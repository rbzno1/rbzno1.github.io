<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Post 45]]></title>
    <url>%2F2019%2F01%2F18%2F2019.1.18%2F</url>
    <content type="text"><![CDATA[后缀数组进阶height数组个人感觉，上面说的一大堆，都是为heightheight数组做铺垫的，heightheight数组才是后缀数组的精髓、 先说定义 $i$号后缀：从$i$开始的后缀 $lcp(x,y)$：字符串xx与字符串yy的最长公共前缀，在这里指xx号后缀与与yy号后缀的最长公共前缀 $height[i]$：$lcp(sa[i],sa[i−1])$，即排名为$i$的后缀与排名为$i−1$后缀的最长公共前缀 $H[i]$：$height[rak[i]]$，即ii号后缀与它前一名的后缀的最长公共前缀 性质：$H[i]⩾H[i−1]−1$ 看以下证明之前 证明引自远航之曲大佬 能够线性计算height[]的值的关键在于h的性质，即h[i]&gt;=h[i-1]-1，下面具体分析一下这个不等式的由来。 我们先把要证什么放在这：对于第i个后缀，设j=sa[rank[i] – 1]，也就是说j是i的按排名来的上一个字符串，按定义来i和j的最长公共前缀就是height[rank[i]]，我们现在就是想知道height[rank[i]]至少是多少，而我们要证明的就是至少是height[rank[i-1]]-1。 好啦，现在开始证吧。 首先我们不妨设第i-1个字符串（这里以及后面指的“第?个字符串”不是按字典序排名来的，是按照首字符在字符串中的位置来的）按字典序排名来的前面的那个字符串是第k个字符串，注意k不一定是i-2，因为第k个字符串是按字典序排名来的i-1前面那个，并不是指在原字符串中位置在i-1前面的那个第i-2个字符串。 这时，依据height[]的定义，第k个字符串和第i-1个字符串的公共前缀自然是height[rank[i-1]]，现在先讨论一下第k+1个字符串和第i个字符串的关系。 第一种情况，第k个字符串和第i-1个字符串的首字符不同，那么第k+1个字符串的排名既可能在i的前面，也可能在i的后面，但没有关系，因为height[rank[i-1]]就是0了呀，那么无论height[rank[i]]是多少都会有height[rank[i]]&gt;=height[rank[i-1]]-1，也就是h[i]&gt;=h[i-1]-1。 第二种情况，第k个字符串和第i-1个字符串的首字符相同，那么由于第k+1个字符串就是第k个字符串去掉首字符得到的，第i个字符串也是第i-1个字符串去掉首字符得到的，那么显然第k+1个字符串要排在第i个字符串前面，要么就产生矛盾了。同时，第k个字符串和第i-1个字符串的最长公共前缀是height[rank[i-1]]，那么自然第k+1个字符串和第i个字符串的最长公共前缀就是height[rank[i-1]]-1。 到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第i个字符串的字典序排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第i个字符串的那个字符串了呀，即sa[rank[i]-1]。也就是说sa[rank[i]]和sa[rank[i]-1]的最长公共前缀至少是height[rank[i-1]]-1，那么就有height[rank[i]]&gt;=height[rank[i-1]]-1，也即h[i]&gt;=h[i-1]-1 唯一有点不懂的就是为啥LCP一定是前面那个后缀而一定不是后面那个呢。。。 然后我又认真读了一遍，发现前提是字典序排名更靠前的那些这个条件。。。在做题的过程中加深理解吧。 不同子串个数题目背景因为NOI被虐傻了，蒟蒻的YJQ准备来学习一下字符串，于是它碰到了这样一道题： 题目描述给你一个长为N的字符串，求不同的子串的个数 我们定义两个子串不同，当且仅当有这两个子串长度不一样 或者长度一样且有任意一位不一样。 子串的定义：原字符串中连续的一段字符组成的字符串 输入输出格式输入格式： 第一行一个整数N 接下来一行N个字符表示给出的字符串 输出格式： 一行一个整数，表示不一样的子串个数 输入输出样例输入样例#1： 125aabaa 输出样例#1： 111 输入样例#2： 123aba 输出样例#2： 15 说明请使用64位整数来进行输出 （具体来说，C++和C选手请使用long long 类型，pascal选手请使用Int64） 由于输入文件过大，请使用 高效的读入方法（具体的，c++和c选手请不要使用cin，pascal选手不需要管） 对于30%的数据，N\le 1000N≤1000 对于100%的数据，N\le 10^5N≤105 题解考虑将子串按照所属后缀分类。 枚举每个后缀，通过上述求出的Height数组我们可以知道每个后缀$i$之前的那些后缀与它的最大公共子串，这一部分之前被统计过了，所以对于这个后缀的$n-sa_i+1$个子串，有$Height_{rki}$个是重复的， 减去累加答案即可。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// luogu-judger-enable-o2// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005int rk[maxn] , sa[maxn] , h[maxn] , pos[maxn] , c[maxn] , n , m, ct;char s[maxn];inline void Sort()&#123; for(int i = 1 ; i &lt;= m ; ++i) c[i] = 0; for(int i = 1 ; i &lt;= ct ; ++i) ++ c[rk[i]]; for(int i = 1 ; i &lt;= m ; ++i) c[i] += c[i-1]; for(int i = ct ; i &gt;= 1 ; --i) sa[c[rk[pos[i]]]--] = pos[i];&#125;inline void getLCP()&#123; int k = 0; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(k) --k; int cr = sa[rk[i]-1]; while(s[i+k] == s[cr+k]) ++k; h[rk[i]] = k; &#125;&#125;inline void SuffixSort()&#123; m = 10000 , ct = n; for(int i = 1 ; i &lt;= n ; ++i) rk[i] = s[i] , pos[i] = i; Sort(); for(int k = 1 ; k &lt;= n ; k &lt;&lt;= 1) &#123; ct = 0; for(int i = 1 ; i &lt;= k ; ++i) pos[++ct] = n - k + i; for(int i = 1 ; i &lt;= n ; ++i) if(sa[i] &gt; k) pos[++ct] = sa[i] - k; Sort(); std::swap(pos,rk); rk[sa[1]] = ct = 1; for(int i = 2 ; i &lt;= n ; ++i) rk[sa[i]] = (pos[sa[i-1]] == pos[sa[i]] &amp;&amp; pos[sa[i-1]+k] == pos[sa[i]+k]) ? ct : ++ct; m = ct; if(m == n) break; &#125; getLCP();&#125;int main()&#123; scanf("%d",&amp;n); scanf("%s",s+1); SuffixSort(); long long ans = 0; for(int i = 1 ; i &lt;= n ; ++i) ans += n + 1 - sa[i] - h[i]; printf("%lld\n",ans);&#125; 顺便放一下SAM的一些笔记（非正式） 果按照普通的字典树来建造的话，是以下的图： 但是我们看着可以发现有很多很多点都是重复的，浪费了很多空间，而且我们看到每个点大部分只有一个儿子，我们就想到利用公共部分把空间压缩，即把某些重复的边删去，连接到别的子树，从而利用公共部分降低空间复杂度，同时我们还要保证新的做法的正确性，并且降低时间复杂度降到大概O(n)O(n)，为了解决这个问题，后缀自动机诞生了qwqqwq 下图是后缀自动机成型样子（没显示failfail指针）： 后缀自动机是这样的:在后缀自动机中,为了节省空间,某个点有可能成为多个结点的儿子,可以保证在后缀自动机中遍历出来的所有字符串不会重复,而且刚好是原串s的所有子串。 基本储存信息： 11、ch[N][26]ch[N][26]：基本的字典树； 22、fail[N]fail[N]：指向上一个与当前节点等价的点 33、len[N]len[N]：表示以当前点为终点的子串的长度 后缀自动机的性质： 11、从任意节点到任意节点结束的路径都是文本串T的子串。 22、后缀自动机是一个根为rootroot的有向无环图 33、任何一个从任意节点到达任意节点p的路径是从根节点到p节点最长路径的一个后缀 …… 算法流程：（假设要插入的字符为cc） 1、定义一个变量p=lastp=last； //lastlast为上一次的节点； 2、定义一个变量np=++cntnp=++cnt //cntcnt为节点编号（也可以理解为时间戳吧，反正差不多就是一种顺序），npnp为新添加的节点 3、last=nplast=np；len[np]=len[p]+1len[np]=len[p]+1 //更新上次的节点以及新节点的长度 4、循环判断：当pp点没有到cc的转移的话，ch[p][c]=npch[p][c]=np；即把pp点添加到cc的转移为npnp，并且pp点跳failfail指针，当pp点有到cc的转移时停止循环 5、当此时pp点为00时，把npnp的failfail指针赋为11（因为根节点rootroot为11） 6、否则的话，意味着此时的pp点有到cc的转移，我们定义q=ch[p][c]q=ch[p][c] 7、当len[q]==len[p]+1len[q]==len[p]+1时，把fail[np]fail[np]赋为pp并退出即可（具体后面会详细讲） 8、否则的话，我们定义一个新节点nq=++cntnq=++cnt，复制节点qq的chch数组，failfail指针给nqnq，len[nq]=len[p]+1len[nq]=len[p]+1，并且把npnp，qq的failfail指针赋为nqnq。循环跳pp点的failfail指针，每次当ch[p][c]==qch[p][c]==q时，ch[p][c]ch[p][c]赋为nqnq （看到这里时是会有点懵逼的，等会结合下文图解及分析一起看） 先贴这部分代码（方便以后使用）： + View Code 强势图解开始！！！ 首先，假设我们已经建立好了文本串TT的后缀自动机，现在要在后面插入字符xx，使自动机成为字符串TxTx的后缀自动机，那么我们先建立一个新节点npnp，并且找到上一个节点pp，循环判断如果pp没有xx儿子的话，那么就向npnp连一条xx的转移，pp点跳failfail指针，直到pp点到了虚拟节点00或者有向x的转移时，停止循环。如果pp点此时是因为有向x的转移而退出的循环，即p!=0。假设此时pp点向x的转移为qq节点，那么就会有以下两种情况： 1、len[q]=len[p]+1len[q]=len[p]+1 我们因为想要压缩空间，那么就必须要共用已有的节点，下面是这种情况的图： 那么我们先考虑从pp点连一条xx的转移到npnp，但是这样可行吗？我们可以看出如果这样连的话，qq点就没有办法到达了，也就是说p−&gt;q−&gt;npp−&gt;q−&gt;np这一字串将会被破坏，那么怎么办呢？我们考虑把qq当做是npnp（因为都是向xx的转移），也就是说，把qq也当做是TT的某个字串的结尾，把npnp的failfail指针指向qq，从而保证算法的正确性（即性质11） 说到这可能大家会有疑问，如果我们不走pp节点就到了qq节点，那就不能保证到qq节点的都是TxTx的后缀了。其实len[p]=len[q]+1len[p]=len[q]+1就已经保证了经过了qq就必定经过了pp，如果不经过pp，那就只能从rootroot节点直接来了，为什么呢，我们运用反证法（转自某大佬）： 假设原命题不成立,那么就有两种可能:（补充：现在文本串为TxTx，也就是说xx是终点） 一.当前的xx字符,之前没有出现过.这样的话,有xx字符的子串必然是后缀,与假设矛盾. 二.当前的xx字符,之前已经出现过.这样的话,有xx字符而不是后缀的子串必然与之前的某个代表字符xx的结点连接,而不是与当前的xx点连接,否则后缀自动机的性质33早就被破坏了,故也与假设矛盾。 那么结束后的图是这样的（红色虚边为failfail指针，实线黑边为chch数组）： 2、len[q]&gt;lenp[p]+1len[q]&gt;lenp[p]+1 这种情况就是下图： 也面临着qq点能不能当做npnp点的问题。但是这种情况与第一种情况的区别在于：第一种情况pp，qq中间不会夹杂其他的字符，而这种情况pp，qq中间是会有其他字符的，我们就不能保证到达qq节点的一定是TxTx的后缀了。 那么我们考虑能不能把这种情况能不能转化为第一种情况呢？答案是肯定的，我们考虑新建一个节点nqnq，使得len[nq]=len[p]+1len[nq]=len[p]+1，这样的话我们就转化为了第一种问题，那么我们把节点qq所有东西复制给新节点nqnq的话，就让nqnq充当第一种问题中的qq，那么我们把qq，npnp的failfail指针赋值为nqnq，nqnq的failfail指针为pp，同时还必须记住让pp节点跳failfail指针，把所有连向qq节点的边都连向nqnq（因为nqnq节点代替了qq节点） 操作完成后就是下图： 图解acabb的后缀自动机过程，建议和代码一起理解！ （没有动图。。。动图太快了不好理解其实是本人不会） 1、插入aa字符： 因为pp一开始等于11（根节点），而所以根节点没有向aa的转移，因此向22连一条向aa的转移，然后跳failfail指针，然而fail[1]=0fail[1]=0，也就是指向了虚拟节点，所以fail[2]=1fail[2]=1（指向根节点） 2、插入cc字符： 建立新的节点33，pp节点为上一个节点22，pp没有向cc的转移，因此添加一个向cc的转移指向33，pp点跳failfail指针到了11,11节点也没有向cc的转移，也添加一个向cc的转移到33，跳failfail指针到00（虚拟节点），所以npnp节点的failfail指针指向11（根节点） 3、（重点）插入aa字符 这种情况就是len[q]=len[p]+1len[q]=len[p]+1的情况了，首先pp为33节点，然而现在pp节点没有向aa的转移，于是向npnp节点连一条aa的转移 并且pp点跳failfail指针到11节点，如下图： 而这时候我们发现pp节点有aa的转移指向22号节点， 并且满足上面所述的第一种情况即len[q]=len[p]+1len[q]=len[p]+1，所以直接把qq节点当做npnp节点 把fail[np]fail[np]赋值为qq，即下图： 4、插入bb字符 pp节点没有bb的转移，于是pp点向npnp连一条bb的转移 pp点跳failfail指针： 我们发现pp点没有bb的转移，于是pp点向npnp连一条bb的转移 pp点跳failfail指针： 最后pp点到了虚拟指针，所以将fail[np]fail[np]赋值为根节点11，完成后如下图： 5、（重点）插入bb字符： 这种情况就是第二种情况:len[q]&gt;len[p]+1len[q]&gt;len[p]+1 首先我们发现pp节点没有bb的转移，于是添加一个到bb的转移为npnp pp跳failfail指针到rootroot： 我们发现pp点有bb的转移到qq节点，并且满足情况22（len[q]&gt;len[p]+1len[q]&gt;len[p]+1），复制qq点的信息到nqnq点（因为它要代替qq节点），即fail[nq]=fail[q]fail[nq]=fail[q]，并且nqnq也像qq一样连一条bb的转移到npnp，同时把qq，npnp的failfail指针赋值为nqnq 最后我们还要按照下图一样，pp点跳failfail指针把所有连向qq的转移都连向nqnq（nqnq代替了qq），如下图： 最终acabbacabb的后缀自动机就完成啦！ 把failfail指针去掉就是下图： 后缀自动机的应用（借鉴了某大佬）： 1、检查字符串pp是不是文本串TT的子串 给定一个文本串TT，求字符串pp是不是TT的子串 首先，我们对文本串TT建立后缀自动机，然后在自动机上直接按照pp的每个字符来转移，如果转移失败的话，说明pp不是TT的子串，这些都是因为后缀自动机满足性质11。 2、不同的子串 给你一个文本串，求一共有多少子串 后缀自动机性质22，因为后缀自动机是一个有向无环图，所以我们可以考虑在上面简单的dpdp，根据性质22，任何子串都会是后缀自动机上的一段路径（包括长度为00的路径），所以我们令f[i]f[i]为ii节点不同路径的条数，即从ii节点开始有多少不同子串，状态转移方程就是：f[u]=∑v:(u,v)∈Ef[v]+1f[u]=∑v:(u,v)∈Ef[v]+1 那么我们最后的答案的话就是f[1]−1f[1]−1因为要去掉根节点长度为00的串 如果要考虑按字典序输出的话，那么就用一个手写栈来写，每次走字典序小的边，走到一个点就输出当前的栈内元素，递归后要回溯！ 3、字典序第kk大的子串 其实这个问题是基于上面这个问题的，我们既然已经求出了每个点不同路径的条数，那么我们就可以选择性的走k小路径 4、字典序最小循环移位 给定一个文本串TT，每次操作可以把最左边的字符移到最右边，请求出字典序最小的循环移位 这个问题的话其实做多了就知道了，我们以T+TT+T来建立后缀自动机，这样的话后缀自动机就会包含每个循环移位的路径，那么我们直接贪心来找字典序最小就行了 【模板】循环移位 5、求两串中的最长公共子串 给定两个字符串为TT和SS，求出它们的最长公共子串 对于这个问题，我们对字符串TT建立后缀自动机，对于SS的每个前缀，在自动机里转移状态，定义一个ll变量，一个pospos变量，分别表示现在匹配的长度，以及现在的位置。我们每匹配成功一次，ll自增一，直到没有状态转移的时候，我们就跳failfail指针，而此时ll就要赋值为len[pos]len[pos]，直到pospos指向虚拟节点（也就是失配，此时l=0l=0）或匹配完成，而答案就是ll的最大值 6、出现次数 对于一个给定的文本串 $T$，有多组询问，每组询问给一个模式串 pp，回答模式串 pp 在字符串 $T$ 中作为子串出现了多少次 我们为文本串TT建立后缀自动机，为每个节点定义一个变量sizesize，初始化为11，根节点与复制节点nq除外，那么我们对每个节点做如下操作：size[fail[pos]]+=size[pos]size[fail[pos]]+=size[pos]，含义是当节点pospos出现了size[pos]size[pos]次，那么以它为后缀的点也会出现这么多次。最后查询size[t]size[t]，tt就是模式串的状态，查询不到则为00 练习： P3804【模板】后缀自动机 没什么好说的，就是模板 P3649[APIO2014]回文串 要用用上面的知识点，灵活运用吧qwqqwq，相信你会举一反三的 今天晚上又读了读lrj的紫书上关于SAM（其实是广义自动机）的介绍，感觉对SAM又了解了一点，对于它的各种神器性质和思想也理解的更多了。 上面那些杂乱的笔记是我偶然翻到一个blog关于一点一点模拟的，可以增加感性理解，不过对于这个高级算法更重要的还是理解其各种性质才能学会构造（吧） 明天一天一定要学会SAM！！！ 看了道很简单的线段树维护最大字段和，连代码都懒得写了。。 简述方法： 分情况讨论，对于当前区间，如果我们想通过左右区间快速合并当前区间信息，需要维护左端开始的的最大子区间，右边开始的，以及当前答案（即左右最大或左边的右最大和右边的左最大合并来更新答案） 参考Code： 1234567inline void update(int p)&#123; s(p)=s(p&lt;&lt;1)+s(p&lt;&lt;1|1);//该区间和为左区间和+右区间和 lm(p)=max(s(p&lt;&lt;1)+lm(p&lt;&lt;1|1),lm(p&lt;&lt;1));//左区间最大子段和 或 左区间和+右区间左子段和 rm(p)=max(s(p&lt;&lt;1|1)+rm(p&lt;&lt;1),rm(p&lt;&lt;1|1));//右区间最大子段和 或 右区间和+左区间右子段和 m(p)=max(max(m(p&lt;&lt;1),m(p&lt;&lt;1|1)),rm(p&lt;&lt;1)+lm(p&lt;&lt;1|1));//左区间最大子段和 或 右区间最大子段和 或 左区间右子段和+右区间左子段和&#125; 还说今天之所以什么都没干成的原因是这个笔记本又卡死了啊啊啊啊。 幸好找到了问题所在，把win10那臭名远扬的自动更新关掉了。]]></content>
      <tags>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 44]]></title>
    <url>%2F2019%2F01%2F13%2F2019.1.13%2F</url>
    <content type="text"><![CDATA[这笔记本真差劲。。比起surface book差了老远。。 我到现在除了能在本地用Vim写个程序以外还啥也不能干。。。 明天最后试试Win10能不能装成功，反正win7要想装成功非常困难。 培训之前肯定把这事弄好。 Dinic算法实现很简单，主要是想明白其正确性，由于每次都会分层，所以最后还是能找到所有的增广路，根据增广路定理最后得到的就是最大流。 我不明白为啥分了层就优化到$O(n^2m)$了。 还加了个多路增广，懒得加当前弧优化了。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 30005#define maxm 100005#define INF 0x7ffffffint hd[maxn] , ct = 1 , MaxFlow , n , m , dep[maxn] , s , t;bool vs[maxn];struct edge&#123; int nxt , to , dis;&#125;e[maxm&lt;&lt;1];inline void add(int x, int y , int d)&#123; e[++ct] = (edge)&#123;hd[x],y,d&#125;; hd[x] = ct;&#125;inline bool bfs()&#123; for(int i = 1 ; i &lt;= n ; ++i) dep[i] = INF; dep[s] = 0; std::queue&lt;int&gt; q; q.push(s); for( ; q.size() ; q.pop()) &#123; int k = q.front(); for(int i = hd[k] ; i ; i = e[i].nxt) if(dep[e[i].to] == INF &amp;&amp; e[i].dis) dep[e[i].to] = dep[k] + 1 , q.push(e[i].to); &#125; return dep[t] != INF;&#125;int dfs(int u , int cfw)&#123; if(u == t || !cfw) return cfw; int flow = 0 , f; for(int i = hd[u] ; i ; i = e[i].nxt) &#123; int v = e[i].to; if(dep[v] == dep[u] + 1 &amp;&amp; (f = dfs(v , std::min(cfw , e[i].dis)))) &#123; flow += f; cfw -= f; e[i].dis -= f , e[i^1].dis += f; if(!cfw) break; &#125; &#125; return flow;&#125;inline int Dinic()&#123; int f; for( ; bfs() ; MaxFlow += dfs(s,INF)); return MaxFlow;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y , d; scanf("%d%d%d",&amp;x,&amp;y,&amp;d); add(x,y,d) , add(y,x,0); &#125; printf("%d\n",Dinic());&#125; 然后顺便学习了最小费用最大流，用的EK+SPFA. 没看懂DIjkstra的势是怎么证明正确性的然后就没学 其实思想很简单，我们始终找源点到汇点的在边有流量的情况下(不管多少)的最短路，然后更新。直到没有增广路。由增广路定理可知此时达到最大流，由于一直走的最短路寻找增广路，所以由贪心可知（很简单的反证）此时费用达到最小。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 5005#define maxm 50005#define INF 0x7ffffffint hd[maxn] , n , m , s , t , ct = 1, fw[maxn] , d[maxn] , pre[maxn] , ep[maxn] , MxFw;long long MnCo;bool vis[maxn];struct edge&#123; int next , to , fw , dis;&#125;e[maxm&lt;&lt;1];inline void add(int x , int y , int fw , int dis)&#123; e[++ct] = (edge)&#123;hd[x],y,fw,dis&#125;; hd[x] = ct;&#125;inline bool bfs()&#123; std::queue&lt;int&gt; q; std::memset(d,0x7f,sizeof(d)); std::memset(fw,0x7f,sizeof(fw)); std::memset(vis,false,sizeof(vis)); vis[s] = true , d[s] = 0 , pre[t] = -1; q.push(s); for(int k ; q.size() ; q.pop()) &#123; k = q.front(); vis[k] = false; for(int i = hd[k] ; i ; i = e[i].next) &#123; int v = e[i].to; if(d[k] + e[i].dis &lt; d[v] &amp;&amp; e[i].fw) &#123; fw[v] = std::min(fw[k] , e[i].fw); pre[v] = k , ep[v] = i;// if(~pre[t]) return true; d[v] = d[k] + e[i].dis; if(!vis[v]) vis[v] = true , q.push(v); &#125; &#125; &#125; return (bool)~pre[t];&#125;inline void mcmf()&#123; for( ; bfs() ; ) &#123; int now = t; MxFw += fw[t]; MnCo += fw[t] * d[t]; while(now != s) &#123; e[ep[now]].fw -= fw[t]; e[ep[now]^1].fw += fw[t]; now = pre[now]; &#125; &#125;&#125;int main()&#123;// freopen("data.out.txt","r",stdin); scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y , z, d; scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;d); add(x,y,z,d) , add(y,x,0,-d); &#125; mcmf(); printf("%d %lld\n",MxFw , MnCo);&#125; 好像费用流有更快的算法，不过网络流最重要的又不是写板子。。。 接下来可能会学完左偏树，LCT，真希望不要退役啊。 不退役我还会认认真真学完算导和具体数学。可能还会在多学一点数学知识。 （退役了补文化课也不是很糟糕的感觉]]></content>
      <tags>
        <tag>最小费用最大流 Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 43]]></title>
    <url>%2F2019%2F01%2F11%2F2019.1.11%2F</url>
    <content type="text"><![CDATA[网络流学习笔记这是信息学中比较重要的一个算法了，可以用来处理很多图论模型。 先说说网络最大流，主要来自进阶指南，blog的学习。 非常重要的增广路定理回家看算导吧qwq 首先介绍一些基本的网络流的概念。 什么是网络流在一个有向图上选择一个源点，一个汇点，每一条边上都有一个流量上限（以下称为容量），即经过这条边的流量不能超过这个上界，同时，除源点和汇点外，所有点的入流和出流都相等，而源点只有流出的流，汇点只有汇入的流。这样的图叫做网络流。 所谓网络或容量网络指的是一个连通的赋权有向图 D= （V、E、C） ， 其中V 是该图的顶点集，E是有向边(即弧)集，C是弧上的容量。此外顶点集中包括一个起点和一个终点。网络上的流就是由起点流向终点的可行流，这是定义在网络上的非负函数，它一方面受到容量的限制，另一方面除去起点和终点以外，在所有中途点要求保持流入量和流出量是平衡的。（引自百度百科） 定义我们定义：源点：只有流出去的点汇点：只有流进来的点流量：一条边上流过的流量容量：一条边上可供流过的最大流量残量：一条边上的容量-流量 几个基本性质基本性质一： 对于任何一条流，总有流量&lt;=容量 这是很显然的 基本性质二 对于任何一个不是源点或汇点的点u，总有 $\sum_{p∈E}k[p][u]=\sum_{q∈E}k[u][q]$（其中k[i][j]表示i到j的流量 这个也很显然，即一个点（除源点和汇点）的入流和出流相等 基本性质三 对于任何一条有向边(u,v)，总有 $k[u][v]==−k[v][u]$ 这个看起来并不是很好理解，它的意思就是一条边的反边上的流是这条边的流的相反数，可以这么想，就是如果有k[u][v]的流从u流向v，也就相当于有-k[v][u]的流从v流向u。这条性质非常重要。 这些都不是很难理解，不过对于性质三，他有什么用呢？ 后面关于巧妙调整网络中的流量就知道了。 既然是图论，接下来肯定少不了图。 抄袭严重 面是所有最大流算法的精华部分：引入反向边 为什么要有反向边呢？ 我们第一次找到了1-2-3-4这条增广路，这条路上的delta值显然是1。于是我们修改后得到了下面这个流。（图中的数字是容量） 这时候(1,2)和(3,4)边上的流量都等于容量了，我们再也找不到其他的增广路了，当前的流量是1。 但这个答案明显不是最大流，因为我们可以同时走1-2-4和1-3-4，这样可以得到流量为2的流。 那么我们刚刚的算法问题在哪里呢？问题就在于我们没有给程序一个”后悔”的机会，应该有一个不走(2-3-4)而改走(2-4)的机制。那么如何解决这个问题呢？回溯搜索吗？那么我们的效率就上升到指数级了。 而这个算法神奇的利用了一个叫做反向边的概念来解决这个问题。即每条边(I,j)都有一条反向边(j,i)，反向边也同样有它的容量。 我们直接来看它是如何解决的： 在第一次找到增广路之后，在把路上每一段的容量减少delta的同时，也把每一段上的反方向的容量增加delta。即在Dec(c[x,y],delta)的同时，inc(c[y,x],delta) 我们来看刚才的例子，在找到1-2-3-4这条增广路之后，把容量修改成如下 这时再找增广路的时候，就会找到1-3-2-4这条可增广量，即delta值为1的可增广路。将这条路增广之后，得到了最大流2。 那么，这么做为什么会是对的呢？我来通俗的解释一下吧。 事实上，当我们第二次的增广路走3-2这条反向边的时候，就相当于把2-3这条正向边已经是用了的流量给”退”了回去，不走2-3这条路，而改走从2点出发的其他的路也就是2-4。（有人问如果这里没有2-4怎么办，这时假如没有2-4这条路的话，最终这条增广路也不会存在，因为他根本不能走到汇点）同时本来在3-4上的流量由1-3-4这条路来”接管”。而最终2-3这条路正向流量1，反向流量1，等于没有流量。 这就是这个算法的精华部分，利用反向边，使程序有了一个后悔和改正的机会换句话说我们用巧妙的方式配合增广路定理避免了搜索回溯来寻找最优方案。 由于状态不好，只写出来了EK（居然跑过了1e4点1e5边的图，luogu数据是真的水） Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 10005#define maxm 100005#define INF 0x7ffffffint head[maxn] , ct = 1 , n , m , s , t , MaxFlow, fw[maxn] , pre[maxn] , Epre[maxn];struct edge&#123; int nxt , to , dis;&#125;e[maxm&lt;&lt;1];inline void add(int x , int y , int d)&#123; e[++ct] = (edge)&#123;head[x],y,d&#125;; head[x] = ct;&#125;inline int bfs(int s , int t)&#123; std::memset(pre,-1,sizeof(pre)); std::memset(Epre,-1,sizeof(Epre)); pre[s] = Epre[s] = 0; std::queue&lt;int&gt; q; q.push(s); fw[s] = INF; for( ; q.size() ; q.pop()) &#123; int nw = q.front(); if(nw == t) break; for(int i = head[nw] ; i ; i = e[i].nxt) if(e[i].dis &gt; 0 &amp;&amp; !~pre[e[i].to]) fw[e[i].to] = std::min(fw[nw] , e[i].dis) , Epre[e[i].to] = i , pre[e[i].to] = nw , q.push(e[i].to); &#125; if(~pre[t]) return fw[t]; else return -1;&#125;inline void EK(int s , int t)&#123; int flow = 0; while(~(flow = bfs(s,t))) &#123;// printf("Cur Arguement Way:%d\n",flow); int k = t;// printf("THE ROAD\n"); while(k != s) &#123;// printf("%d ",k); e[Epre[k]].dis -= flow; e[Epre[k]^1].dis += flow; k = pre[k]; &#125;// printf("THE FLOW: %d\n",flow); MaxFlow += flow; &#125;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y , d; scanf("%d%d%d",&amp;x,&amp;y,&amp;d); add(x,y,d) , add(y,x,0); &#125; EK(s,t); printf("%d",MaxFlow);&#125; 当然Dinic是必须学的，明天抽时间吧，进度比我想象的顺利，给我可能是最后的NOI培训做个准备吧。]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 42]]></title>
    <url>%2F2019%2F01%2F10%2F2019.1.10%2F</url>
    <content type="text"><![CDATA[二分图学习笔记从今天开始的未来5天将学习图论进阶，主要涉及进阶指南，luogu网课，以及有些（大量）图论定理的证明。 由于我的学习习惯，学个啥都得全弄明白可能导致进度偏慢。。不过严谨点总没太大坏处。 我们从二分图的定义说起 二分图：可以分成两组点集，点集内部无边相连，两点集之间有边。 十分好理解。 接下来要介绍二分图判定定理：一个图是二分图，当且仅当这个图不存在奇环。 我们需要证明必要性和充分性。 1.必要性。二分图的边是在两个集合里交替的，显然不会出现奇圈。 必要性：考虑对图进行二分图染色。如果两个节点之间有一条长度为奇数的路径，那么显然两个点颜色不同，反之如果两个节点之间有一条长度为偶数的路径，那么两个点颜色必定相同（这是显然的）。如果图中存在奇环，那么我们任取环上两点，可以发现如果从环的两边走，那么两条路径必定是一奇一偶的，所以我们无法就行二分图染色，即原图不是二分图。 充分性：还是考虑二分图染色的过程。假设某个点的颜色既是黑色又是白色，那么说明从起点到这个点存在一条奇路径，也存在一条偶路径，那么我们就可以构造出一个奇环（因为两条路径之和是奇数）（注意这里的环不一定是简单环，有可能有某些边被走两次）。而原图不存在奇环，所以这种情况不可能发生，即原图一定可以被二分图染色，即原图就是个二分图。 这是来自ZQC的一个语言描述的证明，不过是正确的，想看更严谨的符号演绎证明（其实就是用符号表达啦）： 这样我们就搞定了二分图相关的第一个定理。并且可以用它来进行二分图染色从而判定二分图。 接下来就是更重要的二分图匹配定理相关，包括： Berge定理 Hall定理 Konig定理 hall定理是判定二分图是否存在完全匹配的定理，Konig等到点覆盖问题时会写。。 定理1：（Berge 1957）M是最大匹配的充要条件是G中无M的可增广轨 定理2：如果从一个点A出发，没有找到增广路径，那么无论再从别的点出发找到多少增广路径来改变现在的匹配，从A出发都永远找不到增广路径。 定理1，2可以看做匈牙利算法正确性的证明。 先给出定理1的证明（感谢LOJ群@pupil大佬的指点，我稍作改动使得更好理解）： 必要性显然。充分性使用反证法证明。 如果匹配M不是最大匹配且无增广轨，设M’是最大匹配，异或后得到边集H。 对于H，每条边的顶点要么度数为2要么度数为1。 这种图只能是交错边偶环或交错边形成的链。并且可以知道必定有一条链其起点和终点都是非匹配点（因为点集不同，且M’要大），又因为这是一条交错边的链，所以这是M的一条增广轨，与假设矛盾。 因此匹配M在无增广轨的情况下必定是二分图最大匹配。 怕我说的有问题，再找一个网上的（一般的图论书里这种定理肯定有证明，有时间买一本） 假设M不是最大匹配，则说明存在比M更大的一个匹配M”,则取H ={M并M” - M交M”},则H里，顶点的度不是1就是2.不存在度为0的顶点。则H的连通片，或者是M”与M中的边交替出现的一个偶圈，或者是M”与M中的边交替出现的一条轨。又因为|M”| &gt; |M|,必有H的某个连通片是轨，且此轨是M”的边为终止边（实际上包含起边和终边），于是得到了M的可增广轨，与M中无增广轨矛盾。 下面证明定理2： 假设我们对点A进行了两次，增广，第一次没有找到增广路，第二次找到了。下面需要证明这样是矛盾的，因为如果第二次可以找到，那么在第一次找时就应该找到了。 前面说过了实际上这个定理利用了1，或者它们证明的方法完全是一样的，我们可以用在第一次增广A时的那个匹配替换上面的M，而第二次增广A之后得到的那个匹配集显然就是上面的M”。两者的区别就在现在那个增广轨的位置已经确定了，因为这里的A点首先他必然不在M中，但是第二次从A处找到了一条增广轨，所以它必然的被加入了M”中，这也就意味着定理1证明中苦苦寻觅的那个增广轨在这里变成了确定的，就是从A开始的，也就是说实际上在第1次增广A时就应该找到这条增广轨了，于是矛盾。 匈牙利算法的原理就是不断找到增广路更新，从而得到最大的图匹配。 代码早就写过了，主要就是证明其正确性，毕竟背板子做图论题没有什么意思。 下午有时间再去思考一下这些定理以及推论，并且完成下Hall定理的推论。 接下来是二分图的覆盖与独立集 最小点覆盖问题求出一个最小点集S，使得每条边都有至少一个端点被选中。 Konig定理最小点覆盖=最大图匹配 证明鸣谢@Matrix67 假如我们已经通过匈牙利算法求出了最大匹配（假设它等于M），下面给出的方法可以告诉我们，选哪M个点可以覆盖所有的边。匈牙利算法需要我们从右边的某个没有匹配的点，走出一条使得“一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现”的路（交错轨，增广路）。但是，现在我们已经找到了最大匹配，已经不存在这样的路了。换句话说，我们能寻找到很多可能的增广路，但最后都以找不到“终点是还没有匹配过的点”而失败。我们给所有这样的点打上记号：从右边的所有没有匹配过的点出发，按照增广路的“交替出现”的要求可以走到的所有点（最后走出的路径是很多条不完整的增广路）。那么这些点组成了最小覆盖点集：右边所有没有打上记号的点，加上左边已经有记号的点。看图，右图中展示了两条这样的路径，标记了一共6个点（用 “√”表示）。那么，用红色圈起来的三个点就是我们的最小覆盖点集。首先，为什么这样得到的点集点的个数恰好有M个呢？答案很简单，因为每个点都是某个匹配边的其中一个端点。如果右边的哪个点是没有匹配过的，那么它早就当成起点被标记了；如果左边的哪个点是没有匹配过的，那就走不到它那里去（否则就找到了一条完整的增广路）。而一个匹配边又不可能左端点是标记了的，同时右端点是没标记的（不然的话右边的点就可以经过这条边到达了）。因此，最后我们圈起来的点与匹配边一一对应。其次，为什么这样得到的点集可以覆盖所有的边呢？答案同样简单。不可能存在某一条边，它的左端点是没有标记的，而右端点是有标记的。原因如下：如果这条边不属于我们的匹配边，那么左端点就可以通过这条边到达（从而得到标记）；如果这条边属于我们的匹配边，那么右端点不可能是一条路径的起点，于是它的标记只能是从这条边的左端点过来的（想想匹配的定义），左端点就应该有标记。最后，为什么这是最小的点覆盖集呢？这当然是最小的，不可能有比M还小的点覆盖集了，因为要覆盖这M条匹配边至少就需要M个点（再次回到匹配的定义）。证完了。 进阶指南上正好相反，从左边非匹配点出发标记，最后左边未被标记的和右边被标记的和上面是一一对应的。 PS：Matrix67的post好多啊。而且都很有意思的样子。还有演算法笔记似乎是不错的学习资料： http://www.csie.ntnu.edu.tw/~u91029/ 好像是台湾某大学的。]]></content>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 41]]></title>
    <url>%2F2019%2F01%2F09%2F2019.1.9%2F</url>
    <content type="text"><![CDATA[WANNAFLY DIV1 A. Treepath链接： https://ac.nowcoder.com/acm/contest/15/A 题目描述给定一棵n个点的树，问其中有多少条长度为偶数的路径。路径的长度为经过的边的条数。x到y与y到x被视为同一条路径。路径的起点与终点不能相同。 输入描述:1234第一行一个数n表示点的个数；接下来n-1行，每行两个整数x，y表示边；保证输入数据形成一棵树；1&lt;=n&lt;=100000 输出描述:1一行一个整数表示答案。 示例1 输入12331 21 3 输出11 题解题意简洁明了。我喜欢。 怎么统计长度为偶数的路径呢？不难想到奇数和奇数，偶数和偶数组成长度为偶数的路径，当然我们还得计算长度为奇数的路径。 但是考虑以任意点为根时，树上两点的路径不管过不过根，我们都只需要看他们到根的距离相加是不是偶数就可以了，这是因为LCA到根的距离是两倍，在模2意义下为0，所以两点间距离在模2意义下（也就是只看奇偶性）就是两点到根路径的和，这样这道题就很好统计了。 我是不会说一开始一想到要么过根要么不过根我差点写了点分治。 Code： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define maxn 100005int n , o , e;long long ans;std::vector&lt;int&gt; g[maxn]; void dfs(int x , int fx , int dep)&#123; if(dep &amp; 1) ans += o , ++o; else ans += e , ++e; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i]; if(v == fx) continue; dfs(v , x , dep + 1); &#125;&#125; int main()&#123; scanf("%d",&amp;n); int x , y; for(int i = 1 ; i &lt; n ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); g[x].push_back(y); g[y].push_back(x); &#125; dfs(1,1,0); printf("%lld\n",ans);&#125; WANNAFLY DIV1 B. Xorto链接： https://ac.nowcoder.com/acm/contest/15/B 题目描述给定一个长度为n的整数数组，问有多少对互不重叠的非空区间，使得两个区间内的数的异或和为0。 输入描述:123第一行一个数n表示数组长度；第二行n个整数表示数组；1&lt;=n&lt;=1000,0&lt;=数组元素&lt;100000。 输出描述:1一行一个整数表示答案。 示例1 输入1230 0 0 输出15 说明1([1,1],[2,2]),([1,1],[3,3]),([1,1],[2,3]),([1,2],[3,3]),([2,2],[3,3]) 题解本场比赛的第二道送分题。 显然关于异或连续区间我们常用的方法是前缀异或，这时问题等价为选择四个数升序异或和为0。 关于这个统计，如果我们枚举所有$O(n^4)$4元组，恭喜你TLE. 然后我们改进一下枚举，从大到小枚举右端点，然后在这个右端点的基础上枚举左端点，同时确保右端点右边的所有区间异或值已经被加入一个桶，然后统计即可。 也就是说我们通过更改枚举顺序，避免右边的区间被重复加入，通过桶优化了时间复杂度。 时间复杂度$\Theta(n^2)$ Code： 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;map&gt;#define maxn 1024int s[maxn] , n , c[maxn&lt;&lt;8];long long ans;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;s[i]) , s[i] ^= s[i-1]; for(int r = n ; r &gt;= 1 ; --r) &#123; for(int l = 0 ; l &lt; r ; ++l) ans += c[s[r]^s[l]]; for(int nr = r ; nr &lt;= n ; ++nr) ++c[s[nr]^s[r-1]]; &#125; printf("%lld\n",ans);&#125; luoguP1736 创意吃鱼法题目背景感谢@throusea 贡献的两组数据 题目描述回到家中的猫猫把三桶鱼全部转移到了她那长方形大池子中，然后开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 ^_*）。她发现，把大池子视为01矩阵（0表示对应位置无鱼，1表示对应位置有鱼）有助于决定吃鱼策略。 在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。 猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？ 输入输出格式输入格式： 有多组输入数据，每组数据： 第一行有两个整数n和m（n,m≥1），描述池塘规模。接下来的n行，每行有m个数字（非“0”即“1”）。每两个数字之间用空格隔开。 对于30%的数据，有n,m≤100 对于60%的数据，有n,m≤1000 对于100%的数据，有n,m≤2500 输出格式： 只有一个整数——猫猫一口下去可以吃掉的鱼的数量，占一行，行末有回车。 输入输出样例输入样例#1： 123454 60 1 0 1 0 00 0 1 0 1 01 1 0 0 0 10 1 1 0 1 0 输出样例#1： 13 说明右上角的 1231 0 00 1 00 0 1 题解我好像又做了一道水题。。。看了看有思路就写了。 首先我们能想到二分答案，因为对于一个大正方形它里面的小正方形也合法。 然后对于每个答案，预处理每个点向左上方和右上方的最大连续长度以及二维前缀和，可以在$O(n^2)$的时间里递推完成。对于枚举的每个点，我们都能通过预处理的信息$O(1)$判断其合法性（左上或右上长度大于等于当前答案，并且通过前缀和容斥得到的这个正方形区间的1的个数等于答案） 最后时间复杂度$\Theta(Tn^2logn)$ 好像还有什么悬线法之类可以优化到平方，不过感觉没什么区别。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 2505int f[maxn][maxn] , g[maxn][maxn] , h[maxn][maxn] , s[maxn][maxn] , ss[maxn] , n , m;inline bool solve(int cur)&#123;// printf("CUR:%d\n",cur); for(int i = cur ; i &lt;= n ; ++i) for(int j = cur ; j &lt;= m ; ++j) &#123;// printf("THE SQUARE%d %d %d %d\n",i,j,g[i][j] - g[i-cur][j] - g[i][j-cur] + g[i-cur][j-cur],f[i][j]); if(f[i][j] &lt; cur &amp;&amp; h[i][j-cur+1] &lt; cur) continue; if(g[i][j] - g[i-cur][j] - g[i][j-cur] + g[i-cur][j-cur] != cur) continue; return true; &#125; return false;&#125;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m) != EOF) &#123; std::memset(f,0,sizeof(f)); std::memset(g,0,sizeof(g)); std::memset(h,0,sizeof(h)); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) scanf("%d",&amp;s[i][j]); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) &#123; if(!s[i][j]) continue; f[i][j] = f[i-1][j-1] + s[i][j]; &#125; for(int i = 1 ; i &lt;= n ; ++i) for(int j = m ; j &gt;= 1 ; --j) &#123; if(!s[i][j]) continue; h[i][j] = h[i-1][j+1] + s[i][j]; &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123; std::memset(ss,0,sizeof(ss)); for(int j = 1 ; j &lt;= m ; ++j) ss[j] = ss[j-1] + s[i][j]; for(int j = 1 ; j &lt;= m ; ++j) g[i][j] = g[i-1][j] + ss[j]; &#125;// puts("THE INFO");// for(int i = 1 ; i &lt;= n ; ++i)// for(int j = 1 ; j &lt;= m ; ++j)// printf("%d %d %c",f[i][j],g[i][j],(j==m)?10:32); int l = 1 , r = std::min(n,m) , ans = 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(solve(mid)) ans = mid , l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <tags>
        <tag>qwq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 40]]></title>
    <url>%2F2019%2F01%2F08%2F2019.1.8%2F</url>
    <content type="text"><![CDATA[以前经常听说树套树很难写，今天写了一下感觉挺简单的啊。 最起码是1A233. 3196: Tyvj 1730 二逼平衡树Description您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：1.查询k在区间内的排名2.查询区间内排名为k的值3.修改某一位值上的数值4.查询k在区间内的前驱(前驱定义为小于x，且最大的数)5.查询k在区间内的后继(后继定义为大于x，且最小的数) Input第一行两个数 n,m 表示长度为n的有序序列和m个操作第二行有n个数，表示有序序列下面有m行，opt表示操作标号若opt=1 则为操作1，之后有三个数l,r,k 表示查询k在区间[l,r]的排名若opt=2 则为操作2，之后有三个数l,r,k 表示查询区间[l,r]内排名为k的数若opt=3 则为操作3，之后有两个数pos,k 表示将pos位置的数修改为k若opt=4 则为操作4，之后有三个数l,r,k 表示查询区间[l,r]内k的前驱若opt=5 则为操作5，之后有三个数l,r,k 表示查询区间[l,r]内k的后继 Output对于操作1,2,4,5各输出一行，表示查询结果 Sample Input9 6 4 2 2 1 9 4 0 1 1 2 1 4 3 3 4 10 2 1 4 3 1 2 5 9 4 3 9 5 5 2 8 5 Sample Output2 4 3 4 9 HINT1.n和m的数据范围：n,m&lt;=50000 2.序列中每个数的数据范围：[0,1e8] 3.虽然原题没有，但事实上5操作的k可能为负数 题解这道题暂时学习的是经典的线段树套平衡树(Treap)的做法。 重在理解和认识这个数据结构。 我们对于线段树的每一个区间，用一颗Treap来维护，由于每个节点只在线段树的$\Theta(logn)$个区间里，所以平衡树最多也只需要维护$\Theta(nlogn)$，我一开始听说这种东西还不明白这到底是怎么搞得，看了看别人的实现发现非常简单。HPD也没有每条链单独开一颗线段树而是放在一颗线段树里处理的啊。 同样我们用一片Treap森林维护每个区间就可以啦。 由于每次查询只会分成$\Theta(logn)$个区间，每个区间用Treap做到$O(logn)$处理即可。 所以好像能用树套树维护的最重要一点和线段树一样依旧是满足可合并性。。这样一来就能想到根号算法的适用性之广了。。 具体来说：操作一：查询区间内数的排名 满足子区间可加性，及查每个小区间有多少个比当前数小的，加起来+1即为排名 将查询区间分成$O(logn)$个区间，每个区间用Treap查询多少个比当前数小的（和查排名略有不同） 时间复杂度$O(log^2n)$ 操作二：查询区间第k大 由于这个不满足区间可加性，因此不能直接利用树套树完成。 但是我们知道答案随k增大而增大，因此二分权值查询的排名有单调性。可以二分查找转化为第一问。 时间复杂度$O(log^3n)$ 巨慢无比。。。 操作三：单点修改。 转化成删除原数加入新数。 由于每个元素最多在$O(logn)$个线段树区间内，每个区间的平衡树可以在$O(logn)$的时间里完成插入删除，所以时间复杂度是$O(log^2n)$ 操作四和五 均满足子区间答案的可合并性质，因此对$O(logn)$个区间$O(logn)$查询前驱后继再分别取最大最小即可。 时间复杂度$O(log^2n)$ 这样我们就完美的解决了这道问题。 当然200行代码才是最重要的233 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ls ch[0][x]#define rs ch[1][x]#define INF 2147483647int val[maxn] , n , m;namespace Treap&#123; int ch[2][maxn&lt;&lt;4] , sz[maxn&lt;&lt;4] , tot , ct[maxn&lt;&lt;4] , v[maxn&lt;&lt;4] , p[maxn&lt;&lt;4]; inline void pushup(int x)&#123; sz[x] = ct[x] + sz[ls] + sz[rs]; &#125; inline int newnode(int k) &#123; ++tot; sz[tot] = ct[tot] = 1 , v[tot] = k , p[tot] = rand()%998244353; return tot; &#125; inline void rotate(int&amp; x , int tp) &#123; int s = ch[tp][x]; ch[tp][x] = ch[tp^1][s]; ch[tp^1][s] = x; sz[s] = sz[x]; pushup(x); x = s; &#125; void ins(int&amp; x , int k) &#123; if(!x)&#123; x = newnode(k); return ; &#125; else ++sz[x]; if(v[x] == k) ++ct[x]; else if(v[x] &gt; k) &#123; ins(ls , k); if(p[ls] &lt; p[x]) rotate(x , 0); &#125; else&#123; ins(rs , k); if(p[rs] &lt; p[x]) rotate(x , 1); &#125; &#125; void del(int&amp; x , int k) &#123; if(!x) return ; if(v[x] == k) &#123; if(ct[x] &gt; 1) --ct[x] , --sz[x]; else if(!ls || !rs) x = ls + rs; else if(p[ls] &lt;= p[rs]) rotate(x,0) , del(x, k); else rotate(x,1) , del(x , k); return ; &#125; --sz[x]; if(v[x] &gt; k) del(ls , k); else del(rs , k); &#125; inline int qPre(int k , int x) &#123; int ans = -INF; while(x) &#123; if(v[x] &lt; k) ans = v[x] , x = rs; else x = ls; &#125; return ans; &#125; inline int qNxt(int k , int x) &#123; int ans = INF; while(x) &#123; if(v[x] &gt; k) ans = v[x] , x = ls; else x = rs; &#125; return ans; &#125; inline int Rank(int k , int x) &#123; while(x) &#123; if(sz[ls] &lt; k &amp;&amp; sz[ls] + ct[x] &gt;= k) return v[x]; if(sz[ls] &lt; k) k -= sz[ls] + ct[x] , x = rs; else x = ls; &#125; return INF; &#125; inline int getRank(int k , int x) &#123; int ans = 0; while(x) &#123; if(v[x] == k) return ans + sz[ls]; else if(v[x] &gt; k) x = ls; else ans += sz[ls] + ct[x] , x = rs; &#125; return ans; &#125;&#125;namespace SegmentTree&#123; int seg[maxn&lt;&lt;2] , sl[maxn&lt;&lt;2] , sr[maxn&lt;&lt;2]; void build(int p , int l , int r) &#123; sl[p] = l , sr[p] = r; for(int i = l ; i &lt;= r ; ++i) Treap::ins(seg[p] , val[i]); if(l == r) return ; int mid = l + r &gt;&gt; 1; build(p &lt;&lt; 1 , l , mid); build(p &lt;&lt; 1 | 1 , mid + 1 , r); &#125; void upd(int p , int pos , int v) &#123; Treap::del(seg[p] , val[pos]); Treap::ins(seg[p] , v); if(sl[p] == sr[p]) return; int mid = sl[p] + sr[p] &gt;&gt; 1; if(pos &lt;= mid) upd(p &lt;&lt; 1 , pos , v); else upd(p &lt;&lt; 1 | 1 , pos , v); &#125; int qPre(int p , int l , int r , int v) &#123; int mid = sl[p] + sr[p] &gt;&gt; 1 , ans = -INF; if(l &lt;= sl[p] &amp;&amp; sr[p] &lt;= r) return Treap::qPre(v , seg[p]); if(l &lt;= mid) ans = std::max(ans , qPre(p &lt;&lt; 1 , l , r , v)); if(r &gt; mid) ans = std::max(ans , qPre(p &lt;&lt; 1 | 1 , l , r , v)); return ans; &#125; int qNxt(int p , int l , int r , int v) &#123; int mid = sl[p] + sr[p] &gt;&gt; 1 , ans = INF; if(l &lt;= sl[p] &amp;&amp; sr[p] &lt;= r) return Treap::qNxt(v , seg[p]); if(l &lt;= mid) ans = std::min(ans , qNxt(p &lt;&lt; 1 , l , r , v)); if(r &gt; mid ) ans = std::min(ans , qNxt(p &lt;&lt; 1 | 1 , l , r , v)); return ans; &#125; int getRank(int p , int l , int r , int v) &#123; if(l &lt;= sl[p] &amp;&amp; sr[p] &lt;= r) return Treap::getRank(v , seg[p]); int mid = sl[p] + sr[p] &gt;&gt; 1 , ans = 0; if(l &lt;= mid) ans += getRank(p &lt;&lt; 1 , l , r , v); if(r &gt; mid ) ans += getRank(p &lt;&lt; 1 | 1 , l , r , v); return ans; &#125; int Rank(int l , int r , int v) &#123; int L = 0 , R = INF , ans = INF; while(L &lt;= R) &#123; int mid = L + R &gt;&gt; 1; if(getRank(1 , l , r , mid) &lt; v) ans = mid , L = mid + 1; else R = mid - 1; &#125; return ans; &#125; void print(int l , int r , int p) &#123; if(l == r) &#123; printf("LEAF : %d %d %d\n",seg[p] , sl[p] , sr[p]); return ; &#125; int mid = l + r &gt;&gt; 1; print(l,mid,p&lt;&lt;1); printf("THE RANGE: %d %d INFO : %d %d %d\n",l,r,seg[p],sl[p],sr[p]); print(mid+1,r,p&lt;&lt;1|1); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;val[i]); SegmentTree::build(1,1,n); // 1 is the root of SegmentTree// SegmentTree::print(1,n,1);// return 0; for(int i = 1; i &lt;= m ; ++i) &#123; int op , l , r , v; scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op == 1) scanf("%d",&amp;v), printf("%d\n",SegmentTree::getRank(1,l,r,v) + 1);// the v rank number if(op == 2) scanf("%d",&amp;v), printf("%d\n",SegmentTree::Rank(l,r,v));//the v biggest number,O(log^3n) if(op == 3) SegmentTree::upd(1,l,r) , val[l] = r; if(op == 4) scanf("%d",&amp;v) , printf("%d\n",SegmentTree::qPre(1,l,r,v)); if(op == 5) scanf("%d",&amp;v) , printf("%d\n",SegmentTree::qNxt(1,l,r,v)); &#125;&#125; 不过就是写的时间有点长，毕竟谨慎，用了将近三个小时写完qvq。 看看NOI组别还有什么是需要提前学习学习的qwq。]]></content>
      <tags>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Starrydream]]></title>
    <url>%2F2019%2F01%2F07%2FStarrydream%2F</url>
    <content type="text"><![CDATA[A starry sky Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>nothing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 39]]></title>
    <url>%2F2019%2F01%2F07%2F2019.1.7%2F</url>
    <content type="text"><![CDATA[这两天由于种种缘故没能写Post，主要是因为surface book充电线被我妈忘在家里结果我就什么都干不了。 今天终于拿过来了，这笔记本倒是挺高配，不过我去郑州培训估计也舍不得。 讲真不怎么想去郑州，估计是个坑钱的培训，要不是看有lyd这种讲师我是肯定不会去的。 唯一值得高兴的是终于有个笔记本了。 dessert甜品囤积者（1）时间限制：1秒，内存限制：128MB 读入文件名：dessert.in 输出文件名：dessert.out 【题目描述】放假在家，甜品总是少不了的。 最近你已经瞄中了一家甜品店的甜品，打算接下来连续n天都要吃那里的甜品了。你已经知道了甜品店每天的甜品价格，第i天每袋甜品的价格是ai。而你也计划好了每天要吃的甜品袋数，第i天要吃si袋甜品。 每天你都可以买任意多袋甜品，吃不完可以囤积着并不用担心过期变质，那么为了满足n天的甜品需求，你至少要花费多少钱呢。 【输入格式】输入共3行。 第一行输入一个正整数n，表示天数。 第二行输入n个正整数，表示第1天到第n天的甜品价格ai，输入用一个空格分隔。 第三行输入n个正整数，表示第1天到第n天计划要吃的甜品袋数si，输入用一个空格分隔。 【输出格式】输出共一行，包含一个整数，表示最小花费。 【输入输出样例1】dessert.in 5 3 5 7 1 6 5 9 1 1 10 dessert.out 56 【输入输出样例2】dessert.in 5 3 10 8 3 10 9 5 8 4 7 dessert.out 99 【输入输出样例3】dessert.in 5 8 6 5 8 7 10 5 5 1 7 dessert.out 175 【数据规模与约定】对于前40%的数据，1≤n≤100，1≤ai,si≤1000； 对于前70%的数据，1≤n≤1000； 对于100%的数据，1≤n≤100000，1≤ai,si≤100000。 题解这道题是一道挺经典的简单贪心。 由于每天买的数量没有限制，所以对于每一天的需求，只需要从他（当然包括这一天）前面最便宜的买好就可以了。程序实现也很简单。不知道为什么做了这么一道水题。 Code： 12 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int n , f[maxn] , p[maxn] , s[maxn];struct Deque&#123; int q[maxn] , l , r; Deque()&#123; l = 1 , r = 0; &#125; inline void clear()&#123; l = 1 , r = 0; &#125; inline void push(int x)&#123; q[++r] = x; &#125; inline void pop_front()&#123; q[l++] = 0; &#125; inline void pop_back()&#123; q[r--] = 0; &#125; inline int front()&#123; return q[l]; &#125; inline int back()&#123; return q[r]; &#125; inline int size()&#123; return r-l+1; &#125;&#125;q;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;s[i]); for(int i = 1 ; i &lt;= n ; ++i) &#123; while(q.size() &amp;&amp; p[i] &lt;= p[q.back()]) q.pop_back(); q.push(i); f[i] = p[q.front()]; &#125; long long ans = 0; for(int i = 1 ; i &lt;= n ; ++i) ans += 1ll * s[i] * f[i]; printf("%lld\n",ans);&#125; 今天好像就写了这一道题的程序，不过似乎思考了很多题目只不过今天时间太琐碎就没写。。以后再说说那些有趣的题目吧。 在surface book上搞定了blog，以后就可以用这个了！不过等我的笔记本来了恐怕还得重新配置我的新笔记本。]]></content>
      <tags>
        <tag>nothing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 38]]></title>
    <url>%2F2019%2F01%2F05%2F2019.1.5%2F</url>
    <content type="text"><![CDATA[好几天由于各种事情结果没写blog 把最近做的题写写题解 [NOI2015]程序自动分析题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入输出格式输入格式： 从文件prog.in中读入数据。 输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若�e=0，则该约束条件为xi≠xj； 输出格式： 输出到文件 prog.out 中。 输出文件包括t行。 输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。 输入输出样例输入样例#1： 复制 1234567221 2 11 2 021 2 12 1 1 输出样例#1： 复制 12NOYES 输入样例#2： 复制 12345678910231 2 12 3 13 1 141 2 12 3 13 4 11 4 0 输出样例#2： 复制 12YESNO 说明【样例解释1】 在第一个问题中，约束条件为：x1=x2,x1≠x2。这两个约束条件互相矛盾，因此不可被同时满足。 在第二个问题中，约束条件为：x1=x2,x1=x2。这两个约束条件是等价的，可以被同时满足。 【样例说明2】 在第一个问题中，约束条件有三个：x1=x2,x2=x3,x3=x1。只需赋值使得x1=x1=x1，即可同时满足所有的约束条件。 在第二个问题中，约束条件有四个：x1=x2,x2=x3,x3=x4,x4≠x1。由前三个约束条件可以推出x1=x2=x3=x4，然而最后一个约束条件却要求x1≠x4，因此不可被满足。 【数据范围] 【时限2s，内存512M】 题解一道十分sb的并查集，结果由于我坐着硬刚掉进思维陷阱结果这道多日来做的最简单的题我却看了题解。。 这道题一开始想用扩展域，后来想了一想发现不等关系没有传递性。 然后就魔改扩展域并查集不过还是失败了。 我当时为什么没想到既然这样不等关系就是相对独立的，因此没有必要管它呢？（其实确实需要一点灵感才能想到） 我们只需要把相等的合并了，然后看看不等的两个变量属不属于一个集合就行了。。 这道题就怕想不到不等关系 Code： 12 [1007]Scarlet的字符串不可能这么可爱题目描述Scarlet妄图构造字符集为kk，长度为LL的字符串，满足没有任何一个长度超过11的回文连续子串。 看起来这样的字符串太多了，Scarlet随手加了个限制：她指定了字符串的第ss位为ww。 这下Scarlet不会做了，请你来帮她计算究竟有多少满足条件的字符串。按照套路，你只要求出答案对pp取模后的结果。 输入输出格式输入格式： 第一行三个整数k,Lk,L和pp，分别表示构造的字符串的的字符集、长度和模数。 第二行两个整数s,ws,w，描述Scarlet给的限制。 注意：s=0s=0表示该数据点中Scarlet十分良心地没有添加限制 输出格式： 一行一个整数，表示答案对pp的取模后的结果。 输入输出样例输入样例#1： 123 3 2331 1 输出样例#1： 12 说明字符集：一个字符串中不同字符的数量。例如，字符集是3的话，你可以认为字符串仅由“A”、“B”、“C”三个字母组成。 样例解释：第一个字符固定A，那么符合要求的字符串是ABC,ACB。而AAB字符串包括AA这个回文子串，ACA本身就是回文串，一次类推。 对于$100\%$的数据$1\leq k,L\leq 10^{18},0\leq s\leq L,1\leq w\leq k,1\leq p\leq 10^9$ 题解这道题首先要想到位置不同方案数是相同的。 如果指定字符呢？其实也没有什么大不了的，在前面我们可以发现每一个字符会对后两位进行限制，那么这个指定的字符只是会对前后两位有限制。 通过计算会发现就是没有限制的情况 除$k$即可， 我记得当时比赛我并没有想出来这一点，思维能力=-INF 后面的就好推了。 我们发现递推的时候对于第$k$位（$k &gt;= 3$），只需要和前一位与前两位不同即可，因为我们每一位始终保证没有回文串，意味着和$k-3$位相同，$k-2$与$k-1$会阻隔他们形成回文串。 会这个简单的性质你就可以80分啦。 结合上面，我们就可以通过这道题。 Code： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define LL long long LL ans , mod , k , n;inline LL pow(LL n , LL k)&#123; LL ans = 1 , base = n % mod; for( ; k ; k &gt;&gt;= 1 , base = base * base % mod) if(k &amp; 1) ans = ans * base % mod; return ans;&#125;LL s;inline LL solve()&#123; k %= mod; if(s &gt; 0)&#123; if(n == 1) return 1; if(n == 2) return (k-1) % mod; return (k-1) % mod * pow(k-2,n-2) % mod; &#125; else &#123; if(n == 1) return k % mod; if(n == 2) return k % mod * (k-1) % mod; return k % mod * (k-1) % mod * pow(k-2,n-2) % mod; &#125;&#125;int main()&#123; LL t; scanf("%lld%lld%lld",&amp;k,&amp;n,&amp;mod); scanf("%lld%lld",&amp;s,&amp;t); printf("%lld\n",solve());&#125; 玉蟾宫题目背景有一天，小猫rainbow和freda来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。 题目描述这片土地被分成N*M个格子，每个格子里写着’R’或者’F’，R代表这块土地被赐予了rainbow，F代表这块土地被赐予了freda。 现在freda要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着’F’并且面积最大。 但是rainbow和freda的OI水平都弱爆了，找不出这块土地，而蓝兔也想看freda卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为S，它们每人给你S两银子。 输入输出格式输入格式： 第一行两个整数N,M，表示矩形土地有N行M列。 接下来N行，每行M个用空格隔开的字符’F’或’R’，描述了矩形土地。 输出格式： 输出一个整数，表示你能得到多少银子，即(3*最大’F’矩形土地面积)的值。 输入输出样例输入样例#1： 1234565 6 R F F F F F F F F F F F R R R F F F F F F F F F F F F F F F 输出样例#1： 145 说明$1&lt;=N,M&lt;=1000$ 题解终于认真学习了悬线法。。。（还有另一种求极大有效子矩形的算法） 这破玩意边界真多啊。。联赛不会考这么板子的题的，mhr如是毒奶道。 其实我们只是尽量有效的枚举极大子矩形就可以。 对于每个点，它向上最大没有障碍点的距离称为悬线，然后预处理出左右能使悬线有效的长度。 可以画图证明其正确性。 注意边界以及左右是两开的，所以左右多扩展一位表示直到左右边界都没有障碍。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 1005int h[maxn][maxn] , l[maxn][maxn] , r[maxn][maxn] , n , m;bool vld[maxn][maxn];char ch;int main()&#123;// freopen("data.in","r",stdin); scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) &#123; std::cin&gt;&gt;ch; if(ch == 'R') vld[i][j] = true; &#125; for(int i = 1 ; i &lt;= m ; ++i) l[0][i] = 0 , r[0][i] = m + 1; for(int i = 1 ; i &lt;= n ; ++i) &#123; for(int j = 1 ; j &lt;= m ; ++j) &#123; if(!vld[i][j]) h[i][j] = h[i-1][j] + 1; else h[i][j] = 0; &#125; for(int j = 1 , t = 0 ; j &lt;= m ; ++j) &#123; if(!vld[i][j]) l[i][j] = std::max(l[i-1][j] , t); else t = j ; &#125; for(int j = m , t = m + 1; j &gt;= 1 ; --j) &#123; if(!vld[i][j]) r[i][j] = std::min(r[i-1][j] , t); else t = j , r[i][j] = m + 1; &#125; &#125;// for(int i = 1 ; i &lt;= n ; ++i)// for(int j = 1 ; j &lt;= m ; ++j)// printf("%d %d %d %d %d\n",i,j,h[i][j],l[i][j],r[i][j]); int ans = 0; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) ans = std::max(ans , (r[i][j] - l[i][j] - 1) * h[i][j]); printf("%d",ans * 3);&#125; [USACO15JAN]电影移动Moovie Mooving题目描述Bessie is out at the movies. Being mischievous as always, she has decided to hide from Farmer John for L (1 &lt;= L &lt;= 100,000,000) minutes, during which time she wants to watch movies continuously. She has N (1 &lt;= N &lt;= 20) movies to choose from, each of which has a certain duration and a set of showtimes during the day. Bessie may enter and exit a movie at any time during one if its showtimes, but she does not want to ever visit the same movie twice, and she cannot switch to another showtime of the same movie that overlaps the current showtime. Help Bessie by determining if it is possible for her to achieve her goal of watching movies continuously from time 0 through time L. If it is, determine the minimum number of movies she needs to see to achieve this goal (Bessie gets confused with plot lines if she watches too many movies). 奶牛贝西想连续看L (1 &lt;= L &lt;= 100,000,000)分钟的电影，有 N (1 &lt;= N &lt;= 20)部电影可供选择，每部电影会在一天的不同时段放映。 贝西可以在一部电影播放过程中的任何时间进入或退出放映厅。但她不愿意重复看到一部电影，所以每部电影她最多看到一次。她也不能在看一部电影的过程中，换到另一个正在播放相同电影的放映厅。 请帮贝西计算她能够做到从0到L分钟连续不断地观看电影，如果能，请计算她最少看几部电影就行了。 输入输出格式输入格式： INPUT: (file movie.in) The first line of input contains N and L. The next N lines each describe a movie. They begin with its integer duration, D (1 &lt;= D &lt;= L) and the number of showtimes, C (1 &lt;= C &lt;= 1000). The remaining C integers on the same line are each in the range 0..L, and give the starting time of one of the showings of the movie. Showtimes are distinct, in the range 0..L, and given in increasing order. 输出格式： UTPUT: (file movie.out) A single integer indicating the minimum number of movies that Bessie needs to see to achieve her goal. If this is impossible output -1 instead. 输入输出样例输入样例#1： 123454 100 50 3 15 30 55 40 2 0 65 30 2 20 90 20 1 0 输出样例#1： 13 说明SOLUTION NOTES: Bessie should attend the first showing of the fourth movie from time 0 to time 20. Then she watches the first showing of the first movie from time 20 to time 65. Finally she watches the last showing of the second movie from time 65 to time 100. 题解一道还行的状态压缩dp 我一开始写了个爆搜得了个位数。。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define maxn 22std::vector&lt;int&gt; v[maxn];int n , c , l[maxn] , len , ans;bool vis[maxn];void dfs(int cur , int ct , int dep)&#123; if(dep &gt; (int)n*1.5) return; if(cur &gt;= len) &#123; ans = std::min(ans , ct); return ; &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(vis[i]) continue; if(v[i][0] &gt; cur) break; vis[i] = true; // choose it for(int j = 0 ; j &lt; (int)v[i].size() ; ++j) &#123; if(v[i][j] &gt; cur || v[i][j] + v[i].back() &lt; cur) continue; dfs(v[i][j] + v[i].back() , ct + 1 , dep + 1); &#125; vis[i] = false; // not choose or choose later dfs(cur , ct , dep + 1); &#125;&#125; bool operator &lt; (const std::vector&lt;int&gt;&amp; x , const std::vector&lt;int&gt;&amp; y)&#123; return x[0] &lt; y[0];&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;len); for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%d%d",&amp;l[i],&amp;c); int x; for(int j = 1 ; j &lt;= c ; ++j) scanf("%d",&amp;x) , v[i].push_back(x); &#125; for(int i = 1 ; i &lt;= n ; ++i) v[i].push_back(l[i]); std::sort(v+1,v+n+1); ans = 0x7ffffff; dfs(0,0,0); if(ans &gt; 20) ans = -1; printf("%d\n",ans);&#125; 然后想状态压缩dp做法，突然我眉头一皱，目光停在一句看上去很平常的话上：贝西可以在一部电影播放过程中的任何时间进入或退出放映厅 那不就是对于任意一个已经观看的电影状态，都是越大越好吗？？ 反正可以中途进入，那大了在进入和比较小进入最后的结束时间是一样的。 这个小贪心没什么问题。 她也不能在看一部电影的过程中，换到另一个正在播放相同电影的放映厅 直接算结束时间更新即可。 然后我们对于当前的状态和枚举的下一个准备看的电影，只需要在电影的开始时间里找当前状态值的前驱，然后算出看完的时间更新当前状态并上这个电影的状态就行。 然后注意判断-1. 然后就随便过了。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define maxn 22std::vector&lt;int&gt; v[maxn];int n , c , l[maxn] , len , ans , f[1&lt;&lt;maxn];bool vis[maxn];inline int bit(int x)&#123; int ans = 0; for( ; x ; x -= x &amp; -x) ++ans; return ans;&#125;inline int find(int k , int val)&#123; std::vector&lt;int&gt;&amp; now = v[k]; int cl = 0 , cr = now.size() - 1 , ans = -0x7ffffff; while(cl &lt;= cr) &#123; int mid = cl + cr &gt;&gt; 1; if(now[mid] &lt;= val) ans = now[mid] , cl = mid + 1; else cr = mid - 1; &#125; return ans + l[k];&#125;void write(int x)&#123; std::stack&lt;int&gt; k; for( ; x ; x &gt;&gt;= 1) k.push(x&amp;1); for( ; k.size() ; k.pop()) putchar(k.top()+48); putchar(32);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;len); for(int i = 1; i &lt;= n ; ++i) &#123; scanf("%d%d",&amp;l[i],&amp;c); for(int j = 1 , x; j &lt;= c ; ++j) scanf("%d",&amp;x) , v[i].push_back(x); &#125; std::memset(f,-0x7f,sizeof(f)); f[0] = 0; int S = 1 &lt;&lt; n; for(int i = 0 ; i &lt; S ; ++i) &#123; for(int j = 1 ; j &lt;= n ; ++j) &#123; if(i &amp; (1 &lt;&lt; j - 1)) continue; f[i | (1 &lt;&lt; j - 1)] = std::max(f[i | (1 &lt;&lt; j - 1)] , find(j , f[i])); &#125; &#125;// for(int i = 1 ; i &lt; S ; ++i)// write(i) , printf("%d\n",f[i]); int ans = 0x7fffff; for(int i = 1 ; i &lt; S ; ++i) if(f[i] &gt;= len) ans = std::min(ans , bit(i)); if(ans &gt; n) ans = -1; printf("%d",ans);&#125; [HAOI2007]理想的正方形题目描述有一个ab的整数组成的矩阵，现请你从中找出一个nn的正方形区域，使得该区域所有数中的最大值和最小值的差最小。 输入输出格式输入格式： 第一行为3个整数，分别表示a,b,n的值 第二行至第a+1行每行为b个非负整数，表示矩阵中相应位置上的数。每行相邻两数之间用一空格分隔。 输出格式： 仅一个整数，为ab矩阵中所有“nn正方形区域中的最大整数和最小整数的差值”的最小值。 输入输出样例输入样例#1： 1234565 4 21 2 5 60 17 16 016 17 2 12 10 2 11 2 2 2 输出样例#1： 11 说明$2&lt;=a,b&lt;=1000,n&lt;=a,n&lt;=b,n&lt;=100$ 题解定长区间+最大最小值的合并性质让我们可以用单调队列来处理这道题。 首先我们思考一下边长为$n$的正方形的最大值是什么（形而上）： 是$n$个上下连续的长度为$n$的小长方形的最大值的最大值。 那我们先用单调队列求出所有长度为$n$的小长方形的最大值，然后再单调队列竖着求所有$n$个连续小长方形构成的边长为$n$的正方形的最大值就可以了。 手写Deque优化常数。 时间复杂度$\Theta(ab)$ Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 1005int a , b , n , p[maxn][maxn] , f[maxn][maxn] , g[maxn][maxn] , xmx[maxn][maxn] , xmn[maxn][maxn];struct Deque&#123; int l , r , q[maxn]; Deque()&#123; l = 1 , r = 0; // std::memset(q,0,sizeof(q)); &#125; inline void clear()&#123; l = 1 , r = 0; // std::memset(q,0,sizeof(q)); &#125; inline void push(int x)&#123; q[++r] = x; &#125; inline int size()&#123; return r-l+1; &#125; inline int front()&#123; return q[l]; &#125; inline int back()&#123; return q[r]; &#125; inline void pop_back()&#123; q[r--] = 0; &#125; inline void pop_front()&#123; q[l++] = 0; &#125;&#125;q;inline void solve()&#123; for(int i = 1 ; i &lt;= a ; ++i) &#123; q.clear(); int* now = p[i]; for(int j = 1 ; j &lt;= b ; ++j) &#123; while(q.size() &amp;&amp; now[j] &gt; now[q.back()]) q.pop_back(); while(q.size() &amp;&amp; j - q.front() + 1 &gt; n) q.pop_front(); q.push(j); xmx[i][j] = now[q.front()]; &#125; q.clear(); for(int j = 1 ; j &lt;= b ; ++j) &#123; while(q.size() &amp;&amp; now[j] &lt; now[q.back()]) q.pop_back(); while(q.size() &amp;&amp; j - q.front() + 1 &gt; n) q.pop_front(); q.push(j); xmn[i][j] = now[q.front()]; &#125; &#125; for(int j = 1 ; j &lt;= b ; ++j) &#123; q.clear(); for(int i = 1 ; i &lt;= a ; ++i) &#123; while(q.size() &amp;&amp; xmx[i][j] &gt; xmx[q.back()][j]) q.pop_back(); while(q.size() &amp;&amp; i - q.front() + 1 &gt; n) q.pop_front(); q.push(i); f[i][j] = xmx[q.front()][j]; &#125; &#125; for(int j = 1 ; j &lt;= b ; ++j) &#123; q.clear(); for(int i = 1 ; i &lt;= a ; ++i) &#123; while(q.size() &amp;&amp; xmn[i][j] &lt; xmn[q.back()][j]) q.pop_back(); while(q.size() &amp;&amp; i - q.front() + 1 &gt; n) q.pop_front(); q.push(i); g[i][j] = xmn[q.front()][j]; &#125; &#125;// for(int i = n ; i &lt;= a ; ++i)// for(int j = n ; j &lt;= b ; ++j)// printf("%d %d %d %d\n",i,j,f[i][j],g[i][j]);&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;n); for(int i = 1 ; i &lt;= a ; ++i) for(int j = 1 ; j &lt;= b ; ++j) scanf("%d",&amp;p[i][j]); solve(); int ans = 0x7fffffff; for(int i = n ; i &lt;= a ; ++i) for(int j = n ; j &lt;= b ; ++j) ans = std::min(ans , f[i][j] - g[i][j]); printf("%d\n",ans);&#125; P2716 和谐的雪花题目背景没有背景 题目描述现在有nm个雪花，被放在了一个nm的矩阵当中。每个雪花都有一个优美值。一个正方形的和谐度被定义为在这个正方形中雪花的最大优美值和最小优美值的差，和谐度越大这个正方形就越和谐。现在给出这个矩阵和一个非负整数k，zzs和zzy希望你能告诉他，在所有和谐度不小于k的正方形中，边长最小的正方形的边长（即找到一个最小的边长a，使得存在一个边长为a的正方形它的和谐度不小于k）。如果没有解，输出-1。 输入输出格式输入格式： 第一行两个正整数和一个非负整数，n、m和k。 接下来n行，每行m个非负整数，表示题目中的矩阵。 输出格式： 如果有解，则输出一个正整数，表示答案。如果无解，则是-1。 输入输出样例输入样例#1： 12343 5 73 4 2 8 76 5 2 4 63 1 4 0 9 输出样例#1： 12 说明对于20%的数据，1&lt;=n,m&lt;=20； 对于100%的数据，1&lt;=n,m&lt;=500； 对于100%的数据，矩阵中所有数不超过100000。 题解上面那个套个二分即可解决。。 至于为什么答案单调？一个更大的正方形的极值之差必定比它包含的正方形要打，更容易满足条件，因此可以二分 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 1005int a , b , n , p[maxn][maxn] , f[maxn][maxn] , g[maxn][maxn] , xmx[maxn][maxn] , xmn[maxn][maxn];struct Deque &#123; int l , r , q[maxn]; Deque()&#123; l = 1 , r = 0; // std::memset(q,0,sizeof(q)); &#125; void clear()&#123; l = 1 , r = 0; // std::memset(q,0,sizeof(q)); &#125; void push(int x)&#123; q[++r] = x; &#125; int size()&#123; return r-l+1; &#125; int front()&#123; return q[l]; &#125; int back()&#123; return q[r]; &#125; void pop_back()&#123; q[r--] = 0; &#125; void pop_front()&#123; q[l++] = 0; &#125;&#125;q;inline void solve(int n)&#123; for(int i = 1 ; i &lt;= a ; ++i) &#123; q.clear(); int* now = p[i]; for(int j = 1 ; j &lt;= b ; ++j) &#123; while(q.size() &amp;&amp; now[j] &gt; now[q.back()]) q.pop_back(); while(q.size() &amp;&amp; j - q.front() + 1 &gt; n) q.pop_front(); q.push(j); xmx[i][j] = now[q.front()]; &#125; q.clear(); for(int j = 1 ; j &lt;= b ; ++j) &#123; while(q.size() &amp;&amp; now[j] &lt; now[q.back()]) q.pop_back(); while(q.size() &amp;&amp; j - q.front() + 1 &gt; n) q.pop_front(); q.push(j); xmn[i][j] = now[q.front()]; &#125; &#125; for(int j = 1 ; j &lt;= b ; ++j) &#123; q.clear(); for(int i = 1 ; i &lt;= a ; ++i) &#123; while(q.size() &amp;&amp; xmx[i][j] &gt; xmx[q.back()][j]) q.pop_back(); while(q.size() &amp;&amp; i - q.front() + 1 &gt; n) q.pop_front(); q.push(i); f[i][j] = xmx[q.front()][j]; &#125; &#125; for(int j = 1 ; j &lt;= b ; ++j) &#123; q.clear(); for(int i = 1 ; i &lt;= a ; ++i) &#123; while(q.size() &amp;&amp; xmn[i][j] &lt; xmn[q.back()][j]) q.pop_back(); while(q.size() &amp;&amp; i - q.front() + 1 &gt; n) q.pop_front(); q.push(i); g[i][j] = xmn[q.front()][j]; &#125; &#125;// for(int i = n ; i &lt;= a ; ++i)// for(int j = n ; j &lt;= b ; ++j)// printf("%d %d %d %d\n",i,j,f[i][j],g[i][j]);&#125;inline bool check(int k)&#123; std::memset(xmx,0,sizeof(xmx)); std::memset(xmn,0,sizeof(xmn)); std::memset(f,0,sizeof(f)); std::memset(g,0,sizeof(g)); solve(k); int ans = -0x7fffffff; for(int i = k ; i &lt;= a ; ++i) for(int j = k ; j &lt;= b ; ++j) ans = std::max(ans , f[i][j] - g[i][j]); if(ans &gt;= n) return true; else return false;&#125;int main()&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;n); for(int i = 1 ; i &lt;= a ; ++i) for(int j = 1 ; j &lt;= b ; ++j) scanf("%d",&amp;p[i][j]); int l = 1 , r = std::min(a,b) , ans = -1; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(check(mid)) ans = mid , r = mid - 1; else l = mid + 1; &#125; printf("%d\n",ans);&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two-week post 3]]></title>
    <url>%2F2018%2F12%2F31%2F2018.12.31WeekPost%2F</url>
    <content type="text"><![CDATA[This is a private post Incorrect Password! No content to display! U2FsdGVkX18+GSwsydRJ8/9It2zQJUFrl1UthkZzesFI0AfWTMalbGO4ZG8EPjG1CYoAxTgu5kztmTYQCM4P0WAXtF2uBvipe2DPnmpPm/fdHKY9oVkNxun3uM7oehoEOdwe08CHF0ng6nLQqnkgYYr9TJjnBctHs3lUdbCo1IIeIx4m0oYY1CeNsPl38q8HY2nQqWUwNOyIovpw2cGVE/1tRwPTeosk+ZZbzWwNbkd9IB3RuRCIPUfDttVuLFVN7CcFssWTKbt0fOQt/oNu1Sa3O8Def8mw5ZXshQTii2r89o0otjYt7h6TIPzqEF9wn+nHQJTrHvvRwHVMZWX+SCXgXNVizLuDfanpyhoc9JEmX3fwrxXKMcTLryKQJW4JjgDgsfosC4/uc2jKkfCjuMI3rIoxrObyIYsIfZzjzCJGs6Nsb33EwBiFhIYGgPYyt2twyVoZtp8gMLSGBIwozwHxiCLvlunyS5gjPgzUdBNI5v+lSRgLM0Wvpgj2MsKDFhxLWuigTg3CCKjrwkJ1giA7l747WMdFdwZf81GZwu9wSQVob1mRjdkbEz5JB2UksKW8mhGwjClBY8JKtL3RbcKTocfWByF95ojzy62slGgFh8b0uCF452Dyt/y/CbQLefnQP8fI0EuCOIApHRyogbIbWW0eeyCksmqId/6GLCyN8ocgV/it9/zFUmvsyxwLt6e0Zw+ohWMriG14zoj01Qds15K6BF48io4S7QHQ/4cggZtetOmfP8gehFuJTIcjwyjg746852VY4ZtpKvb/AXAn52Dh2tODZlojcnTe46AEWIUeX+Y5OmCYazMd06r9oM7xWC7NznFFJjdDLvNMxtNGqgua/bCym3bMttD0J+cNpsNpVHuZZNImpTYgqYgTnsJ7re0u0wIqa0m9XTl3MdvgTpkYtNMCIL0jyV63wcAkQNRofNMD9zRLQYIN4UwEPAbDF/ifzasYHCt8QF5QJqcBi7BgwIqgeLZJCuymi2TjEqPwHG6PS2QMu8P2Te+CbJ41wGURqZ748tpB7m4rDQAQpk45g7QuLI1zXYpcPAeV++MzsWiMUUjTg3SrcGaRjMqJszwPtsvBiLvmN3S02LXJgEyzXoPZcQMr69eNB8Fc8zADaJSHE0QBkPq7SQV1jSV1lUUtkpl45P/LbiLYv6zyGyg2ijF94grInB1Gr7cySJyG4vrjVSjZlvitwbwLnEKUEE74ey85BgP21bjtAhYI6ICIj8BeCrT2pLQZ3m+IeIZZCVt4Nuz1v5GTXdGeGY0f0vuDG5GtKjsw9Olu3v1R5wvjxyiM0Sr1M0+86oHlMwdbbx3rxyJ5Phy+2SJyv2/f6HE+T7p0WF2y3SG2csrJP212ZP7QRQ6c2qIm3DK13ysE7zsgGOojCgAAJVKYpfbCGDWVW/1Ky0euWWwPXDiJPY6iv+T1KdxONmV3Xsawdx+llVkWWRXsGgTCjqL04jXxO2ujqYt5LNK2LCczgVYIN6Fn/Y4GUlsnRBFXImkg0bvnCiu1NgYR5QDKVXaAP+7jVocolSqoL0s6hFLl5+UF7y06sa3Ur57f/EfUa6ynW6rFpmB42Em4KrwN3Bzn2nCqUnSEo+Xiuvkd+dE1OZ8YXDfWEdnuh9vb3KjuslndXW11ahZhIDGJiwoB9Hx4PCYXlC+A4RU2SdophT0LEAihehhaucVhdAGI8jtdWwgNs/oVWxhSGnOVVAUmYgKDGise1eLr+L6TgQ2dqIhprcOUN7lEQncfz20yIu249KBSDTlZjc2Lwsn7K7ISIXNhoTn/JnaU3ymp6itDkq2hOhC2eEBG88fUITP5DmiU+KQyu8eYCW8bUBwzRCdeZy5/t57ab31VZ9K+I6PPAuDOeRD7oql0DpFLTFsiAZSX2q1OgbPwhq2o2y54Vg09np/JQseMqtouzFaHl8ysNUkoNg+9TVx9u6uIInk9WLU+mSqR6dCIhbG3SmsNM8xXUjsytycaAi/M7vPQVDrOxx376ULd8SoPAxs97uq0JVg+rJXDeF7A4IKUPeP9Fr++ka1b+5p7pdwpsC+AGO29qzObPT3VEDSL3cP+66DsYLqsE44BJEQfGZ5hnS+GZHuXVfMvUWz5u+0pyaI5ThWCSt3mXXvUFHy52urXkzZixJVziqFqRoouwTxgT25qdAN9z3ERr7iG8Q6SZ6yPfz1WWpuMZgrtcXRy8OxCA7KLkk1oKiezdMxpzyu4GocTgoabOcTGaZYo906S7M7SMvfZza/AZDnzTslpURo2ou110jDO9ixqJmjWXoKD0/iG0OYIoxXAYvoP6C23WQZsFpZWvmTTGPRr4yYrZNoLKGu3Miaz6r/8XmyHdNVW4jvy5EDqXZyEzH0catsjEusg4wwQYnpn6khMiCVCKCj2O721MQS98USfgXGgQjo1/1K4/JVIcrW5Kf4GklscI5ivvGFQrGU920mhRxEBuBml7fF8U1SfUIqxFXB5earUlWIico+7gGiRvj15Nh4GDxYfRjNf+CI/BF+WReFbKLsUCvrKwh5hb7q7PMLI73G15um4hAfbPZf61wu0cQ2p6XAxoTZoDmRG+FvwFk1C24xlX8fdGUXWE6/kJuqqztBlc2wtTJ0o1ycF0KPuIqIORucnbzHFdMaRih/6xQefhKJKVBjA94YLJ07b7Zih+QfwJIozWrwIhwFfQfo8QeTgId/rx1SOBhFraMIZjFxRElop7GqERyYqwxZ1V/S+hzmcAYzKtcpNE7zmQSVXJtHcXNQ9LDSDukC6zIiWsRpOj5TQSR7V/4tX/owBvTUy9PQpGZ0ERaLKcoWgVWQdqAxti5thtKoXKIcZ9xsb1ZduJX7BMODb/5RIBRGi3IMV8PEVCE7h85ljorJJJeTmoQu+9Vou5m1xK5TQwdN/OOfGIUJRDTRqWiVjsXdUy2ytmUsO1G5dJbWcjzJ4ERn+Jad3Qa7A36WCMCeAyNSrcp3QeAYEooD0QgqiGZb34YgSdEznictSddYeDaBcPP32a7Vyo677i5ZwZO4WXfnlrzs/23udbEndjGPaYHAJ0/FmEeODhLPFB5RC/z5r9v+AnObtVyXS36A7etCpuma6S+0HTzF8JaJ2RTYd/R8w5jfktXEv1KqfauhSLdycXxD4fayvt5oaIhlUbtOSDuY8u2F7c9nZ7aDwl/Um1UNVzFnQ8MM6EFjatboYMoYn7XF1+ZiE8GszTDz7hyvGlv5DlkDR8BRVVl7MVcSV+S5MQCnsmRx6PwbfWoB8rtR2MpusKOrpaegbEZJVB4dlJbjHu9gnpY4H/Bq19mnBIFajXI+Wb61F7UMX+zdFv6qOSeX+AVUiXk1PlVAcnM6A7x9KwI77uo8AFQvLHEnXU77cE2PQegVQwuROf8dX3z1gGYLRfUjoub44AFaHRw4LZG6+kekBi8RvRAHb7WK1t/IyRfj3TzC8kxvSWKzbvQRVe7gWK79uzca8mTtP4iyXt8OGeWuw3FkwzOO78tScIrl1rrRrJOeoVwggHQaiY4WK6DFpMXv2+sA1ItleakqhD5YBiorJTfr67Z6AgxePpThZVjKP0INjPQyfp/TYe/6W9dNciSRDiFWJX6SkWQ4aVt+u8nnMTsf+zgOmwnYwlAquKVZAKNBn6He2a0orO5SbxR0z5+ReSL5rXze1npESm54cpBOIoKzlpHj/FaTLALUJ4Uce4GHR3kXeCrNsCK/B4JgGoPm0yEOqR1DEALlwjpDm7jBfwFzmNLj7gGIweajTaAkCdZjPo6VA2/nf/jl+TvgOyr2tyKuXmCEXGf2qJCcim4/uGt7wUVWPF2mDLBq+jIXaxtLYQW24Zfg2TYM4+nB6vBJU0dUEjjSRBSBQ52LgGADnO5edPxlU8GhwKcp/A7yVigt5A13lbWHuTomeiEYgDz4hTM59lBWyh8P8MYLVVrpW884pcgjQyhM8XKfCApZNfk1A/C/StCMofvDagWHA2sZiZpFl8EWymqMzLsZ2QS7uMiczXJd4vEKa+RFXwouVDaGfrm7e6hQjkuU6VzfCa0z5AGKyNaxI71QwDK8L9WMqo7+N2WmwxXqqBrOEb+73lSMOhsHTQGowoZYpmok7TVXcro5RT1Q+g5nJ8K/V2Y+1LXgx5M9leg+cz4qMLXgZCsDloV31gLQq3L4ZWEzMSyqGHL4zRwBSdS1yTbkXtTIb+FdKIRIFAQL8U91Yzqj/PqyDvklvpEjnXjX2C2nBPJVHienrnW9KLHDaiBCPse04lGxSCl5RVSN+Z3+I7Nd37PpaNKI05/Z3xpWp43201evLBP8WHT+4OOCtAXmg2vXQNdlu7BHSV9RL5a3ml3p+WgwN1zhETK8egih2G6dNM4BnkBXRiPDLM3m/dHa9IlKlM8HcvUF95dfu7SN0v0+LNOXD5ft2WQvtVWI3f2mP6xsn85MN3fHdAwDJKB1053k+s2z7U/m9Yc9cCX/EF4kxIDp5pstCJzdO9SeV4jDwHnOLTBIOceofkdxiZLdSS/HBBFSZww3IP8VJwQrKH6xXdc2JEOjWSGLdyMXsmS1zhP5C1uJ8Zds57nRcRwBA2xhXR3RWpa7/4ELFh25Reqrlhn0W8EhL8Wxz7UFJX8OIwU/4PdIItXqiE6E1QTLJY23bdYoZaOIOe+plndWB4IhKljJcvh9wk1VKvSTr6pviI9hv5diozWK3SALt9Zw+pZ1QOnnDrB+omNUYafMaWlrXQ6xMJHA7Db6Y1WAPAbqPrYTyX0mQo60fSjd6BBjlGJLFedyxmgM9bBMhXDa3L7rlsoKeaJFl2EzGzd9N0I+v7ltjwdP1eDOSVIIeXvBdx16B49X17f2YVWDclvzC43wHPH3HkKa+8Lz1t32OLzuSAMFAx3fKhURof7LttmJvAVnKS77jbo56v2+73oMJo6VoEtOuYXQrAz7p1wBoHy0fKrf4enJllD9t6Uyy6InlT0mpNDxIWkuGRdJu+q8mrQ1GaVwnIahMfF+a9/DELnKofdhgU7it0IyoJc5+xn56vQ0UqJLlsJCKu6ZRqu113i8xLViilw8l+PNISQo6jaFG274Jn4HuYNHE801kHJd+Yh89C/Ryyk0xxj7OyRP0/fM3cubFRvZJPRDyZt5I6xElN7OJCK+xUhz3JRankq2ryuo5OCv655WcBTXplWO2TVA/V2rXYnMHAJZNtexaHAayXc1a5SzSqzbuIwvFuv0SwuK6Y+EV67iVRYpm6awpbCFC3I8OYW+jsS6XbCB714nTuTc5A624sfhvC7yAIxcf0sOT3rC8peGMZ3ZUvXGLl84a11swjeSUEXky4VYSt9t9RJ6LEREcJAe+IgThIRin28g9XTepaD4ZuP2a7WWZ5KNr1PdnS9CCrL0JSLSq16ftD/LFrcrzrwougBo+l505sbkV66FbKWBJNi5dbO9gvARJ2tdA2OiopRt6GrAC+aUb81BUd9eyxSOs3FICfqf0TFqyz9Jp9MNG6F0vaWloX7DUfyDHwLHHVu/MSvuuKYdG/U6Rn/dJDUYYDbEfDMP9Rgvy+DHYKyi6v2ivgXvxpWCuWs9veI7KGjRcYzKtWm1Ks4xXCTEveI/M3gtbstrerK3fSLnmIzTru4sG/J40bQanj5f5+3GMTq6fYrFYqd8VFlXzlZK9RiKXjV5Hy+mfcQ985NtVrygTKWm+8A6rr+Fom71hhEAkQmuNYgMBYHTvaMibI/D2fn6t1uLy40qQKzM+38SsI4NMGzRHjCX6tXAxTBZDX2RdlD02n+r4pL3lks3swD6zPTOCUK/wFhTpa+6lD0im/tG7KDOJa4JR/HW7VoSDm3wg1G1rkfK2/XkSY3LF9cS3LdtZDnTqSXGwZWEsFhACZor8vW9DRCEH8Pst0v1j0VoWlSQ33cz+E450lNXPttkqStUHXaBc38CwoRbgcCxInCMo8UNdABQvelg3GV7pT7fKje6uM4udyhTmoptUnUofKvTTMwZ47YvV+fnEQzvWkokQvXe9HLgLiSRMrAELSRH/0fl1lkYolwzfRlI8jMfSxTqBGs5VF/F5nBsy97HZkLkw6YXK8qZBvYeEstnRn2MSBR2HIQwtEbHNOokdd5AAc+XaWOiZ2hLAw98jKLHkBhLExzgvsVJmszL69tR3exP8hlIhb1cG+ojwKGkh5Xd/v697sWUFkJ29xuGXdRFGylhDnkgK1ONxka0Y96pP3RiZO/oySJi+BFHjCFJqcSwPV+MoQsqFFFErt9Z9T2klDzfJOoSCQ2NetkpgYysIAMkc+hnicyneSqLqhOJ5xVCS6r3OmsE/+BVOYypFDWvhA0Mct8Za2oQJlb5dRmqfLp4FJ3vq1HEwKOiXSbo5mExUIpcn+b8TfLoyokvFYBuFKq57NEDe2c0nTKsSjEKn3xR472uJtWy7GkCKkzadJ/mvE2jryhBac47GGzf45GY6We7tF3tv38rn4achl1t4WeATYWFeS8QuC6WInJWFaMBhJC9w4wVQ1JgB4kh+KPd0sJk6xp8xcJ+ofuihp0DsZEGOKrd9KIt+P4fhI5DRDTjqIBg+sdV6++I5Yt84fQCGTfemSon6h6JlPvzXcCoPCMg5r3Ga5WTM6DkQbWUUSqNc5ywQekBwYwk2SFAw8E6Uve9vAPmPY+hTKdIFRabhqQkRIr54+JSNWocUJtCp/P+Y1UKSL1mMBwKhIT1WoTBOP6+3cOuwy0jYJCmYl3uNq44JGwRSUzenuV9VYR1gmUS2f7yNnQxw9V29K0I4XNWJSBi3JY96hlj5dL0HAJR8e2tYhu5WnljWN0bSVANaliTFgbrEZD0fR0QillY+66j6uXmtDXzrkyd/A/uAsJwv5c0qQG1g9bf4XV285g0EIHv4QiYeJ5DSZdOfmAC96myX50+co10ynXtv4J6VdLgD1LFgXOh6AJ6f2UwqX1XtvOwRjvR+O16YwFGnkCALVK+sdY+c6SmeY0W2hLX8SVDlYUcQxWNCrwaLo/zDWXq5vLq9wX74Ow1ZM8pf+3Wm08FjsjAcc4vy27RzaBi+N6n8S3rCcGNkpB2nRZQITWh4M4+w1H2Cve28h5NFstWb+7K6GBs5wYkpDy0cuuCXfAMaVuEDJa8lib9ffIop88/Z/KvvwROEczMJe+DcZGigJvQB/5b0jEG2ZDycTs9cXAe3GBb8uA0o5YDXW9PsDiY4M8Tg1FrS83Am84Wp7E1WyXfQPh8u3bKJ54EtWXE1o1mPiL6sQK35BJDKBNOmnhgNafro5vehJIUIiO5Got6WMsEV4wYguPu/TiJzssMw+9k09pu8aFIZkAtBuB4bM0OwsmbJtC3hkA2i3dfCKsjW3NNsCdOjgCKDC8pmwJx4tYDzp2/cUEFNby8NlnuYRRX8Yh9SJPBbMdUOlxSjY8lCl4WXFhiGnfvpDkRg5/mBP2Y9VBLF8q0T0jVqQfXaHAASD13Ai5mQ9QddiVE/LL1/oV1shMit/9Oxqjw2rOh2nSu6UNV96rV53rBNWnIP0eO+lRNDFcRrIesEM0q4hLqmmIEG22HLFsBAGP2xygXet/UAvkqs0Of+GcTETVZBjMNexyK0oBNN7Ddl+c4nCGnAg+zKNyedgSMxUi57DY5948f6r7OZ6NdS/4Ipr8v5T1A0bN7EeYNfTogBAlQU6PLiFJKte6Efi0x8rGrRYwPFwT3NfNv0xFUHsN3WoT1YbL4WvYiLo09eoPWz5OqhOsnL15iyumuzQ1WRVDVm1VBGKjf7bI+upIt3C0LTRsEITi/GMcHN8n3UnPf/GsrgFlRslvEwbMSeVGOn0k8wLIV505O9T/po9/ObenY4xHuOVcuWA+0RlfSVlVo36YC5DZ0uH/y4XrnyfVjo8L05aqVyw1o4SCpk5IVZpB2K9ucfJHslf+7SbT/P8rAaBcxDegUp4w3t3mSqM5l/bwidJZfV7hAw9HcQt5wDxKiSXbxa3NOipHNrTBO8ZmT7/R5OHv4sESXeYorp4G1ClJzA5usLyVzFJOEm1Io7Wscus6jWHSbPp2H+8sOL8K9Mfr1szn/awROifYRMdPCK+C6gNwm8x6JH0Dki7o0vbnSYewOPVMsTuRFcvOo8jiyiAtVHbAiA7ACZUcJJs9c48S0x+w+9cS4KX9A6jT5I2+0kzXHHtpMY1pUYiOISIn0Rg+VBcAHVVVXO7yI+ICA/zZyx06VRdOb93GL1RpVl7pTQM62FuQruccm80mtMsUULXv4hJz5R9WNlPxG16hIyqFiOcNhu4bmFZk2hxRmuvKDjdzpff3vQOEgwowiEvlhLJzo8y/63vpXOJCkdpMMf+raJFLAraZvTCXpgxN9FAD87040EK1MOkPUKT+E7ZkadWk72cJjdX+3vkcMxFXqw7iJhRgZ6yZHdvNcCVKU1RrHuCR0mm5pQRGav1xB0/XwRwvbxGQLmIjDf0NOAztHMHZQ2/JZKU5D/XNaVKnFOiq4alkChMqs5++pqreZhR9KSUcM5CghPVKWFvIJd1DJ1ZrpNHLfUL7nDmTizTOrGvW4Wo5vmnAXklQqwFhrILygGZFUW+6J4EAztk9Lev6xwEXjGdjqHbirmvipEFVSS5t8pyNpId3c7xeKfhAETKVyNnGF9R7qgJTNTvGa5zi2j94PQ+PCAQ4d0EZYfVwXVSk7J0uc/zXHZPEfh/lYLPH4JaycCjDKwvZoHhyr+UN5FpYcEoMhYqCwdl7+fgJzWUhGmFFB7QJ0K9koZJ+LABifQHZbvYoRvqKpPnHYIegrgQYaUG4eXn4RXFpVMImbGAqfIAmmeknFkwmwkA3bnxYYfjx84v/FutkoIceNocPjyXF+Kvml2ZJ8hwdOzr4X1rV/lHXrDmZk1NE3IA9yfrAaF+4HUBrVf9+XEvjoAp3OIV1Mt5CvdWOpScgS04h1fPasI6ZslFK/TBvwUyQyD0J8aV4qnUTc/E0k6WtU1pxlPPalAtawCQHkbrMcjF0OYvbxVmQw87cRp+C2/pf2zJTJIk9RUNBkcDASL1E39lLyTg6Y6z/d/QiCKwioVAABNMvkpS9nMBB0iwcsjpWW2sKKOEATJxKvy3nVPJvFL2aEyv9H2hyAK2SDd7E21IC6H6UM4YiPvvgi7CdJwUAzeI0JNpfk7gYLXGOW41FreJ4GbZtBbiAiEPa5GcRJdMDb6hAmBk99hL5tgEgZPcmkl04CFbiBkTM6uI0A1fvlUvW7rs3WSl6IpOx/I/ZdI7ZFlGVdM2YHE3XC0lABcuZzxxYeOr2M9DGErtwyYA60yCRSRXDg1gXJ12vXpMwhTmp7L2CkDF/JP1ztOuInStGwz2R8hRTx0R3Lm75Sz1Jqt9pjqKdaKpRqFQz68NbiPdFK/ab6bml8jO3fNQulJcjOOFpUq7mirZS4O1ogr1q0qtwB5koJ+RwaugDCO5sCUBNtS1tHnAl/q0ZSNYNYqZIAscwVs1siFj/bIQYgT5Zk5TwnqZsfaGqb9gQmPOLl2ft00jx0v7I7Vqr7/SAEyTmtZrWAlP+HtEu98VdIIurvY9qq7Q6wPkm9HCbL/Grfj8PZzZrrhx+oo2chNWbXtm/HqXVozcaxLHEj58XNamQDgIQgUJV58F5fzvyZ7Xl0Cp0UcprElTzrkDpSBD/8N3+8Dz+gq55XXVI6HQsbS0NMifFIPovZ8B6p9mmfgjrLihal+yON+qRewQRE9SEOPYPhkaKUGDwNg64m2OHopnWx2nTAlV04q3NOKkC31QZUEejdBecUHlFBtLwS7LTfN38Z14nCj0z2hKnkFOUz09fP+rO0N6DN4sCslxiJNX+/1/xDILiD4nQRfAxT9fUkih4nlIu2YfsU9f31D275md7m/1Aj6NdnUvVwnQE7JlR8SqgwOw9gJHy2Z0n7dSGyIFlIsL6zajp2cQ8KZpSpDLW/8iN5mf+oJjTgxfsPC5w2mkM/Mx0L+IYe4pvrmTeJ6nXobeQxwxhET+Pe/rTV1q+GvU4oK3DUJQJ5QPtGaG1Y3a7B2J+HGUDaRmW/qTNVS3X2ZexCahDw70/rNMtm+i2YyzY7pJgTU+IWJC8Tgtj8p6pcxII2dB95I0Mw39q+nZjHxYkymSGaLaH0LSReNwHKrfzZEGegdApoY0Oku7Lxv69KC17IpBpWUc4cR4grsxEjCIXuk0nKgxE2GQsFHSI6Y5wJdLHBhR+rmrJE08DkQQsL6PhwKRGNuCp5fkMi53Ts/vO0VbmwEDZIbl8768gfX1qUeKTrx2f8AMHwp4cDzaBJNfF4tQ5j0wtlmqox1mhPINPxXODX7dkLUnJvYquVIPB1RMlFQUasJT0SZVoXBKk8MWrbr3Lm6YTRfRfHPT6RTtU2OB1kCCXzF/3dGZmRbkChpxDtFY0fsUrpCBF+EJwSggJvRY5pq1GVArOVxte163wRgjKV9Jk4m2dyr2peFHKLgo/geuNR1+g6NjsYqzwWfFMyE3jmVh/XbtR2SWO/vAqgtY/zGlTHNmXHjpOTX1e7vRqGNVDrUJE+0Xv+nEDB9Gk+frlwJ3nf/DNTgryCppdFMAKJFi9T3fDX5xzMgoLmEXQFjVAHpiFu4YNtrQX4qy9JOK1gdU/U/4kan2wwEOHA9GEClN2UW7eEpgmS7GwUQuRI5xwKNHxz4DzdZbPd3xpDODJFEFXK9Tojl9VCCEIW3XJj9kHeTe8Rp6I9Ky0V+lz6e229mV09Xg0NenRQ6wCYbh4EF3JPrIa/KuzXNLP5+EV+NdYuX664SL59X6Lg8yV/07JepvoU3xiDIMIfRy5/lgquzEi5S/kKZRR4MEmpW9R9wmgpRk5qnWKh71NgCmmYMHH6bIsZH0RZwDHQ/5LV2pMT3HZ+CPsvDM0joR+IaDEHpDEJ1oPtZgCACFQxVduf7QQd2poVTCl+CvshPo6utSPMMMfgdMlHq4Gi2eRIF/rp+EkVW3s5s+LRlayzdgwm8JJ0CyVzLtVGQSZYN4Tn0OAb8TKy4QaDos58og66BJDfRLCM2zxjQ0/+05ytoX7u3OFJ/AmiM2aZWcwAJkav7d2qfKmMXlGk1vk52ik4KP6gtMUnTUMsDDRriHyJi0MLFvdCvz6j0KmO3SWeS+OZvOUQZj13Ukkoc6YnLpkSR/CouKnX5+k4V6OKCPPw5vB86FpTnCmbnDjr64u+q2z6pFmgWnurQe79lfbb2B/7PHJD5QeYAvR5iNyzPah3z0QsGz7e0xwRrj4eNEljCxWe1ZEjoCYCNslSgHN6Hp24BXrHDIvoBqeThjMlR5xgbo1JgX7G+W3AnxVovfEi46fAZw56oITr7dFea+ZuZdpaxthVTT3nhOZr4iTgsfUHY9eYTjBgVPLzeWcdHrfjyfkgfJdBiZSq5zSjbLc1Sic4z8CjzNPe6WCKBOv6aq5wLn80zqZz6IUEDQaZ96qkDjtmhMQkxpIG1ex0ajkO82ulXDlhNyXBxz5Y8rjqsp7YGaeArVMGJKuiMSCo6hSAKzJSi5QyENogn9UBwuDCXcdXfYjazX/hBjoftgICoQ4DOtMFH2+yUeX10F1zmfZyyzMq6Loj9ieIbXUfZb1x24Ey8m6/MhvDmGTV7XbfRhl7WDThLDhSiN9HHXEVbwuJ6yljxGa8J5UhdJKj0vKRJ7N8ny7EQ7JVDxajHfE/qqtc+6zbpWYSZtAj0+Asi3QQR679VbgmKBi5DCMmnx0olcpyBGdMxM24zZVwxhrpypl9LHDy156K+zmjG5vAVlz3oLH8fvE1uF8IcsehWHwigPO61cNfrbpnmcQBTJS+m3Mz0xQR/9ZOmYDxQMfOu1ry6uR5hqTLIVZMkokWt6sAYmcZ+xKrgSEfr54eWDY1kQX1IPdnAUhhhsKidLkoaXPQR6H2HCfCXSxXz5lbTx0GrsnnfU0ZAb6XRCH9fFxFG29usy7z2aqD7qZdJgMo16gMB/MVLkbDyZCKMt48wK/hjL2ImG1Dho1uaCQB95yxBKMiRVGo3Ps3S4n71N532ohsj83PoAi2XJBei0Q+eZsynvhhGj+Dh037NQrZSWoG1dmgtVnRwm3dl9u4/yaZ2cc5yJypbwscv9dcAZLuS0k2vi7I0TNtLoZa7hvwHCnsGyXvC/WHIL+OO8wMfN6MVMUoG7JTD389tcguvLgLmdaODUUL0YQHwFNggHNMBQwh++sCb8v1q7Cxma0Bnav6dncY0CBO2qQowEnrcD5aVBQtjkCB3I3jluIMG9AkGxQdUxAJlQuKWvP+WkP1VVebO3yX0FnXDTYJg/3sVmXSfG/+u7RrHqfLS1tdcAo47iUtD1gl9qKMUdeiJGFe+TQ/AGOvP7VdmumzGGxKXRIJllu/XPe+Uxqw+BkSlrTkeS0FJuT0BntN5X0erEaEpT6gJm0Oaf2PS/Ny4PwHE8TnDu/UBoRWwb8ugJNoZ466/bqtlIe1f9qQiqa8fsBilRkn/Klemee/01rIV4civeeALsBLrCSu2VEHJQKJangqW2V0Mj9sxYjayy57OfEb/bCXbKznnG3EUrKyMQFRYnsxZ/rN8rYFFvubP3L9Ndj/gYKJaySTVL5Tg3YtZ0Zu3w7XTlBj935sWaoIhhmjDAvt1StCQ/5RRBCD5BMS+xCc/bLOl0VHaFvQWQ7OV84ocMchX2Sibp6XJdmcOaXhbH3CJzGE9zBo5ucTWHppHeWX7hFbqcKkDyXF4jWliL20F6FwUGXnEiSIKyxi7604bXYfCm4e5EcK6VJHD0gk0tHxLaTY3wCvqgoS1Hu/0AEgxaBP1wKIGZxU4t94eX33RO6yHPeABCOPGTdYlBL32cToh43ubnRZrZbChhgoIIJKnsmXoZ5kG59Uet9cFlC9fb3xKNiNlVJ9+9ot1q5kgze6Ppd14o1N7C03p6QN8J9Y3BNODpeS20YbrLC2ju99lrV3JfXeoHSsCu1KgElFB1CmeLK/y3+99DrGjd+Nw28UZ/COB/Rj0TVpOrkmrEEhtQ/AX1yfLtq/NSYWUyROBRGdI+xxKR4u7JU069W0WJIE7ezhKrj6/19H+y5Vlqpcrm4g9wy2/Bk4nnnrmyGDq6cEt+iDrvR+7Nty8+GfwqQXzX9/LvwG0LFWdABp9n6JPbYw8THpcrXxNMEf6zSZgJb0dLanUeffLKmWi0VV3FRj5sIG7EfOJbFkg1JDPmewPZ9UMSAYYaxdE8vHuqE+jyI6L9f+v25HHnS1F5k7FXaGbgPsfX4pqM21tUkOe6y1/fHQAJi+RLD/fveKY/1boWgH5cgl3brQJ2a2APJvVdd00qLLSDOtVdDY1J271fgmwLIbO9fNA0L3vXUIfOnB90biarVo2n7apVcw+rDK0afJgVT1bptqDCkLeKJp3gbjHrQLIcziFdblN9xkecLem1TmvCxhF75wZfY2F9PjzbPQNkKiYSYsqoAk3Sxi9qqtDRjRE4/ML+al0kzX0y3xFEXDmgyznEpLJh1ZiswmfR0+QjA6pi28PiTFc]]></content>
      <tags>
        <tag>可持久化 随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 37]]></title>
    <url>%2F2018%2F12%2F31%2F2018.12.31%2F</url>
    <content type="text"><![CDATA[终于调出了树链第k大。。。 Count on a tree题目描述给定一棵N个节点的树，每个点有一个权值，对于M个询问(u,v,k)，你需要回答u xor lastans和v这两个节点间第K小的点权。其中lastans是上一个询问的答案，初始为0，即第一个询问的u是明文。 输入输出格式输入格式： 第一行两个整数N,M。 第二行有N个整数，其中第i个整数表示点i的权值。 后面N-1行每行两个整数(x,y)，表示点x到点y有一条边。 最后M行每行两个整数(u,v,k)，表示一组询问。 输出格式： M行，表示每个询问的答案。 输入输出样例输入样例#1： 12345678910111213148 5105 2 9 3 8 5 7 71 21 31 43 53 63 74 82 5 10 5 210 5 311 5 4110 8 2 输出样例#1： 123452891057 题解这题思路学过可持久化不难想，只不过我写出了好几个sb的错误 一开始在学校写，我建可持久化线段树居然是枚举每个点插入。。。。可以想到这是多么的荒谬，因为枚举到的点的父亲必须在它之前插入才能维护到跟的前缀权值线段树啊。。这还是我今天又看才突然反应过来的。。 其次一个更sb的错误是我居然在查询中把$tot \leq k$当成是进左子树的条件。。。 这种把左右写反的错误已经不是一次两次了，根源是写的太快不过脑子。 一定要避免这种情况，否则调试代价不小（主要是这次调试也挺失败，输出关键信息锁定错误的能力还需要提高）。 现在来说说思路。 主要思路是利用可持久化权值线段树维护树上前缀路径在每个值域的个数，然后利用个数的可减性快速计算出当前值域下链上的个数，假如小于等于$k$就继续递归左子树查找，假如大于$k$就在右子树查找$k-cur$大的值。 主要利用了值域二分和差分统计的思想，不是很难想， 其实也不难写，结果还是挂了好几次。。 话说我也不知道为什么win10下Vim的tab缩进在Vim下显示的好好的，一复制出来就没了。。凑合着看吧。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define maxn 200005std::vector&lt;int&gt; g[maxn];int n , rev[maxn] , lsa , range , m , tot , val[maxn] , sgt[maxn&lt;&lt;5] , lc[maxn&lt;&lt;5] , rc[maxn&lt;&lt;5] , sz[maxn] , hs[maxn] , f[maxn] , top[maxn] , dep[maxn] , rt[maxn];struct Node&#123; int v , id; bool operator&lt;(const Node&amp; p)const&#123; return v &lt; p.v; &#125;&#125;p[maxn];void dfs1(int x , int fx)&#123; sz[x] = 1; dep[x] = dep[fx] + 1; f[x] = fx; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i]; if(v == fx) continue; dfs1(v , x) , sz[x] += sz[v]; if(sz[hs[x]] &lt; sz[v]) hs[x] = v; &#125;&#125;void dfs2(int x , int tp)&#123; top[x] = tp; if(!hs[x]) return ; dfs2(hs[x] , tp); for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i]; if(v == hs[x] || v == f[x]) continue; dfs2(v , v); &#125;&#125;inline int LCA(int x , int y)&#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); x = f[top[x]]; &#125; if(dep[x] &gt; dep[y]) std::swap(x,y); return x;&#125;inline void pushup(int x)&#123; sgt[x] = sgt[lc[x]] + sgt[rc[x]];&#125;inline void cpy(int x , int y)&#123; lc[x] = lc[y]; rc[x] = rc[y]; sgt[x] = sgt[y];&#125;void build(int&amp; p , int l, int r)&#123; p = ++tot; if(l == r) return; int mid = l + r &gt;&gt; 1; build(lc[p] , l , mid); build(rc[p] , mid + 1, r);&#125;void insert(int&amp; p , int fp , int l , int r , int v)&#123; p = ++tot; cpy(p,fp); if(l == r)&#123; sgt[p] ++ ; return ; &#125; int mid = l + r &gt;&gt; 1; if(v &lt;= mid) insert(lc[p] , lc[fp] , l , mid , v); else insert(rc[p] , rc[fp] , mid + 1 ,r , v); pushup(p);&#125;void buildSgt(int x , int fx)&#123; insert(rt[x] , rt[fx] , 1 , range , val[x]); for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i]; if(v == fx) continue; buildSgt(v , x); &#125;&#125;int query(int x , int y , int lca, int flca , int l , int r , int k)&#123; if(l == r) return l; int tot = sgt[lc[x]] + sgt[lc[y]] - sgt[lc[lca]] - sgt[lc[flca]] , mid = l + r &gt;&gt; 1;// printf("QUERY INFO LINK INFO : %d %d %d %d\n",sgt[x],sgt[y],sgt[lca],sgt[flca]); if(k &lt;= tot) return query(lc[x] , lc[y] , lc[lca] , lc[flca] , l, mid , k); else return query(rc[x] , rc[y] , rc[lca] , rc[flca] , mid + 1 , r , k-tot);&#125;void print(int p , int l , int r)&#123; if(l == r)&#123;// printf("LEAF VAL : %d number:%d\n",l,sgt[p]); return; &#125; int mid = l + r &gt;&gt; 1;// printf("THE NUMBER OF %d to %d:%d\n",l,r,sgt[p]); print(lc[p],l,mid); print(rc[p],mid+1,r);&#125;inline void pre()&#123; for(int i = 1 ; i &lt;= n ; ++i) p[i].v = val[i] , p[i].id = i; std::sort(p+1,p+n+1); for(int i = 1 ; i &lt;= n ; ++i) &#123; if(p[i].v != p[i-1].v) ++range; rev[range] = p[i].v; val[p[i].id] = range; &#125; dfs1(1,0); dfs2(1,0); build(rt[0],1,range); buildSgt(1,0);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;val[i]); for(int i = 1 ; i &lt;= n - 1; ++i) &#123; int x , y; scanf("%d%d",&amp;x,&amp;y); g[x].push_back(y); g[y].push_back(x); &#125; pre(); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y, k , lca; scanf("%d%d%d",&amp;x,&amp;y,&amp;k);// x ^= lsa; lca = LCA(x,y); printf("%d\n",lsa = rev[query(rt[x],rt[y],rt[lca],rt[f[lca]],1,range,k)]); &#125;&#125;]]></content>
      <tags>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 36]]></title>
    <url>%2F2018%2F12%2F30%2F2018.12.30%2F</url>
    <content type="text"><![CDATA[BZOJ#1901 Dynamic RankingsDescription给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1 ],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改 变后的a继续回答上面的问题。 Input第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。 分别表示序列的长度和指令的个数。 第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。 接下来的m行描述每条指令 每行的格式是下面两种格式中的一种。 Q i j k 或者 C i t Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1） 表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。 C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t m,n≤10000 Output 对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。 Sample Input5 3 3 2 1 4 7 Q 1 4 3 C 2 6 Q 2 5 3 Sample Output3 6 题解昨天本来很垃圾，也就秒想出待修改整体二分怎么搞还算好点。 昨天已经写好题解了，不过在这里再说下理解。 整体二分就是把操作序列分治成和值域相关的子问题，不管是修改还是查询。 一个有趣的细节： 这两个都是正确的。 原因是整体二分由于右边的永远不会影响左边的，所以覆盖掉左边的位置并不会错。 确实挺好写，1A Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int n , ans[maxn] , bit[maxn] , m , val[maxn];const int RANGE = (int)1e9;struct Node&#123; int tp , l , r , v , id;&#125;q[maxn&lt;&lt;2] , lq[maxn&lt;&lt;2] , rq[maxn&lt;&lt;2];inline void update(int pos , int val)&#123; if(pos == 0) return ; for( ; pos &lt;= n ; pos += pos &amp; -pos) bit[pos] += val;&#125;inline int query(int pos)&#123; if(!pos) return 0; int ans = 0; for( ; pos ; pos -= pos &amp; -pos) ans += bit[pos]; return ans;&#125;void VDC(int vl , int vr , Node* cur , int al , int ar)&#123; if(vl == vr) &#123; for(int i = al ; i &lt;= ar ; ++i) if(cur[i].tp == 1) ans[cur[i].id] = vl; return; &#125; if(ar - al + 1 == 0) return ; int mid = vl + vr &gt;&gt; 1 , lqt = 0 , rqt = 0; for(int i = al ; i &lt;= ar ; ++i) &#123; if(cur[i].tp == 0) &#123; if(cur[i].v &lt;= mid) &#123; update(cur[i].l , cur[i].r); lq[++lqt] = cur[i]; &#125; else rq[++rqt] = cur[i]; &#125; else if(cur[i].tp == 1) &#123; int l = cur[i].l , r = cur[i].r , v = cur[i].v; int cnt = query(r) - query(l-1); if(cnt &gt;= v) lq[++lqt] = cur[i]; else cur[i].v -= cnt , rq[++rqt] = cur[i]; &#125; &#125; for(int i = al ; i &lt;= ar ; ++i) if(cur[i].tp == 0 &amp;&amp; cur[i].v &lt;= mid) update(cur[i].l , -cur[i].r); for(int i = 1 ; i &lt;= lqt ; ++i) cur[i] = lq[i]; for(int i = 1 ; i &lt;= rqt ; ++i) cur[i+lqt] = rq[i]; VDC(vl , mid , cur , 1 , lqt); VDC(mid + 1 , vr , cur , 1 + lqt , lqt + rqt);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int t = 0; for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%d",&amp;val[i]); q[++t].tp = 0 , q[t].l = i , q[t].r = 1 , q[t].v = val[i]; &#125; int tot = 0; for(int i = 1 ; i &lt;= m ; ++i) &#123; int l , r , v; char op; scanf("\n%c",&amp;op); if(op == 'Q') scanf("%d%d%d",&amp;l,&amp;r,&amp;v) , q[++t].tp = 1 , q[t].id = ++tot , q[t].l = l , q[t].r = r , q[t].v = v; else &#123; scanf("%d%d",&amp;l,&amp;r) , q[++t].tp = 0 , q[t].l = l , q[t].r = -1 , q[t].v = val[q[t].l] , q[++t].tp = 0 , q[t].l = l , q[t].r = 1 , q[t].v = r , val[q[t].l] = r; &#125; &#125; VDC(-RANGE,RANGE,q,1,t); for(int i = 1 ; i &lt;= tot ; ++i) printf("%d\n",ans[i]);&#125; 上午luogu有场比赛，感觉还挺有意思，就参加了一下。 暂时前十qwq？]]></content>
      <tags>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 35]]></title>
    <url>%2F2018%2F12%2F29%2F2018.12.29%2F</url>
    <content type="text"><![CDATA[本来想这段时间做做高级算法综合题，不过hz跟我说有场他们出的比赛，我就参加了。 结果发现D题卡SPFA，不然就跟AH学长并列第一260了qwq(Starrydream) 然后就下午了，感觉不睡午觉会困qwq 先看道POI的Hash题。 「POI2010」珍珠项链 Beads题目描述Byteasar 决定制造一条项链，她买了一串珠子，她有一个机器，能把这条珠子切成很多段，使得每段恰有 kk 个珠子 (k&gt;0)(k&gt;0) ，如果这条珠子的长度不是 kk 的倍数，最后一块长度小于 kk 的段就被丢弃了。Byteasar 想知道，选择什么数字 kk 可以得到最多的不同的段。注意这里的段是可以反转的，即，子串 1,2,31,2,3 和 3,2,13,2,1 被认为是一样的。 输入格式第一行一个正整数 nn ，表示珠子的长度。第二行 nn 个空格隔开的正整数 a_1,a_2,\cdots a_na1​,a2​,⋯an​ ，描述这一串珠子的颜色。 输出格式第一行两个空格隔开的正整数，第一个表示能获得的最大不同的段的个数，第二个表示能获得最大值的 kk 的个数。第二行若干空格隔开的正整数 kk ，表示所有能够取得最大值的 kk ，请将kk按照从小到大的顺序输出。 样例输入样例12211 1 1 2 2 2 3 3 3 1 2 3 3 1 2 2 1 3 3 2 1 输出样例126 12 数据范围与提示对于 $100\%$ 的数据， $1\le n\le 2\times 10^5$ 题解这题好像很好写，尤其是你在想出翻转只需要对后缀hash之后。 我们需要map来判断这个串是否之前有相同的或者反串相同的。 时间复杂度$O(nlog^2n)$ Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#define _MAX 200005int n , c[_MAX] , now;unsigned long long h[2][_MAX];std::vector&lt;int&gt; ans;struct Node&#123; unsigned long long k1, k2; bool operator &lt; (const Node&amp; x)const&#123; if(k1 == x.k1) return k2 &lt; x.k2; return k1 &lt; x.k1; &#125;&#125;;inline unsigned long long pow(int x , int y)&#123; unsigned long long ans = 1 , base = x; for( ; y ; y &gt;&gt;= 1 , base *= base) if(y &amp; 1) ans *= base; return ans;&#125;inline void pre()&#123; for(int i = 1 ; i &lt;= n ; ++i) h[0][i] = h[0][i-1] * 178431 + c[i]; for(int i = n ; i &gt;= 1 ; --i) h[1][i] = h[1][i+1] * 178431 + c[i];&#125;inline unsigned long long Prehash(int l , int r)&#123; return h[0][r] - h[0][l-1] * pow(178431 , r-l+1);&#125;inline unsigned long long Sufhash(int l , int r)&#123; return h[1][l] - h[1][r+1] * pow(178431,r-l+1);&#125;inline int solve(int k)&#123; int ans = 0; std::map&lt;unsigned long long , bool&gt; v1; for(int i = k ; i &lt;= n ; i += k) &#123; if(v1[Prehash(i-k+1,i)] || v1[Sufhash(i-k+1,i)]) continue; ++ans; v1[Prehash(i-k+1,i)] = true , v1[Sufhash(i-k+1,i)] = true; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;c[i]); pre(); for(int i = 1 ; i &lt;= n ; ++i) &#123; if(n/i &lt; now) continue; int k = solve(i); if(k &gt; now)&#123; ans.clear(); now = k; ans.push_back(i); &#125; else if(k == now) ans.push_back(i); &#125; printf("%d %d\n",now,(int)ans.size()); for(int i = 0 ; i &lt; (int)ans.size() ; ++i) printf("%d ",ans[i]);&#125; LOJ#144. DFS 序 1题目描述这是一道模板题。 给一棵有根树，这棵树由编号为 1\dots N1…N 的 NN 个结点组成。根结点的编号为 RR。每个结点都有一个权值，结点 ii 的权值为 v_ivi。接下来有 MM 组操作，操作分为两类： 1 a x，表示将结点 aa 的权值增加 xx； 2 a，表示求结点 aa 的子树上所有结点的权值之和。 输入格式第一行有三个整数 N,MN,M 和 RR。第二行有 NN 个整数，第 ii 个整数表示 v_ivi​。在接下来的 N-1N−1 行中，每行两个整数，表示一条边。在接下来的 MM 行中，每行一组操作。 输出格式对于每组 \texttt{2 a}2 a 操作，输出一个整数，表示「以结点 aa 为根的子树」上所有结点的权值之和。 样例样例输入 112 样例输出 112 样例输入 21234567891011121314151617181920212223242510 14 912 -6 -4 -3 12 8 9 6 6 28 22 108 62 77 16 310 92 410 51 4 -12 21 7 -12 101 10 52 11 7 -52 51 1 82 71 8 82 21 5 52 6 样例输出 212345672134121223314 数据范围与提示$1\leqslant N, M\leqslant 10^6 1\leqslant R\leqslant N -10^6\leqslant v_i, x\leqslant 10^6$ 题解这道题只需要dfs，是不是很简单 树的dfs序可过，HPD大概率不可过。 我们通过树的dfs将树的每个节点连续编号，并且由于dfs的性质总是深度优先，所以只有一个点的子树全被编号才会回溯进入下一个点， 然后一个点$k$的子树在序编号上就是$k+sz_k$了，然后我们就可以用小常数的树状数组在序列上轻松完成题目要求了。 时间复杂度$O((n+m)logn)$ Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define _max 1000005int idx , dfn[_max] , n , v[_max] , sz[_max] , r , m ;long long bit[_max] ;std::vector&lt;int&gt; g[_max];void dfs(int x , int fx)&#123; sz[x] = 1; dfn[x] = ++idx; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i]; if(v == fx) continue; dfs(v , x) , sz[x] += sz[v]; &#125;&#125;inline long long query(int pos)&#123; if(pos == 0) return 0; long long ans = 0; for( ; pos ; pos -= pos &amp; -pos) ans += bit[pos]; return ans;&#125;inline void update(int pos , int val)&#123; for( ; pos &lt;= n ; pos += pos &amp; -pos) bit[pos] += val;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;r); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); for(int i = 1 ; i &lt;= n - 1 ; ++i) &#123; int x , y ; scanf("%d%d",&amp;x,&amp;y); g[x].push_back(y) , g[y].push_back(x); &#125; dfs(r,r); for(int i = 1 ; i &lt;= n ; ++i) update(dfn[i],v[i]); for(int i = 1 ; i &lt;= m ; ++i) &#123; int op , pos , val; scanf("%d",&amp;op); if(op == 1) &#123; scanf("%d%d",&amp;pos,&amp;val); update(dfn[pos], val); &#125; else if(op == 2) &#123; scanf("%d",&amp;pos); printf("%lld\n",query(dfn[pos] + sz[pos] - 1) - query(dfn[pos]-1)); &#125; &#125;&#125; 「BalticOI 2014 Day 1」三个朋友题目描述本题译自 BalticOI 2014 Day1 T2「Three Friends」 给定一个字符串 SS，先将字符串 SS 复制一次（变成双倍快乐），得到字符串 TT，然后在 TT 中插入一个字符，得到字符串 UU。 给出字符串 UU，重新构造出字符串 SS。 所有字符串只包含大写英文字母。 输入格式第一行一个整数 NN，表示字符串 UU 的长度。 第二行一个长度为 NN 的字符串，表示字符串 UU。 输出格式一行一个字符串，表示字符串 SS。 特别地： 如果字符串不是按照题述方法构造的，输出 NOT POSSIBLE； 如果字符串 SS 不唯一，输出 NOT UNIQUE。 样例样例输入 1127ABXCABC 样例输出 11ABC 样例输入 2126ABCDEF 样例输出 21NOT POSSIBLE 样例输入 3129ABABABABA 样例输出 31NOT UNIQUE 数据范围与提示 子任务 分数 数据范围 1 3535 2\le N\le 20012≤N≤2001 2 6565 2\le N\le 20000012≤N≤2000001 题解这题思路不难想。 首先分类讨论，要么在左半边要么右半边，然后枚举字符，利用hash快速算出删除那部分的hash和没删除的一半的hash，然后比较相等不相等就行了。 关键在于如何快速合并两个hash，这感觉是数学了吧。。 我们将删除左边的那部分串的绝对hash算出来（就是前缀hash通过快速幂相减），然后*base在加上另一部分。 然后这个值整体乘base在$2^{64}$下的逆元就可以了。。 不知道这个口胡的方法对不对，总之大体思路就是这样的，等有心情写代码就试试。 LOJ#10064. 「一本通 3.1 例 1」黑暗城堡题目描述你知道黑暗城堡有 NN 个房间，MM 条可以制造的双向通道，以及每条通道的长度。 城堡是树形的并且满足下面的条件： 设 D_iDi 为如果所有的通道都被修建，第 ii 号房间与第 11 号房间的最短路径长度； 而 S_iSi 为实际修建的树形城堡中第 ii 号房间与第 11 号房间的路径长度； 要求对于所有整数 ii (1\le i\le N1≤i≤N)，有 S_i= D_iSi=Di 成立。 你想知道有多少种不同的城堡修建方案。当然，你只需要输出答案对 2^{31} -1231−1 取模之后的结果就行了。 输入格式第一行为两个由空格隔开的整数 N, MN,M; 第二行到第 M+1M+1 行为 33 个由空格隔开的整数 x, y, lx,y,l：表示 xx 号房间与 yy 号房间之间的通道长度为 ll。 输出格式一个整数：不同的城堡修建方案数对 2^{31} -1231−1 取模之后的结果。 样例样例输入12345674 61 2 11 3 21 4 32 3 12 4 23 4 1 样例输出16 样例说明一共有 44 个房间，66 条道路，其中 11 号和 22 号，11 号和 33 号，11 号和 44 号，22 号和 33 号，22 号和 44 号，33 号和 44 号房间之间的通道长度分别为 11，22，33，11，22，11。 而不同的城堡修建方案数对 $2^{31}$ -1取模之后的结果为 66。 数据范围与提示对于全部数据，$1\le N\le 10001≤N≤1000，1\le M\le \frac{N(N-1)}{2}1≤M≤2N(N−1)$ 题解这个题我似乎受一道高难度图论省选题的启发想出了一个做法。 首先一眼看出这是让你求最短路径生成树的个数。 我们大概知道一个最短路径生成树怎么求。 但是求个数的话。 不妨联想如果我们把所有最短路加到一个图里，是不是可以通过某些神奇的组合原理统计答案呢？ 答案是肯定的。 这个所有最短路都被加入的图是有拓扑性质的，为什么呢？ 证明命题：最短路图中不存在正环（0环和负环题目必须保证不存在） 从定义出发，如果图中有正环，那么从左和右必有一个更小的，因此不能有环。 严谨证明By shadowice： 原理，我们发现如果有最短路就不可以有负环，因此，我们考虑走过属于一条最短路的一条边的过程，我们会发现，一定是从dis值低的点走到了dis值高的点(因为没零环)，相当于我们一直在上坡，而显然，一个一直上坡的环是不存在的 因此我们在DIJKSTRA的过程中建出这个图（反向，不然怎么统计呢？），然后通过拓扑排序+dp可以在$O(n+m)$ 的时间里求出这个方案数。 然后由于现在非常懒，所以不想写代码。 话说我能想出这道题还真是被HAOI的道路那道题启发了呢。 关于用Dijkstra如何求严格次短路。 显然有些奇怪的人严格次短路也不想让你用SPFA，那么我们就应该想想如何使用DIJKSTRA求次短路。 严格次短路还是挺简单的，非严格次短路可能比较麻烦，也许得记录最短路的更新点然后再枚举边。。 严格只需要枚举每条边，然后这条边的边权加上源点到这条边一个点的距离加上终点到另一个的最短路大于源点到终点的最短路即可，至于为什么这样做是正确的，好像只需要从最短路的定义出发就不难证明。。 证明：对于枚举的边，如果在最短路上，两端点必然都是最短路的值，否则，根据仅次于最短路，我们应该让到达这条边和从这条边到终点都尽可能小。可能这种贪心保证最后答案一定正确且最优吧。。 不会证明qwq Color a Tree Time Limit: 1000MS Memory Limit: 30000K Total Submissions: 8640 Accepted: 2980 Description Bob is very interested in the data structure of a tree. A tree is a directed graph in which a special node is singled out, called the “root” of the tree, and there is a unique path from the root to each of the other nodes. Bob intends to color all the nodes of a tree with a pen. A tree has N nodes, these nodes are numbered 1, 2, …, N. Suppose coloring a node takes 1 unit of time, and after finishing coloring one node, he is allowed to color another. Additionally, he is allowed to color a node only when its father node has been colored. Obviously, Bob is only allowed to color the root in the first try. Each node has a “coloring cost factor”, Ci. The coloring cost of each node depends both on Ci and the time at which Bob finishes the coloring of this node. At the beginning, the time is set to 0. If the finishing time of coloring node i is Fi, then the coloring cost of node i is Ci * Fi. For example, a tree with five nodes is shown in Figure-1. The coloring cost factors of each node are 1, 2, 1, 2 and 4. Bob can color the tree in the order 1, 3, 5, 2, 4, with the minimum total coloring cost of 33.Given a tree and the coloring cost factor of each node, please help Bob to find the minimum possible total coloring cost for coloring all the nodes. Input The input consists of several test cases. The first line of each case contains two integers N and R (1 &lt;= N &lt;= 1000, 1 &lt;= R &lt;= N), where N is the number of nodes in the tree and R is the node number of the root node. The second line contains N integers, the i-th of which is Ci (1 &lt;= Ci &lt;= 500), the coloring cost factor of node i. Each of the next N-1 lines contains two space-separated node numbers V1 and V2, which are the endpoints of an edge in the tree, denoting that V1 is the father node of V2. No edge will be listed twice, and all edges will be listed. A test case of N = 0 and R = 0 indicates the end of input, and should not be processed. Output For each test case, output a line containing the minimum total coloring cost required for Bob to color all the nodes. Sample Input 12345675 11 2 1 2 41 21 32 43 50 0 Sample Output 133 Source Beijing 2004 题解算法竞赛进阶指南上一道挺神的贪心。 用到了等效替代的思想，贪心里用这个东西一定要注意完全等效，是需要数学推导的。 发现还是不会，贪心好难啊qwq，以后还会回来看的。。 Dynamic Rankings 自定义测试 Description给定一个含有n个数的序列a[1],a[2],a[3]……a[n]，程序必须回答这样的询问：对于给定的i,j,k，在a[i],a[i+1 ],a[i+2]……a[j]中第k小的数是多少(1≤k≤j-i+1)，并且，你可以改变一些a[i]的值，改变后，程序还能针对改 变后的a继续回答上面的问题。 Input第一行有两个正整数n(1≤n≤10000)，m(1≤m≤10000)。 分别表示序列的长度和指令的个数。 第二行有n个数，表示a[1],a[2]……a[n]，这些数都小于10^9。 接下来的m行描述每条指令 每行的格式是下面两种格式中的一种。 Q i j k 或者 C i t Q i j k （i,j,k是数字，1≤i≤j≤n, 1≤k≤j-i+1） 表示询问指令，询问a[i]，a[i+1]……a[j]中第k小的数。 C i t (1≤i≤n，0≤t≤10^9)表示把a[i]改变成为t m,n≤10000 Output 对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。 Sample Input5 3 3 2 1 4 7 Q 1 4 3 C 2 6 Q 2 5 3 Sample Output3 6 题解终于想明白带修改的整体二分该怎么做，再写今天最后一篇口胡题解。 我们还是按照值域划分。不过把修改拆成删除原数加入新数两个修改。 设计一个函数$solve(l,r,s,t)$表示分治值域$l,r$对于在这个值域内的修改$s,t$ 然后利用权值树状数组进行统计。 然后对于个数小于等于$k$的把询问加在分治左边，大于$k$的放在右边，这里和静态整体二分是一样的。 唯一不同的是我们对修改也这么分类（按照值域），然后将同一类的复制到原数组使其连续然后继续分治。 终于明白了。]]></content>
      <tags>
        <tag>比赛 hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 34]]></title>
    <url>%2F2018%2F12%2F28%2F2018.12.28%2F</url>
    <content type="text"><![CDATA[时光没有教会我任何东西，却教会了我不要轻易去相信童话。 LOJ#6284. 数列分块入门 8题目描述给出一个长为 nn 的数列，以及 nn 个操作，操作涉及区间询问等于一个数 cc 的元素，并将这个区间的所有元素改为 cc。 输入格式第一行输入一个数字 nn。 第二行输入 nn 个数字，第 i 个数字为 a_iai，以空格隔开。 接下来输入 nn 行询问，每行输入三个数字 ll、rr、cc，以空格隔开。 表示先查询位于 [l,r][l,r] 的数字有多少个是 cc，再把位于 [l,r][l,r] 的数字都改为 cc。 输出格式对于每次询问，输出一行一个数字表示答案。 样例样例输入12345641 2 2 41 3 11 4 41 2 21 4 2 样例输出12341102 数据范围与提示对于 100\%100% 的数据，$1 \leq n \leq 100000,$ 题解似乎是我最近写的最简单的分块了吧。 主要还是懒标记应用，然后注意块标记时效性， 有点类似于时间戳。 注意由于可能c为0，所以当不完整的块破坏标记整体性使得我们要像块内每个元素下推标记的时候，不要赋成0，用一个奇奇怪怪的数来代替0. 然后就没什么了，关于昨天那道单点插入的题，可以把排序改成insert，不过一直RE调不对奇怪的边界 关于本题还有一个有趣的地方就是我们发现query函数中看上去很暴力，完全就是线性的复杂度。 但是我们再分析一下题意：只要询问完一个区间，就立刻修改。 这意味着每个数在初始的时候被修改一次后，后面的查询在整块上就可以$O(1)$来判断当前块了。 或者我们可以把初始数的暴力枚举和后面已经经过至少一次修改的数分开来看。 每次修改查询连在一起，修改将产生$O(\sqrt{N})$个不完整块，其他块将被标记。这样复杂度高的线性查询最多进行$O(n/sqrt{n})$次 不管怎样，大量查询后每个元素因为初始没有任何标记至多被暴力计算一次，其他情况下就是整段快速统计边角暴力了。这样由于最初没有任何标记只是小复杂度。当时写的时候还差点以为我写了一个假复杂度的暴力233. 然后我们就愉快的1A本题。 BUG： 这里如果底下加一个else就会造成巨难调的错误，所以千万要注意！ Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define _MAX 100005#define _MAXSQRT 355#define Rand -0x3f7f3ffint mk[_MAXSQRT] , n , v[_MAX] , L[_MAXSQRT] , R[_MAXSQRT] , pos[_MAX] , blnum , blsize;inline void print(int l , int r)&#123; puts("ARRAY"); for(int i = l ; i &lt;= r ; ++i) &#123; if(mk[pos[i]] == Rand) printf("%d ",v[i]); else printf("%d ",mk[pos[i]]); &#125; putchar(10);&#125;inline void pre()&#123; blsize = (int)std::sqrt(n); blnum = n / blsize; for(int i = 1 ; i &lt;= blnum ; ++i) L[i] = (i-1)*blsize + 1, R[i] = i * blsize; if(R[blnum] &lt; n) ++blnum , L[blnum] = R[blnum-1]+1 , R[blnum] = n; for(int i = 1 ; i &lt;= blnum ; ++i) for(int j = L[i] ; j &lt;= R[i] ; ++j) pos[j] = i ; for(int i = 1 ; i &lt;= blnum ; ++i) mk[i] = Rand;// printf("BLNUM : %d BLSIZE%d\n",blnum,blsize);// for(int i = 1 ; i &lt;= blnum ; ++i)// printf("L:%d R:%d\n",L[i],R[i]);&#125;inline void update(int l , int r , int c)&#123;// printf("UPD:%d %d %d\n",l,r,c); if(pos[l] == pos[r]) &#123;// puts("UPD SAME BLOCK"); if(mk[pos[l]] != Rand) for(int i = L[pos[l]] ; i &lt;= R[pos[l]] ; ++i) v[i] = mk[pos[l]]; mk[pos[l]] = Rand; for(int i = l ; i &lt;= r ; ++i) v[i] = c;// print(t1,t2); return ; &#125; if(mk[pos[l]] != Rand) for(int i = L[pos[l]] ; i &lt;= R[pos[l]] ; ++i) v[i] = mk[pos[l]]; mk[pos[l]] = Rand; for( ; L[pos[l]] != l ; ++l) v[l] = c; if(mk[pos[r]] != Rand) for(int i = L[pos[r]] ; i &lt;= R[pos[r]] ; ++i) v[i] = mk[pos[r]]; mk[pos[r]] = Rand; for( ; R[pos[r]] != r ; --r) v[r] = c;// if(l &gt; r) puts("RETURN !"); if(l &gt; r) return ; for(int i = pos[l] ; i &lt;= pos[r] ; ++i) mk[i] = c;// puts("UPD NOW");// print(t1,t2); return ;&#125;inline int query(int l , int r , int c)&#123;// printf("QUERY %d %d %d\n",l,r,c);// print(l,r); int ans = 0; if(pos[l] == pos[r]) &#123;// puts("SAME BLOCK!"); if(mk[pos[l]] == c) return r-l+1; //maybe the c is zero!! else if(mk[pos[l]] != Rand) return 0; else for(int i = l ; i &lt;= r ; ++i) if(v[i] == c) ++ans; return ans; &#125; for(int i = pos[l] ; i &lt;= pos[r] ; ++i) &#123;// printf("THE I BLOCK MK: %d\n",mk[i]); if(mk[i] == Rand) &#123; for(int j = std::max(L[i],l) ; j &lt;= std::min(r,R[i]) ; ++j) if(v[j] == c) ++ans; &#125; else if(mk[i] == c) ans += std::min(R[i],r) - std::max(l,L[i]) + 1; &#125; return ans;&#125;int main()&#123;// freopen("data.in","r",stdin);// freopen("my.out","w",stdout); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); pre(); for(int i = 1 ; i &lt;= n ; ++i) &#123; int l , r , c; scanf("%d%d%d",&amp;l,&amp;r,&amp;c); printf("%d\n",query(l,r,c)); update(l,r,c); &#125;&#125; 分块系列就没了，剩下几个都是做过的了。 接下来就做做字符串和POI. NOIp 2018 货币系统题目描述在网友的国度中共有 nn 种不同面额的货币，第 ii 种货币的面额为 a[i]a[i]，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 nn、面额数组为 a[1..n]a[1..n] 的货币系统记作 (n,a)(n,a)。 在一个完善的货币系统中，每一个非负整数的金额 xx 都应该可以被表示出，即对每一个非负整数 xx，都存在 nn 个非负整数 t[i]t[i] 满足 a[i] \times t[i]a[i]×t[i] 的和为 xx。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 xx不能被该货币系统表示出。例如在货币系统 n=3n=3, a=[2,5,9]a=[2,5,9] 中，金额 1,31,3 就无法被表示出来。 两个货币系统 (n,a)(n,a) 和 (m,b)(m,b) 是等价的，当且仅当对于任意非负整数 xx，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 现在网友们打算简化一下货币系统。他们希望找到一个货币系统 (m,b)(m,b)，满足 (m,b)(m,b) 与原来的货币系统 (n,a)(n,a)等价，且 mm 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 mm。 输入输出格式输入格式： 输入文件的第一行包含一个整数 TT，表示数据的组数。 接下来按照如下格式分别给出 TT 组数据。 每组数据的第一行包含一个正整数 nn。接下来一行包含 nn 个由空格隔开的正整数 a[i]a[i]。 输出格式： 输出文件共有 TT 行，对于每组数据，输出一行一个正整数，表示所有与 (n,a)(n,a) 等价的货币系统 (m,b)(m,b) 中，最小的 mm。 输入输出样例输入样例#1： 复制 123452 4 3 19 10 6 5 11 29 13 19 17 输出样例#1： 复制 122 5 说明在第一组数据中，货币系统 (2, [3,10])(2,[3,10]) 和给出的货币系统 (n, a)(n,a) 等价，并可以验证不存在 m &lt; 2m&lt;2 的等价的货币系统，因此答案为 22。 在第二组数据中，可以验证不存在 m &lt; nm&lt;n 的等价的货币系统，因此答案为 55。 【数据范围与约定】 对于 100\%100% 的数据，满足 1 ≤ T ≤ 20, n,a[i] ≥ 11≤T≤20,n,a[i]≥1。 题解我大概就是被这道题搞死的吧。。 这题当时要是我能看出一个结论：必须是真子集也许就A了吧。 可惜最后获得了0分的好成绩。 对于b，设其内部元素大的不能被小的表示出来。从小到大假如其中有一个元素不是a中的，如果能被a中的凑出来，那用a中凑出来的就小于它，因此仅单选哪些元素中的一个b就表示不出来。假如不能被a凑出来，那单选这个也不满足题意。。 然而考场上就是没有想到这个显而易见的事实。 Code： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define _MAX 505int a[_MAX] , vis[_MAX&lt;&lt;10] , n , t , mx = -0x7fffff;int main()&#123; scanf("%d",&amp;t); while(~--t) &#123; std::memset(vis,0,sizeof(vis)); mx = -0x7fffff; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;a[i]) , mx = std::max(mx , a[i]); std::sort(a+1,a+n+1); vis[0] = 1; int ans = n; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(vis[a[i]])&#123; --ans; continue; &#125; for(int j = a[i] ; j &lt;= mx ; ++j) if(vis[j-a[i]]) vis[j] = true; &#125; printf("%d\n",ans); &#125;&#125; LOJ#2452. 「POI2010」反对称 Antisymmetry题目描述对于一个 0/1字符串，如果将这个字符串 0 和 1 取反后，再将整个串反过来和原串一样，就称作「反对称」字符串。比如 00001111 和 010101 就是反对称的，而 1001 就不是。现在给出一个长度为 n 的 0/1 字符串，求它有多少个子串是反对称的，注意这里相同的子串出现在不同的位置会被重复计算。 输入格式第一行一个正整数 nn 。第二行一个长度为 nn 的 0/10/1 字符串。 输出格式一行一个整数，表示原串的反对称子串个数。 样例样例输入12811001011 样例输出17 数据范围与提示对于 $100\%$的数据， $1\le n\le 500\ 000$ 。 题解挺不错的一道题，POI的题果然质量高。 我们得观察串的性质。 首先第一点是长度必须为偶数，并且一个串从中点为对称轴左右必须互异。 能得到这个性质不难写出$O(n^2)$的Hash算法优化暴力，可以获得50分。 然后不妨再想想根据我们观察出的性质如何优化。我们来想想暴力统计的都是什么样的， 输出观察一下发现很多都互相包含，而且连续。 然后不难想出枚举中间对称点，二分长度了，之所以能二分是因为对于相同对称轴长的包含短的。 注意方向，左边是从右向左和对称轴右边的从左向右，不难想到只需要把左边的从右边开始后缀Hash即可。 最重要的bug，不要随便用static！！那个东西在函数里声明是有特殊用途的，没事别瞎写。 忘了是从右向左忘了开longlong结果WA了两次。。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define _MAX 500005int n , r[_MAX];unsigned long long h[2][_MAX] , p[_MAX] , ans;char s[_MAX];inline void pre()&#123; for(int i = 1 ; i &lt;= n ; ++i) r[i] = s[i] - 48 ^ 1; for(int i = 1 ; i &lt;= n ; ++i) h[0][i] = (h[0][i-1] * 137) + s[i] ; for(int i = n ; i &gt;= 1 ; --i) h[1][i] = (h[1][i+1] * 137) + r[i] + 48;&#125;inline unsigned long long pow(int x , int y)&#123; unsigned long long ans = 1 , base = x; for( ; y ; y &gt;&gt;= 1 , base *= base) if(y &amp; 1) ans *= base; return ans;&#125;inline unsigned long long Prehash(int l , int r)&#123; unsigned long long ans = h[0][r] - h[0][l-1] * p[r-l+1]; return ans;&#125;inline unsigned long long Sufhash(int l , int r)&#123; return h[1][l] - h[1][r+1] * p[r-l+1];&#125;int main()&#123; scanf("%d",&amp;n); scanf("%s",s+1); pre(); p[0] = 1; for(int i = 1 ; i &lt;= n ; ++i) p[i] = p[i-1]*137; for(int i = 1 ; i &lt; n ; ++i) &#123; int l = 1 , r = std::min(i , n - i) , cur = 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; // printf("NOW %d %d %llu %d %d %llu\n",i-mid+1,i,hash(i-mid+1,i,1),i+1,i+mid,hash(i+1,i+mid,0)); if(Sufhash(i-mid+1,i) == Prehash(i+1,i+mid)) cur = mid , l = mid + 1; else r = mid - 1; &#125; // printf("THE LCP:%d\n",cur); ans += cur; &#125; printf("%llu\n",ans);&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 33]]></title>
    <url>%2F2018%2F12%2F27%2F2018.12.27%2F</url>
    <content type="text"><![CDATA[这是成王败寇的残酷。 LOJ#6281. 数列分块入门 5题目描述给出一个长为 nn 的数列 a_1\ldots a_na1…an，以及 nn 个操作，操作涉及区间开方，区间求和。 输入格式第一行输入一个数字 nn。 第二行输入 nn 个数字，第 ii 个数字为 a_iai，以空格隔开。 接下来输入 nn 行询问，每行输入四个数字 \mathrm{opt}, l, r, copt,l,r,c，以空格隔开。 若 \mathrm{opt} = 0opt=0，表示将位于 [l, r][l,r] 的之间的数字都开方。对于区间中每个 a_i(l\le i\le r),\: a_i ← \left\lfloor \sqrt{a_i}\right\rfloorai(l≤i≤r),ai←⌊ai⌋ 若 \mathrm{opt} = 1opt=1，表示询问位于 [l, r][l,r] 的所有数字的和。 输出格式对于每次询问，输出一行一个数字表示答案。 样例样例输入12345641 2 2 30 1 3 11 1 4 40 1 2 21 1 2 4 样例输出1262 数据范围与提示对于 $100\%$的数据，$1 \leq n \leq 50000$。 题解这道题倒是不难想，不过还是犯了两个sb错误WA了好几遍。。。 先说思路，我们可以思考如何在线维护每块的和。 说出来你可能不信，我们暴力给所有数开方。 什么？那不TLE？这里就用到分块的思想了，考虑到每个修改被分块后就只有两个不完整的。 不完整的肯定要暴力开方并且维护块内元素和。 完整的呢？也暴力开方维护块内元素和，不过由于是完整的块，我们可以标记这个块被标记了几遍，假如被标记次数过多（大概8次）就可以确定这个块内元素非0即1。（注意可以是0，思维一定要缜密） 查询的时候就可以按照分块的方法大段查询小段暴力就可以了。 bug如下： 显然整块计算应该是nl，nr。。 导致结果偏大的不止这个，另一个必须静态查错才行（对拍几乎不可能拍出来，除非你知道错误）： 有0的话那个数开多少次都是0，我标记到一定次数直接把块的和赋值为长度了，然后就偏大了。。。 然后就没有其他错误了。 这道题最重要的是没有任何增量运算，因此抓住这点结合开方后的数快速变小的特点不难设计出这个算法 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define _Max 50005#define _MaxSqrt 345int L[_MaxSqrt] , R[_MaxSqrt] , pos[_Max] , tag[_MaxSqrt] , n , v[_Max] , sum[_MaxSqrt] , blsize , blnum;inline int getsqrt(int k , int t)&#123; if(t &gt; 6) return 0; for(int i = 1 ; i &lt;= t; ++i) k = (int)std::sqrt(k); return k;&#125;inline void print()&#123; puts("BLOCK INFO"); for(int i = 1 ; i &lt;= blnum ; ++i) printf("L:%d R:%d SUM:%d\n",L[i],R[i],sum[i]); puts("ARRAY"); for(int i = 1 ; i &lt;= n ; ++i) printf("%d ",v[i]); puts("OUT FINISHED");&#125;inline void pre()&#123; blsize = (int)std::sqrt(n); blnum = n / blsize; for(int i = 1 ; i &lt;= blnum ; ++i) L[i] = (i-1) * blsize + 1, R[i] = i * blsize; if(R[blnum] &lt; n) ++ blnum , L[blnum] = R[blnum-1] + 1 , R[blnum] = n; for(int i = 1 ; i &lt;= blnum ; ++i) for(int j = L[i] ; j &lt;= R[i] ; ++j) pos[j] = i , sum[i] += v[j];// print();&#125;inline void update(int l , int r)&#123; if(pos[l] == pos[r]) &#123; for(int i = l ; i &lt;= r ; ++i) sum[pos[l]] += (int)std::sqrt(v[i]) - v[i] , v[i] = (int)std::sqrt(v[i]); return; &#125; int nl , nr; if(L[pos[l]] == l) nl = l; else nl = L[pos[l]+1]; if(R[pos[r]] == r) nr = r; else nr = R[pos[r]-1]; for(int i = l ; i &lt; nl ; ++i) sum[pos[i]] += (int)std::sqrt(v[i]) - v[i] , v[i] = (int)std::sqrt(v[i]); for(int i = nr + 1 ; i &lt;= r ; ++i) sum[pos[i]] += (int)std::sqrt(v[i]) - v[i] , v[i] = (int)std::sqrt(v[i]); if(nl &gt; nr) return; for(int i = pos[nl] ; i &lt;= pos[nr] ; ++i) &#123; ++tag[i]; if(tag[i] &gt; 8) continue; else if(tag[i] == 8) &#123; sum[i] = 0; for(int j = L[i] ; j &lt;= R[i] ; ++j) sum[i] += v[j]; continue; &#125; for(int j = L[i] ; j &lt;= R[i] ; ++j) sum[i] += (int)std::sqrt(v[j]) - v[j] , v[j] = (int)std::sqrt(v[j]); &#125; return;&#125;inline int query(int l , int r)&#123;// printf("QUERY:%d %d\n",l,r); // print(); int ans = 0; if(pos[l] == pos[r]) &#123; for(int i = l ; i &lt;= r ; ++i) ans += v[i]; return ans; &#125; int nl , nr; if(L[pos[l]] == l) nl = l; else nl = L[pos[l]+1]; if(R[pos[r]] == r) nr = r; else nr = R[pos[r]-1]; for(int i = l ; i &lt; nl ; ++i) ans += v[i]; for(int i = nr + 1 ; i &lt;= r ; ++i) ans += v[i]; if(nl &gt; nr) return ans; for(int i = pos[nl] ; i &lt;= pos[nr] ; ++i) ans += sum[i];// print(); return ans;&#125;int main()&#123;// freopen("data.in","r",stdin);// freopen("my.out","w",stdout); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); pre(); for(int i = 1 ; i &lt;= n ; ++ i) &#123; int op , l , r , val; scanf("%d%d%d%d",&amp;op,&amp;l,&amp;r,&amp;val); if(op &amp; 1) printf("%d\n",query(l,r)); else update(l,r); &#125;&#125; LOJ#6282. 数列分块入门 6题目描述给出一个长为 nn 的数列，以及 nn 个操作，操作涉及单点插入，单点询问，数据随机生成。 输入格式第一行输入一个数字 nn。 第二行输入 nn 个数字，第 i 个数字为 a_iai，以空格隔开。 接下来输入 nn 行询问，每行输入四个数字 \mathrm{opt}opt、ll、rr、cc，以空格隔开。 若 \mathrm{opt} = 0opt=0，表示在第 ll 个数字前插入数字 rr (cc 忽略)。 若 \mathrm{opt} = 1opt=1，表示询问 a_rar 的值（ll 和 cc 忽略）。 输出格式对于每次询问，输出一行一个数字表示答案。 样例样例输入12345641 2 2 30 1 3 11 1 4 40 1 2 21 1 2 4 样例输出1223 数据范围与提示对于 $100\%$的数据，$1 \leq n \leq 100000$ 题解这道题也挺有意思，目前想出来一个做法（应该不随机也没有关系）。 我们应该想到这样一个事实：对于一个数被插入到某个位置，后面会整体移动。 假如我们想使用根号算法优化这个过程，能联想到什么呢？对下标的懒标记！ 设块大小为$S$ 我们保证每一块块内的下标有序，维护这个块还要支持插入。 我们想用什么呢？ vector+排序（Splay）！ 对于插入点所在块， $O(S)$暴力枚举所有id需要修改的元素，加1后把修改元素和id插进vector然后排序$O(Slogn)$（其实这里可以做到线性，只不过有点麻烦就懒得弄了，其实就是一个模拟。。）。 枚举每一块$O(1)$判断是否在插入点后面（可能你会疑惑为什么不直接访问插入块后面的就行了，一开始分的时候不就是块间下标相对单调升的？别忘了为了防止特殊数据大量集中在一块导致排序等维护块有序的代价过大，我们还有重构操作，具体来说就是可能不断使用后面的vector从而块间相对并不是单调的。反正只要块数量在$O(\sqrt{n})$级别，就可以在时限内完成） 然后枚举每一块，假如最小值加上$tag$在这个点的后面，$tag$就再加一。 我们通过上述操作可以在$O(Slogn+n/S)$的时间内维护块内下标均单调的vector。 让我们分析如何查询。 对于给定的一个位置，我们$O(n/S)$枚举每个块，找到位置所在块，由于下标单调，$O(1)$找到那个元素值相应查询即可。 这样一来块大小取$\sqrt{n}$可过，假如你把vector排序换成手动模拟，那么就可以做到每次严格$O(\sqrt{n})$ 代码估计今天都不一定写的完。。 历经千辛万苦终于得到一个TLE的代码，话说又有bug，不过确实是因为本题算法编程复杂度比较高导致的。。 看bug： 这里忘了减$tag_{ubl}$确实不是忘了是大脑短路，索性各种调试定位后后想了下该减掉tag 这里就是对拍后进行精确数据分析分析出来的了，重构后不要忘了把新块的tag赋成原块的。 然后这是TLE3个点的代码 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define _Max 200005#define _MaxSqrt 465int L[_MaxSqrt] , R[_MaxSqrt] , tag[_MaxSqrt] , a[_Max&gt;&gt;1] , n , blsize , blnum;struct Node&#123; int v , id; bool operator &lt; (const Node&amp; x)const&#123; return id &lt; x.id; &#125;&#125;;std::vector&lt;Node&gt; bl[_MaxSqrt];inline void print()&#123; puts("DEBUG INFO"); printf("BLNUM:%d BLSIZE:%d\n",blnum,blsize); for(int i = 1 ; i &lt;= blnum ; ++i) &#123; printf("BLOCK : %d\n",i); printf("THE TAG IS : %d Range: %d %d\n",tag[i],bl[i][0].id+tag[i],bl[i][(int)bl[i].size()-1].id+tag[i]); puts("ARRAY ELEMENTS:"); for(int j = 0 ; j &lt; (int)bl[i].size() ; ++j) printf("(%d,%d) ",bl[i][j].v,bl[i][j].id+tag[i]); putchar(10); &#125; puts("DEBUG FINISH"); puts("");&#125;inline void rebuild(std::vector&lt;Node&gt;&amp; v , int k)&#123;// puts("REBUILD!!"); ++blnum; while((int)v.size() &gt; blsize) &#123; bl[blnum].push_back(v[(int)v.size()-1]); v.pop_back(); &#125; std::sort(bl[blnum].begin(),bl[blnum].end()); tag[blnum] = k;// print();&#125;inline void pre()&#123; blsize = (int)pow(n , 0.5); blnum = n / blsize; for(int i = 1 ; i &lt;= blnum ; ++i) L[i] = (i-1)*blsize + 1, R[i] = i*blsize; if(R[blnum] &lt; n) ++blnum , L[blnum] = R[blnum-1] + 1 , R[blnum] = n; for(int i = 1 ; i &lt;= blnum ; ++i) for(int j = L[i] ; j &lt;= R[i] ; ++j) bl[i].push_back((Node)&#123;a[j],j&#125;);// print();&#125;inline void printS(const std::vector&lt;Node&gt;&amp; k)&#123; printf("SQRQASR\n"); printf("%d\n",k.size()); for(int i = 0 ; i &lt; (int)k.size() ; ++i) printf("(%d %d)\n",k[i].v,k[i].id);&#125;inline void update(int p , int k)&#123;// printf("UPDATE:%d %d\n",p,k); int ubl = 0; for(int i = 1 ; i &lt;= blnum ; ++i) if((int)bl[i].size() &amp;&amp; bl[i][0].id + tag[i] &lt;= p &amp;&amp; bl[i][(int)bl[i].size()-1].id + tag[i] &gt;= p)&#123; ubl = i; break; &#125;// printf("UPD THE UBL : %d\n",ubl); for(int i = 0 ; i &lt; (int)bl[ubl].size() ; ++i) if(bl[ubl][i].id + tag[ubl] &gt;= p) ++bl[ubl][i].id; bl[ubl].push_back((Node)&#123;k,p-tag[ubl]&#125;);// printS(bl[ubl]); std::sort(bl[ubl].begin() , bl[ubl].end());// printS(bl[ubl]);// print(); for(int i = 1 ; i &lt;= blnum ; ++i) if(bl[i][0].id + tag[i] &gt; p) tag[i] ++ ; if((int)bl[ubl].size() &gt; blsize * 2) rebuild(bl[ubl] , tag[ubl]);// print();&#125;inline int query(int p)&#123;// puts("DEBUG QUERY");// printf("QUERY %d\n",p);// print(); for(int i = 1 ; i &lt;= blnum ; ++i) &#123;// printf("NOW RANGE:%d %d\n",tag[i] + bl[i][0].id , tag[i] + bl[i][(int)bl[i].size()-1].id); if(tag[i] + bl[i][0].id &lt;= p &amp;&amp; tag[i] + bl[i][(int)bl[i].size()-1].id &gt;= p) &#123;// printf("THE BLOCK %d size : %d , range: %d %d",i,bl[i].size() , bl[i][0].id +tag[i], bl[i][(int)bl[i].size()-1].id+tag[i]);// for(int j = 0 ; j &lt; (int)bl[i].size() ; ++j)// printf("(%d %d)\n",bl[i][j].v,bl[i][j].id+tag[i]); return bl[i][p-bl[i][0].id-tag[i]].v; &#125; &#125;&#125;int main()&#123; freopen("data.in","r",stdin); freopen("my.out","w",stdout); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;a[i]); pre(); for(int i = 1 ; i &lt;= n ; ++i) &#123; int op , p , k , c; scanf("%d%d%d%d",&amp;op,&amp;p,&amp;k,&amp;c); if(op &amp; 1) printf("%d\n",query(k)); else update(p,k); &#125;&#125; 这代码稳健性好像也为0，块设小一点居然会RE。。 真是我写过最麻烦的分块。 做题调试时间还是太长了，ATP和zyf好像都说过这个问题哎。。。 突然想滚回去学文化课了，明明想出正解的复杂度居然还TLE，过分。 再写个莫队的题吧。（带修莫队和莫队差不多，就是稍麻烦点qwq） NOI.AC #44. color【题目描述】给定一串n个珠子，其中每一个珠子的颜色为a[i]，总共有k类颜色珠子标号从1到k。 初始给定一个参数T。询问再给定m个区间l[i]到r[i]，每次询问这个区间有多少颜色的珠子出现了恰好T次。 【输入格式】第一行四个整数n，m，k，T（1&lt;=n,m,k,T&lt;=5*10^5）。 第二行n个整数，第i个整数为a[i]，表示对应珠子的颜色(1&lt;=a[i]&lt;=k)。 接下来m行，每行两个整数l[i]和r[i],表示询问的区间(1&lt;=l[i]&lt;=r[i]&lt;=n)。 【输出格式】输出m行，每行一个整数，第i行表示第i次询问的答案。 【样例输入】123456710 5 5 11 5 3 4 2 4 1 2 3 5 1 103 6 2 85 76 10 【样例输出】1234502335 【数据范围】$1&lt;=n,m,k,T&lt;=5*10^5，1&lt;=a[i]&lt;=k,1&lt;=l[i]&lt;=r[i]&lt;=n.$ 题解可以很轻松的$O(1)$维护转移指针区间答案。 对询问二元组排序即可，可看以前的Post来理解带修莫队 无视500000数据 好像不带修，那就随便过了。。 还是被卡常了一个点，由于内存的catch miss太多导致同样规模的数据一个过了一个T了。。 那就这么着吧。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define _MAX 500005int n , m , t , k , c[_MAX] , v[_MAX] , ans[_MAX] , bl , curans;struct Query&#123; int l , r , id; bool operator &lt; (const Query&amp; x)const&#123; if(l/bl == x.l/bl) return r &lt; x.r; return l/bl &lt; x.l/bl; &#125;&#125;q[_MAX];inline void read(int&amp; x)&#123; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') ch = getchar(); while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = x * 10 + ch - 48 , ch = getchar(); return;&#125;inline void upd(int col , int ty)&#123; c[v[col]] += ty; if(c[v[col]] == t &amp;&amp; ty == 1) ++curans; if(c[v[col]] == t + 1 &amp;&amp; ty == 1) --curans; if(c[v[col]] == t-1 &amp;&amp; ty == -1) --curans; if(c[v[col]] == t &amp;&amp; ty == -1) ++curans;&#125;inline void solve()&#123; bl = (int)std::sqrt(n); std::sort(q+1,q+m+1); for(int i = 1 ; i &lt;= m ; ++i) q[i].r ++ ; int l = 1 , r = 1; for(int i = 1 ; i &lt;= m ; ++i) &#123; while(l &lt; q[i].l) upd(l++ , -1); while(l &gt; q[i].l) upd(--l , 1); while(r &lt; q[i].r) upd(r++ , 1); while(r &gt; q[i].r) upd(--r , -1); ans[q[i].id] = curans; &#125;&#125;int main()&#123; read(n),read(m),read(k),read(t); for(int i = 1 ; i &lt;= n ; ++i) read(v[i]); for(int i = 1 ; i &lt;= m ; ++i) read(q[i].l) , read(q[i].r) , q[i].id = i; solve(); for(int i = 1; i &lt;= m ; ++i) printf("%d\n",ans[i]);&#125; 今天就到此为止吧qwq。 明天写一道POI（FLAG）]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 32]]></title>
    <url>%2F2018%2F12%2F26%2F2018.12.26%2F</url>
    <content type="text"><![CDATA[无论如何困难，不可求人怜悯。 LOJ #6278. 数列分块入门 2题目描述给出一个长为 nn 的数列，以及 nn 个操作，操作涉及区间加法，询问区间内小于某个值 xx 的元素个数。 输入格式第一行输入一个数字 nn。 第二行输入 nn 个数字，第 ii 个数字为 a_iai，以空格隔开。 接下来输入 nn 行询问，每行输入四个数字 \mathrm{opt}opt、ll、rr、cc，以空格隔开。 若 \mathrm{opt} = 0opt=0，表示将位于 [l, r][l,r] 的之间的数字都加 cc。 若 \mathrm{opt} = 1opt=1，表示询问 [l, r][l,r] 中，小于 c^2c2 的数字的个数。 输出格式对于每次询问，输出一行一个数字表示答案。 样例样例输入12345641 2 2 30 1 3 11 1 3 21 1 4 11 2 3 2 样例输出123302 数据范围与提示对于 100\%100% 的数据，$1 \leq n \leq 50000,$ 题解想了半个小时才想出来怎么做，vector果然是好东西。 我们还是对序列分块，不过先想一想假如给你一个序列让你多次查找小于某个值的数个数有多少个，会怎么做？ 排序+二分。 想到这里就不难构思出做法了。 对每个块用一个vector维护，块内元素是值和下标（下标是为了在块值有序的情况下完成不完整块的修改）对于每次修改，完整的块打懒标记即可，不完整的的块暴力遍历下标在修改区间内的元素，将值修改后对块排序。 查询时对于不完整的块暴力遍历，对于其下标在区间里的元素判断是否符合条件并统计答案。完整的块可以二分查找统计答案。 设块大小为$S$ 这样做，修改时间复杂度是$O(n/S+2SlogS)$ 查询的复杂度是$O(n/Slogn+2S)$ 这个东西显然有比$\sqrt{n}$更优的值，就不讨论了。 值得一说的是本来思路清晰写上去感觉能一遍过的，结果全WA了，然后我又是2节课各种分析数据，定位错误位置，最终得出结论：同块查询有误。 然后我又20分钟整个数据生成器，拍了个极小数据居然错了。。 然后我一看，惊喜的发现： 以后检查不要放过任何一个语句。。。哪怕是最显然的。 不过感觉最高效的做法还是争取写的时候一遍写对，不然这种调试太。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define maxn 50005#define maxsqrt 235struct Node&#123; int v , id; bool operator &lt; (const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;;std::vector&lt;Node&gt; bl[maxsqrt];int blsize , blnum , n , tag[maxsqrt] , L[maxsqrt] , R[maxsqrt] , pos[maxn] , a[maxn] , _de;inline void pre()&#123; blsize = (int)std::pow(n,0.5); blnum = n / blsize; for(int i = 1 ; i &lt;= blnum ; ++i) L[i] = (i-1)*blsize+1 , R[i] = i*blsize; if(R[blnum] &lt; n) ++blnum , L[blnum] = R[blnum-1] + 1 , R[blnum] = n; for(int i = 1 ; i &lt;= blnum ; ++i) for(int j = L[i] ; j &lt;= R[i] ; ++j) pos[j] = i; for(int i = 1 ; i &lt;= n ; ++i) bl[pos[i]].push_back((Node)&#123;a[i],i&#125;); for(int i = 1 ; i &lt;= blnum ; ++i) std::sort(bl[i].begin(),bl[i].end());&#125;inline void update(int l , int r , int v)&#123; if(pos[l] == pos[r]) //in the same block &#123; for(int i = 0 ; i &lt; (int)bl[pos[l]].size() ;++i) if(bl[pos[l]][i].id &lt;= r &amp;&amp; bl[pos[l]][i].id &gt;= l) bl[pos[l]][i].v += v; std::sort(bl[pos[l]].begin(),bl[pos[l]].end()); return; &#125; int nl , nr; if(L[pos[l]] == l) nl = l; else nl = L[pos[l]+1]; if(R[pos[r]] == r) nr = r; else nr = R[pos[r]-1]; int pl = pos[l] , pr = pos[r]; for(int i = 0 ; i &lt; (int)bl[pl].size() ; ++i) if(bl[pl][i].id &gt;= l &amp;&amp; bl[pl][i].id &lt; nl) bl[pl][i].v += v; std::sort(bl[pl].begin() , bl[pl].end()); for(int i = 0 ; i &lt; (int)bl[pr].size() ; ++i) if(bl[pr][i].id &lt;= r &amp;&amp; bl[pr][i].id &gt; nr) bl[pr][i].v += v; std::sort(bl[pr].begin() , bl[pr].end()); if(nl &gt; nr) return; // adjancent block update for(int i = pos[nl] ; i &lt;= pos[nr] ; ++i) tag[i] += v; return ;&#125;inline int find(std::vector&lt;Node&gt;&amp; v , int key)&#123; int l = 0 , r = v.size() - 1 , ans = -1; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(v[mid].v &lt; key) ans = mid , l = mid + 1; else r = mid - 1; &#125; return ans;&#125;inline void print()&#123; puts("NOW THE ARRAY"); int tmp[maxn]; for(int i = 1 ; i &lt;= blnum ; ++i) &#123; for(int j = 0 ; j &lt; (int)bl[i].size() ; ++j) tmp[bl[i][j].id] = bl[i][j].v; for(int j = L[i] ; j &lt;= R[i] ; ++j) printf("%d ",tmp[j] + tag[i]); &#125; putchar(10);&#125;inline int query(int l , int r , int x)&#123;// printf("QUERY!!!!!%d %d %d\n",l,r,x); int ans = 0;// printf("THE BLOCK%d %d\n",pos[l],pos[r]); if(pos[l] == pos[r]) &#123; for(int i = 0 ; i &lt; (int)bl[pos[l]].size() ; ++i) &#123; int v = bl[pos[l]][i].v , id = bl[pos[l]][i].id; // printf("(%d , %d) ",v,id); // printf("SHIT!%d &lt; %d - %d &amp;&amp; %d &lt;= %d &amp;&amp; %d &gt;= %d?",v,x,tag[pos[l]],id,l,id,r); if(v &lt; x - tag[pos[l]] &amp;&amp; id &gt;= l &amp;&amp; id &lt;= r) ++ans; &#125; return ans; &#125; int nl , nr; if(L[pos[l]] == l) nl = l; else nl = L[pos[l]+1]; if(R[pos[r]] == r) nr = r; else nr = R[pos[r]-1]; int pl = pos[l] , pr = pos[r]; for(int i = 0 ; i &lt; (int)bl[pl].size() ; ++i) if(bl[pl][i].id &lt; nl &amp;&amp; bl[pl][i].id &gt;= l &amp;&amp; bl[pl][i].v &lt; x - tag[pl]) ++ans; for(int i = 0 ; i &lt; (int)bl[pr].size() ; ++i) if(bl[pr][i].id &gt; nr &amp;&amp; bl[pr][i].id &lt;= r &amp;&amp; bl[pr][i].v &lt; x - tag[pr]) ++ans;// printf("THE IMCOMPLETE BLOCK ANS: %d\n",ans);// printf("THE CBLOCK %d %d\n",nl,nr); if(nl &gt; nr) return ans; for(int i = pos[nl] ; i &lt;= pos[nr] ; ++i) ans += find(bl[i] , x-tag[i]) + 1;// printf("THE TOTAL BLOCK ANS: %d\n",ans); return ans;&#125;int main()&#123;// freopen("data.in","r",stdin);// freopen("my.out","w",stdout); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;a[i]); pre(); for(int i = 1 ; i &lt;= n ; ++i) &#123; int op , l , r , x; scanf("%d%d%d%d",&amp;op,&amp;l,&amp;r,&amp;x); if(op == 1) printf("%d\n",query(l,r,x*x)); else update(l,r,x);// printf("THE ith operation:%d\n",i);// print(); &#125;&#125; LOJ #6279. 数列分块入门 3题目描述给出一个长为 nn 的数列，以及 nn 个操作，操作涉及区间加法，询问区间内小于某个值 xx 的前驱（比其小的最大元素）。 输入格式第一行输入一个数字 nn。 第二行输入 nn 个数字，第 ii 个数字为 a_iai，以空格隔开。 接下来输入 nn 行询问，每行输入四个数字 \mathrm{opt}opt、ll、rr、cc，以空格隔开。 若 \mathrm{opt} = 0opt=0，表示将位于 [l, r][l,r] 的之间的数字都加 cc。 若 \mathrm{opt} = 1opt=1，表示询问 [l, r][l,r] 中 cc 的前驱的值（不存在则输出 -1−1）。 输出格式对于每次询问，输出一行一个数字表示答案。 样例样例输入12345641 2 2 30 1 3 11 1 4 40 1 2 21 1 2 4 样例输出123-1 数据范围与提示对于 $100\%$的数据，$1 \leq n \leq 100000, -2^{31} \leq \mathrm{others} \leq 2^{31}$ 题解这道题，大概算是我写的最失败的一道题了吧。。 虽然和上面那道题几乎一模一样，主要是用vector+根号平衡来维护值单调从而实现二分查找等操作。 但是。。。我写的时候出了无数的bug，我顺便一一截图展示下。。 这里原来没有加1.。。 要想清楚变量的含义，别打的太快不过脑子。。 无话可说.jpg 最后一个错误，在最终的对拍后好不容易锁定了错误的位置。显然预处理的时候就得保证其块内有序。】 时间复杂度懒得写了，其实和上面一样，又其实所有这类平衡思想的题都可以类似的分析。 慢慢提高自己一边写对复杂代码的能力和调试的能力，确保自己在有思路的情况下不丢分，这非常重要。 上一下因调试代码导致无限长的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define _max 100005#define _maxsqrt 320int n , m , L[_maxsqrt] , R[_maxsqrt] , pos[_max] , blsize , blnum , a[_max] , tag[_max];struct Node&#123; int v , id; bool operator &lt; (const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;;std::vector&lt;Node&gt; bl[_maxsqrt];inline void print(int l , int r)&#123; puts("ARRAY"); static int tmp[_max]; for(int i = 1 ; i &lt;= blnum ; ++i) &#123; for(int j = 0 ; j &lt; (int)bl[i].size() ; ++j) tmp[bl[i][j].id] = bl[i][j].v; &#125; for(int i = l ; i &lt;= r ; ++i) printf("%d ",tmp[i] + tag[pos[i]]); puts("");&#125;inline void pre()&#123; blsize = (int)std::pow(n,0.5); blnum = n / blsize; for(int i = 1 ; i &lt;= blnum ; ++i) L[i] = (i-1)*blsize+1 , R[i] = i*blsize; if(R[blnum] &lt; n) ++blnum , L[blnum] = R[blnum-1]+1 , R[blnum] = n; for(int i = 1 ; i &lt;= blnum ; ++i) for(int j = L[i] ; j &lt;= R[i] ; ++j) pos[j] = i , bl[i].push_back((Node)&#123;a[j],j&#125;); for(int i = 1 ; i &lt;= blnum ; ++i) std::sort(bl[i].begin() , bl[i].end());// puts("PRE THE BLOCK INFO");// for(int i = 1 ; i &lt;= blnum ; ++i)// printf("%d %d\n",L[i],R[i]);&#125;inline void update(int l , int r , int v)&#123; if(pos[l] == pos[r]) &#123; for(int i = 0 ; i &lt; (int)bl[pos[l]].size() ; ++i) &#123; int id = bl[pos[l]][i].id; if(id &gt;= l &amp;&amp; id &lt;= r) bl[pos[l]][i].v += v; &#125; std::sort(bl[pos[l]].begin() , bl[pos[l]].end()); return ; &#125; int nl , nr; if(L[pos[l]] == l) nl = l; else nl = L[pos[l]+1]; if(R[pos[r]] == r) nr = r; else nr = R[pos[r]-1]; for(int i = 0 ; i &lt; (int)bl[pos[l]].size() ; ++i) &#123; int id = bl[pos[l]][i].id; if(id &lt; nl &amp;&amp; id &gt;= l) bl[pos[l]][i].v += v; &#125; std::sort(bl[pos[l]].begin() , bl[pos[l]].end()); for(int i = 0 ; i &lt; (int)bl[pos[r]].size() ; ++i) &#123; int id = bl[pos[r]][i].id; if(id &gt; nr &amp;&amp; id &lt;= r) bl[pos[r]][i].v += v; &#125; std::sort(bl[pos[r]].begin() , bl[pos[r]].end()); if(nl &gt; nr) return; for(int i = pos[nl] ; i &lt;= pos[nr] ; ++i) tag[i] += v; return ;&#125;inline int find(std::vector&lt;Node&gt;&amp; vec , int key)&#123; int l = 0 , r = (int)vec.size() - 1 , ans = -0x7fffffff; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(vec[mid].v &lt; key) ans = vec[mid].v , l = mid + 1; else r = mid - 1; &#125; return ans;&#125;inline int query(int l , int r , int val)&#123;// printf("QUERY %d %d %d\n",l,r,val);// print(l,r); int ans = -0x7fffffff; if(pos[l] == pos[r]) &#123;// puts("THE QUERY SAME BLOCK!"); for(int i = 0 ; i &lt; (int)bl[pos[l]].size() ; ++i) &#123; int id = bl[pos[l]][i].id , v = bl[pos[l]][i].v; if(id &gt;= l &amp;&amp; id &lt;= r &amp;&amp; v &lt; val - tag[pos[l]]) ans = std::max(ans , v + tag[pos[l]]); &#125; return ans; &#125; int nl , nr; if(L[pos[l]] == l) nl = l; else nl = L[pos[l]+1]; if(R[pos[r]] == r) nr = r; else nr = R[pos[r]-1];// if(l == 1 &amp;&amp; r == 5 &amp;&amp; val == 9)&#123;// printf("\n\nSPECIAL : %d %d\n\n",nl,nr);// &#125; for(int i = 0 ; i &lt; (int)bl[pos[l]].size() ; ++i) &#123; int id = bl[pos[l]][i].id , v = bl[pos[l]][i].v; if(id &lt; nl &amp;&amp; id &gt;= l &amp;&amp; v &lt; val - tag[pos[l]]) ans = std::max(ans , v + tag[pos[l]]); &#125;// if(l == 1 &amp;&amp; r == 5 &amp;&amp; val == 9)&#123;// printf("\n\nSPECIAL : %d\n\n",ans);// &#125; for(int i = 0 ; i &lt; (int)bl[pos[r]].size() ; ++i) &#123; int id = bl[pos[r]][i].id , v = bl[pos[r]][i].v; if(id &gt; nr &amp;&amp; id &lt;= r &amp;&amp; v &lt; val - tag[pos[r]]) ans = std::max(ans , v + tag[pos[r]]); &#125;// if(l == 1 &amp;&amp; r == 5 &amp;&amp; val == 9)&#123;// printf("\n\nSPECIAL : %d\n\n",ans);// &#125; if(nl &gt; nr) return ans; for(int i = pos[nl] ; i &lt;= pos[nr] ; ++i) &#123; int k = find(bl[i] , val-tag[i]);// if(l == 1 &amp;&amp; r == 5 &amp;&amp; val == 9)&#123;// puts("SPECIAL ARRAY");// for(int j = 0 ; j &lt; (int)bl[i].size() ; ++j)// printf("%d ",bl[i][j].v);// puts("");// printf("SPECIAL THE BLOCK: %d ans: %d\n",i,k);// &#125; if(k == -0x7fffffff) continue; ans = std::max(ans , k + tag[i]); &#125; return ans;&#125;int main()&#123;// freopen("data.in","r",stdin);// freopen("my.out","w",stdout); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;a[i]); pre(); for(int i = 1 ; i &lt;= n ; ++i) &#123; int op , l , r , v; scanf("%d%d%d%d",&amp;op,&amp;l,&amp;r,&amp;v); if(op &amp; 1)&#123; int now = query(l,r,v); printf("%d\n",now &lt;=-0x6fffffff?-1:now); &#125; else update(l,r,v); &#125;&#125; P3939 数颜色题目背景大样例下发链接：http://pan.baidu.com/s/1c0LbQ2 密码：jigg 题目描述小 C 的兔子不是雪白的，而是五彩缤纷的。每只兔子都有一种颜色，不同的兔子可能有 相同的颜色。小 C 把她标号从 1 到 nn 的 nn 只兔子排成长长的一排，来给他们喂胡萝卜吃。 排列完成后，第 ii 只兔子的颜色是 a_iai。 俗话说得好，“萝卜青菜，各有所爱”。小 C 发现，不同颜色的兔子可能有对胡萝卜的 不同偏好。比如，银色的兔子最喜欢吃金色的胡萝卜，金色的兔子更喜欢吃胡萝卜叶子，而 绿色的兔子却喜欢吃酸一点的胡萝卜……为了满足兔子们的要求，小 C 十分苦恼。所以，为 了使得胡萝卜喂得更加准确，小 C 想知道在区间 [l_j,r_j][lj,rj] 里有多少只颜色为 c_jcj 的兔子。 不过，因为小 C 的兔子们都十分地活跃，它们不是很愿意待在一个固定的位置；与此同 时，小 C 也在根据她知道的信息来给兔子们调整位置。所以，有时编号为 x_jxj 和 x_j+1xj+1 的两 只兔子会交换位置。 小 C 被这一系列麻烦事给难住了。你能帮帮她吗？ 输入输出格式输入格式： 从标准输入中读入数据。 输入第 1 行两个正整数 nn,mm。 输入第 2 行 nn 个正整数，第 ii 个数表示第 ii 只兔子的颜色 a_iai。 输入接下来 mm 行，每行为以下两种中的一种： “1\ l_j\ r_j\ c_j1 lj rj cj” ：询问在区间 [l_j,r_j][lj,rj] 里有多少只颜色为 c_jcj 的兔子； “2\ x_j2 xj”： x_jxj 和 x_j+1xj+1 两只兔子交换了位置。 输出格式： 输出到标准输出中。 对于每个 1 操作，输出一行一个正整数，表示你对于这个询问的答案。 输入输出样例输入样例#1： 复制 12345676 5 1 2 3 2 3 3 1 1 3 2 1 4 6 3 2 3 1 1 3 2 1 4 6 3 输出样例#1： 复制 12341 2 2 3 说明【样例 1 说明】 前两个 1 操作和后两个 1 操作对应相同；在第三次的 2 操作后，3 号兔子和 4 号兔子 交换了位置，序列变为 1 2 2 3 3 3。 【数据范围与约定】 子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。 对于所有测试点，有 1 \le l_j &lt; r_j \le n,1 \le x_j &lt; n1≤lj&lt;rj≤n,1≤xj&lt;n。 每个测试点的数据规模及特点如下表： 特殊性质 1：保证对于所有操作 1，有 |r_j - l_j| \le 20∣rj−lj∣≤20 或 |r_j - l_j| \le n - 20∣rj−lj∣≤n−20。 特殊性质 2：保证不会有两只相同颜色的兔子。 题解这题似乎很容易就想到套路，搞不懂为啥有人非说这是思维题。 其实这道题让我练会了vector。。也不算练会，主要是知道vector引用怎么在函数里用和不能重赋值 还有vector指针调用各种东西得(*v)这样。。 说说这道题思路，把每种颜色的兔子开vector存位置（以前我第一次接触到这种思路也感觉：妙，,妙啊！，现在就觉得其实也不是很难想，主要是利用它只查询一个颜色的兔子这一点，总之就是抓住题目特点进行分析啦），然后位置单调不减。 所以我们每次查询二分小于，更新也二分就没了 然后vector的指针需要加括号！！ Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define maxn 300005std::vector&lt;int&gt; c[maxn];int n , m , p[maxn];inline void print(const std::vector&lt;int&gt;&amp; v)&#123; puts("THE ARRAY"); printf("size: %d\n",v.size()); for(int i = 0 ; i &lt; (int)v.size(); ++i) printf("%d ",v[i]); puts("");&#125;inline int calc(const std::vector&lt;int&gt;&amp; v , int ql , int qr)&#123; int l = 0 , r = (int)v.size() - 1 , ans1 = 0 , ans2 = 0; if(!v.size()) return 0; if(v[r] &lt; ql || v[l] &gt; qr) return 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(v[mid] &lt;= qr) ans1 = mid , l = mid + 1; else r = mid - 1; &#125; l = 0 , r = (int)v.size() - 1; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(v[mid] &gt;= ql) ans2 = mid , r = mid - 1; else l = mid + 1; &#125; return ans1 - ans2 + 1;&#125;inline void update(int pos)&#123; if(p[pos] == p[pos+1]) return ; int c1 = p[pos] , c2 = p[pos+1]; std::swap(p[pos],p[pos+1]); std::vector&lt;int&gt;&amp; v = c[c1]; int l = 0 , r = (int)v.size() - 1 , ans = 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(v[mid] &lt;= pos) ans = mid , l = mid + 1; else r = mid - 1; &#125; v[ans] = pos + 1; std::vector&lt;int&gt;&amp; vec = c[c2]; l = 0 , r = (int)vec.size() - 1 , ans = 0 ; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(vec[mid] &lt;= pos + 1) ans = mid , l = mid + 1; else r = mid - 1; &#125; vec[ans] = pos;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) &#123; int x; scanf("%d",&amp;x); p[i] = x; c[x].push_back(i); &#125; for(int i = 1 ; i&lt;= m ; ++i) &#123; int op , l , r , k; scanf("%d",&amp;op); if(op == 1) &#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;k); printf("%d\n",calc(c[k],l,r)); &#125; else &#123; scanf("%d",&amp;k); update(k); &#125; &#125;&#125; 这种难度的还是随便切的。 关于vector 123456789101112131415#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define maxn 100004std::vector&lt;int&gt; g[maxn];int main()&#123; g[2].push_back(2),g[2].push_back(3); std::vector&lt;int&gt;* v = &amp;g[2]; v -&gt; operator[](2); (*v).push_back(23); std::cout&lt;&lt;g[2][0];&#125; 不过还是不要用-&gt;了，也不浪费时间去研究那个东西了 今天就到此为止，听会歌再说]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 31]]></title>
    <url>%2F2018%2F12%2F25%2F2018.12.25%2F</url>
    <content type="text"><![CDATA[人们说当你遇上你的挚爱时，时间会暂停。真的是这样。但人们没有告诉你，当时针再度恢复转动，它会无比飞快，让人无法赶上。 [2009国家集训队]小Z的袜子(hose)Description作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。 Input输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。 Output包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例） Sample Input6 4 1 2 3 3 3 2 2 6 1 3 3 5 1 6 Sample Output2/5 0/1 1/1 4/15 【数据规模和约定】 $100\%$的数据中 $N,M ≤ 50000，1 ≤ L &lt; R ≤ N，Ci ≤ N$。 题解又是一个很裸的莫队，做完这道就开始练习带修莫队啦（HH的项链，[C. color][http://noi.ac/contest/15/problem/44]等等） 这道题只需要说下$O(1)$修改（其他好像很模板，怪不得很多人都背板子），对于每个加入的颜色。 对$curans$的贡献：$2c(v(x))$ 但是减少一个的贡献可不是把它反过来，一定要自己推一下是：$-2c(v(x))+2$ 然后就没有然后了，以后莫队都写左闭右开了。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 50005int n , m , c[maxn] , bl , v[maxn];long long ans[maxn] , tot[maxn] , curans;struct node&#123; int l , r , id; bool operator&lt;(const node&amp; x)const&#123; if(l/bl == x.l/bl) return r &lt; x.r; return l/bl &lt; x.l/bl; &#125;&#125;q[maxn];inline void update(int col , int ty)&#123; if(ty == 1) curans += 2*c[v[col]]; else curans += 2 - 2 * c[v[col]]; c[v[col]] += ty;&#125;inline void solve()&#123; bl = (int)std::pow(n,0.67); std::sort(q+1,q+m+1); for(int i = 1 ; i &lt;= m ; ++i) q[i].r ++; int l = 1 , r = 1; for(int i = 1 ; i &lt;= m ; ++i) &#123; while(l &gt; q[i].l) update(--l, 1); while(r &lt; q[i].r) update(r++ , 1); while(l &lt; q[i].l) update(l++ , -1); while(r &gt; q[i].r) update(--r , -1); ans[q[i].id] = curans , tot[q[i].id] = 1ll * (q[i].r - q[i].l) * (q[i].r-q[i].l-1); &#125;&#125;int gcd(long long x , long long y)&#123; if(!y) return x; return gcd(y , x % y);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d",&amp;q[i].l,&amp;q[i].r) , q[i].id = i; solve(); for(int i = 1 ; i &lt;= m ; ++i) &#123; if(ans[i] == 0) puts("0/1"); else printf("%lld/%lld\n",ans[i]/gcd(ans[i],tot[i]) , tot[i]/gcd(ans[i],tot[i])); &#125;&#125; [国家集训队]数颜色 / 维护队列题目描述墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令： 1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。 2、 R P Col 把第P支画笔替换为颜色Col。 为了满足墨墨的要求，你知道你需要干什么了吗？ 输入输出格式输入格式： 第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。 第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。 第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。 输出格式： 对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。 输入输出样例输入样例#1： 12345676 51 2 3 4 5 5Q 1 4Q 2 6R 1 2Q 1 4Q 2 6 输出样例#1： 12344434 说明对于$100\%$的数据，$N≤50000，M≤50000$，所有的输入数据中出现的所有整数均大于等于1且不超过$10^6$。 题解调出第一道带修莫队。 话说有个滑稽的错误让我正好一眼看出来了，然后就过了，如下： 原来的时候我把这两个写反了可还行。。。 然后就很简单了，显然理解这个算法后基本上都是一样的东西了。 虽然号称解决一切序列问题，但是带修莫队真！的！很！慢！ 我们在之前已经推导过带修莫队的各种理论了，最优块大小是$n^{\frac{2}{3}}$ 但是据说小一点会更快。。 我们按照三元组排序然后暴力就行了。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 50005#define maxv 1000005int n, m , c[maxn] , tot1 , tot2 , ans[maxn] , b[maxv] , bl , curans , tmp[maxv];struct Query&#123; int l , r , t, id; bool operator &lt; (const Query&amp; x)const&#123; if(l/bl == x.l/bl &amp;&amp; r/bl == x.r/bl) return t &lt; x.t; if(l/bl == x.l/bl) return r/bl &lt; x.r/bl; return l/bl &lt; x.l/bl; &#125;&#125;q[maxn];struct Modify&#123; int p , v , bef;&#125;p[maxn];inline void update(int p , int ty)&#123; if(ty == 1) &#123; b[c[p]] ++ ; if(b[c[p]] == 1) ++curans; &#125; if(ty == -1) &#123; b[c[p]] -- ; if(!b[c[p]]) --curans; &#125;&#125;inline void updTime(int tim , int ty , int l , int r)&#123; int pos = p[tim].p; if(ty == 1) &#123; int k = c[pos]; c[pos] = p[tim].v; if(pos &gt;= l &amp;&amp; pos &lt; r) &#123; b[c[pos]] ++ ; if(b[c[pos]] == 1) ++curans; b[k] --; if(!b[k]) --curans; &#125; &#125; else &#123; int k = c[pos]; c[pos] = p[tim].bef; if(pos &gt;= l &amp;&amp; pos &lt; r) &#123; b[c[pos]] ++; if(b[c[pos]] == 1) ++curans; b[k] --; if(!b[k]) --curans; &#125; &#125; &#125;inline void print(int l , int r , int op)&#123; if(op == 1) &#123; puts("ARRAY:"); for(int i = l ; i &lt;= r ; ++i) printf("(%d,%d) ",c[i],b[c[i]]); puts(""); &#125; printf("l:%d r:%d CURANS : %d\n",l,r,curans);&#125;inline void solve()&#123; bl = (int)std::pow(n , 0.67); std::sort(q+1,q+tot1+1); int l = 1 , r = 1 , t = 0; for(int i = 1 ; i &lt;= tot1 ; ++i) ++ q[i].r; for(int i = 1 ; i &lt;= tot1 ; ++i) &#123;// printf("THE %d query started : %d %d %d\n",q[i].id ,q[i].l,q[i].r,q[i].t); while(t &lt; q[i].t) updTime(++t,1,l,r) ;//, print(q[i].l,q[i].r,1); while(t &gt; q[i].t) updTime(t--,-1,l,r) ;//, print(q[i].l,q[i].r,1); while(l &lt; q[i].l) update(l++ , -1); //, print(l,r,0); while(l &gt; q[i].l) update(--l , 1); //, print(l,r,0); while(r &lt; q[i].r) update(r++ , 1) ;//, print(l,r,0); while(r &gt; q[i].r) update(--r , -1); //, print(l,r,0);// printf("THE %d query %d %d finished\n",q[i].id,l,r); ans[q[i].id] = curans; &#125;&#125;inline void pre()&#123; for(int i = 1 ; i &lt;= n ; ++i) tmp[i] = c[i]; for(int i = 1 ; i &lt;= tot2 ; ++i) &#123; int pos = p[i].p; p[i].bef = tmp[pos]; tmp[pos] = p[i].v; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;c[i]); for(int i = 1 ; i &lt;= m ; ++i) &#123; char op; scanf("\n%c",&amp;op); if(op == 'Q') ++tot1 , scanf("%d%d",&amp;q[tot1].l,&amp;q[tot1].r) , q[tot1].id = tot1 , q[tot1].t = tot2; else if(op == 'R') ++tot2 , scanf("%d%d",&amp;p[tot2].p,&amp;p[tot2].v); &#125; pre(); solve(); for(int i = 1 ; i &lt;= tot1 ; ++i) printf("%d\n",ans[i]);&#125; 今天莫队就做到这里吧，看道POI思维题。 [POI2005]DWU-Double-rowDescription2n 个士兵站成两排. 他们必须重新排列使得任意一排都没有两个相同高度的士兵. 只可以进行一种操作即交换一列中的两个士兵. 你的任务是确定最少要进行多少次操作才能达到要求. Example: 图中所示的是18 个士兵站成了2排. 按图中的方式进行操作. Input第一行一个数n, 1 &lt;= n &lt;= 50 000. 接下来两行每行n个数表示对应列的士兵的高度x1, x2,…, xn, 1 &lt;= xi &lt;= 100 000; y1, y2,…, yn, 1 &lt;= y &lt;= i100 000. 数据保证一定存在一组方案使得可以达到目标. Output一行输出一个数字表示最少操作数. 题解太失败了，最后也只得到了40分。。 确实联想到了二分图，但是考虑的情况不够全面。 我是这么想的，假如我们把上下都是有同行重复的元素连边，然后求每个联通块size，然后统计答案。 这样显然是错误的，因为有可能把本来相同的不在同一行的给交换过来然后就错了，所以答案会比实际答案更优。 所以我们应该这么建二分图：还是只考虑相同元素，不过相同元素在同一行的话向另一行对应下标的元素连边权为1的边，在不同的行连边权为0的边，对每个联通块（必定二分图）BFS，每次过边权为1的边需要换颜色，边权为0的不换颜色，这样就让不同行的要么同时换要么同时不换，就正确了。 恩就这样，不想Code. #1468. TreeDescription给你一棵TREE,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于K InputN（n&lt;=40000） 接下来n-1行边描述管道，按照题目中写的输入 接下来是k Output一行，有多少对点之间的距离小于等于k Sample Input7 1 6 13 6 3 9 3 5 7 4 1 3 2 4 20 4 7 2 10 Sample Output5 题解这题挺好写啊。。。简单容斥原理就行了，不知道进阶指南上的扫描数组是个什么鬼。。。 还是自己想的写的好。 思路的话在我的Post 26中写了，所以我还是要复制一遍233 假如了解过点分治不难想到做法。 对于这种统计路径并且对于一个点p能分治成过p和不过p的，可以很容易联想到点分治做法。 求出当前树的重心 dfs求出每个点到当前重心的距离，排序后用双指针扫描统计，注意容斥，把重心每个子树在这样做一遍即可 递归每个子树重心（注意，如果递归的点已经被访问，代表已经被处理，返回即可。） 整个做法的时间复杂度是$O(nlog^2n)$ 第二步的容斥网上都讲的繁琐玄学。。。然后我就想到这个方法，可能慢一点但很好理解，就代表去掉相同子树里的点对（不属于简单路径）。 还有就是为什么递归重心最多只需要$logn$次，给出证明： 这个命题等价于将重心删除后，最大联通块小于等于树大小的一半，这里我们可以反证。 如果最大联通块的大小超过一半，那么其它的加起来小于一半，此时重心取那个最大联通块与当前重心相连的点时比当前重心优，即当前重心不满足重心定义，与初始条件矛盾。所以 最大联通块小于等于树大小的一半。 然后就没什么了。 考虑点分治奇多无比的细节与今天阴暗的内心世界，我决定咕掉代码。 然后现在补上了代码，调试代码见证我的努力 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#define maxn 100005#define LL long longint n , k , root , now , ct , sz[maxn] , d[maxn] , ans;struct Node&#123; int x , v;&#125;;std::vector&lt;Node&gt; g[maxn];void getroot(int x , int fx)&#123; int maxx = 0x7fffffff; sz[x] = 1; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i].x; if(v == fx) continue; getroot(v , x); sz[x] += sz[v]; maxx = std::max(maxx , sz[v]); &#125; maxx = std::max(maxx , n - sz[x]); if(maxx &lt; now) &#123; now = maxx; root = x; &#125;&#125;void getDis(int x , int fx , int dis)&#123; d[++ct] = dis; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i].x; if(v == fx) continue; getDis(v , x , dis + g[x][i].v); &#125;&#125;inline void calc(int rt , int fx)&#123;// printf("NOW THE ROOT:%d Father:%d\n",rt,fx); ct = 0; getDis(rt , fx , 0); std::sort(d+1,d+ct+1);// puts("THE TREE PRESUM");// for(int i = 1 ; i &lt;= ct ; ++i)// printf("%d ",d[i]);// puts(""); // int t = ans; int l = 1 , r = ct; while(l &lt; r) &#123; while(d[l] + d[r] &gt; k) --r; if(l &gt;= r) break; ans += r - l ; ++l; &#125;// printf("THE CONBINATE WHICH NOT UNIQUE : %d\n", ans-t); for(int i = 0 ; i &lt; (int)g[rt].size() ; ++i) &#123;// int t = ans; int v = g[rt][i].x; if(v == fx) continue; ct = 0; getDis(v , rt , g[rt][i].v); std::sort(d+1,d+ct+1);// puts("UNIQUE FROM SUBTREE");// for(int j = 1 ; j &lt;= ct ; ++j)// printf("%d ",d[j]);// puts(""); int l = 1, r = ct; while(l &lt; r) &#123; while(d[l] + d[r] &gt; k) --r; if(l &gt;= r) break; ans -= r - l ; ++l; &#125;// printf("THE ILLEGAL FROM SON:%d is:%d\n",v,t-ans); &#125;&#125; void TreeDC(int rt , int fx)&#123; calc(rt , fx); for(int i = 0 ; i &lt; (int)g[rt].size() ; ++i) &#123; int v = g[rt][i].x; if(v == fx) continue; getroot(v , rt); TreeDC(v , rt); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt; n ; ++i) &#123; int x , y , d; scanf("%d%d%d",&amp;x,&amp;y,&amp;d); g[x].push_back((Node)&#123;y,d&#125;); g[y].push_back((Node)&#123;x,d&#125;); &#125; scanf("%d",&amp;k); TreeDC(1,1); printf("%d\n",ans);&#125;]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 30]]></title>
    <url>%2F2018%2F12%2F24%2F2018.12.24%2F</url>
    <content type="text"><![CDATA[[USACO07MAR]牛交通Cow Traffic题目描述The bovine population boom down on the farm has caused serious congestion on the cow trails leading to the barn. Farmer John has decided to conduct a study to find the bottlenecks in order to relieve the ‘traffic jams’ at milking time. The pasture contains a network of M (1 ≤ M ≤ 50,000) one-way trails, each of which connects exactly two different intersections from the set of N (1 ≤ N ≤ 5,000) intersections conveniently numbered 1..N; the barn is at intersection number N. Each trail connects one intersection point to another intersection point with a higher number. As a result, there are no cycles and, as they say on the farm, all trails lead to the barn. A pair of intersection points might be connected by more than one trail. During milking time rush hour, the cows start from their respective grazing locations and head to the barn. The grazing locations are exactly those intersection points with no trails connecting into them. Each cow traverses a ‘path’, which is defined as a sequence of trails from a grazing location to the barn. Help FJ finding the busiest trail(s) by computing the largest number of possible paths that contain any one trail. The answer is guaranteed to fit in a signed 32-bit integer. 输入输出格式输入格式： Line 1: Two space-separated integers: N and M. Lines 2..M+1: Two space-separated intersection points. 输出格式： Line 1: The maximum number of paths passing through any one trail. 输入输出样例输入样例#1： 123456787 71 33 43 54 62 35 66 7 输出样例#1： 14 说明Here are the four possible paths that lead to the barn: 1 3 4 6 7 1 3 5 6 7 2 3 4 6 7 2 3 5 6 7 题解做出这道题的关键在于不要被luogu的沙雕翻译影响，自己读一遍英文题面。 这道题的意思是问你对于一条边的价值定义为被包含在从入度为0的点到n的路径中的数量，求这个最大价值。 这种边的问题显然尽可能转化成关于点的问题比较好求，比如说这道题：[HAOI2012]道路 他们都通过巧妙的组合原理把对边统计转化成了对点统计。 显然这题简单的多，对于一条边就是到边起点的数量乘上到终点的数量。 （又去看了看道路那道题感觉还是挺难） Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define maxn 100005int n , m , d1[maxn] , d2[maxn] , fr[maxn] , to[maxn] , f[maxn] , w[maxn];std::vector&lt;int&gt; g[maxn] , r[maxn];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= m ; ++i) &#123; scanf("%d%d",&amp;fr[i],&amp;to[i]); g[fr[i]].push_back(to[i]); ++d1[to[i]]; r[to[i]].push_back(fr[i]); ++d2[fr[i]]; &#125; std::queue&lt;int&gt; q; for(int i = 1 ; i &lt;= n ; ++i) if(!d1[i]) q.push(i) , f[i] = 1; for( ; q.size() ; q.pop()) &#123; int k = q.front(); for(int i = 0 ; i &lt; (int)g[k].size() ; ++i) &#123; int v = g[k][i]; f[v] += f[k]; if(!(--d1[v])) q.push(v); &#125; &#125; while(!q.empty()) q.pop(); for(int i = 1 ; i &lt;= n ; ++i) if(!d2[i]) q.push(i) , w[i] = 1; for( ; q.size() ; q.pop()) &#123; int k = q.front(); for(int i = 0 ; i &lt; (int) r[k].size() ; ++i) &#123; int v = r[k][i]; w[v] += w[k]; if(!(--d2[v])) q.push(v); &#125; &#125; long long ans = -0x7fffffff; for(int i = 1 ; i &lt;= m ; ++i) ans = std::max(ans , 1ll * f[fr[i]] * w[to[i]]); printf("%lld\n",ans);&#125; [POI2005]AUT-The Bus题目描述The streets of Byte City form a regular, chessboardlike network - they are either north-south or west-east directed. We shall call them NS- and WE-streets. Furthermore, each street crosses the whole city. Every NS-street intersects every WE- one and vice versa. The NS-streets are numbered from 11 to nn, starting from the westernmost. The WE-streets are numbered from 11 to mm, beginning with the southernmost. Each intersection of the ii’th NS-street with the jj’th WE-street is denoted by a pair of numbers (i,j)(i,j) (for 1\le i\le n1≤i≤n, 1\le j\le m1≤j≤m). There is a bus line in Byte City, with intersections serving as bus stops. The bus begins its itinerary by the (1,1)(1,1)intersection, and finishes by the (n,m)(n,m) intersection. Moreover, the bus may only travel in the eastern and/or northern direction. There are passengers awaiting the bus by some of the intersections. The bus driver wants to choose his route in a way that allows him to take as many of them as possible. (We shall make an assumption that the interior of the bus is spacious enough to take all of the awaiting passengers, regardless of the route chosen.)TaskWrite a programme which: reads from the standard input a description of the road network and the number of passengers waiting at each intersection,finds, how many passengers the bus can take at the most,writes the outcome to the standard output. Byte City 的街道形成了一个标准的棋盘网络 – 他们要么是北南走向要么就是西东走向. 北南走向的路口从 1 到 n编号, 西东走向的路从1 到 m编号. 每个路口用两个数(i, j) 表示(1 &lt;= i &lt;= n, 1 &lt;= j &lt;= m). Byte City里有一条公交线, 在某一些路口设置了公交站点. 公交车从 (1, 1) 发车, 在(n, m)结束.公交车只能往北或往东走. 现在有一些乘客在某些站点等车. 公交车司机希望在路线中能接到尽量多的乘客.帮他想想怎么才能接到最多的乘客. 输入输出格式输入格式： The first line of the standard input contains three positive integers nn, mm and kk - denoting the number of NS-streets, the number of WE-streets and the number of intersections by which the passengers await the bus, respectively (1\le n\le 10^91≤n≤109, 1\le m\le 10^91≤m≤109, 1\le k\le 10^51≤k≤105). The following kk lines describe the deployment of passengers awaiting the bus, a single line per intersection. In the (i+1)(i+1)’st line there are three positive integers x_ixi, y_iyi and p_ipi, separated by single spaces, 1\le x_i\le n1≤xi≤n,1\le y_i\le m1≤yi≤m,1\le p_i\le 10^61≤pi≤106 . A triplet of this form signifies that by the intersection(x_i,y_i)p_i(xi,yi)pi passengers await the bus. Each intersection is described in the input data once at the most. The total number of passengers waiting for the bus does not exceed 1\ 000\ 000\ 0001 000 000 000. 输出格式： Your programme should write to the standard output one line containing a single integer - the greatest number of passengers the bus can take. 输入输出样例输入样例#1： 1234567891011128 7 114 3 46 2 42 3 25 6 12 5 21 5 52 1 13 1 17 7 17 4 28 6 2 输出样例#1： 111 题解很水的二维偏序。 这告诉我们闲着没事画图。 想到二维偏序是因为扫描线的思想。 恩，所以问题就变成了一个带权的LIS（我一开始没看到带权，打了个贪心美滋滋） 然后我们可以用长时间的经验套路出一个dp状态：设$f_i$为以$i$为结尾的前$i$个的最大值（我一直觉得这个状态相当套路，不过非常正确233） $f_i = max\{f_j\}+v_j $ $x_j \leq x_i , y_j \leq y_i $ 然后我们用线段树优化转移就可以以$O(klogk)$的复杂度通过本题。 话说sb洛谷数据都写错，明明比1e5要大，害我浪费了几分钟。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005struct Node&#123; int x , y , v; bool operator&lt;(const Node&amp; t)const&#123; if(x == t.x) return y &lt; t.y; return x &lt; t.x; &#125; &#125;p[maxn];int n , pos , a ,r , seg[maxn] , tot , h[maxn] , v[maxn] , f[maxn];inline void update(int p , int v)&#123; p += pos; seg[p] = std::max(seg[p] , v); for(p &gt;&gt;= 1 ; p ; p &gt;&gt;= 1) seg[p] = std::max(seg[p&lt;&lt;1] , seg[p&lt;&lt;1|1]);&#125;inline int query(int l , int r)&#123; int ans = 0; for(l = l + pos - 1 , r = r + pos + 1 ; l ^ r ^ 1 ; l &gt;&gt;= 1 , r &gt;&gt;= 1) &#123; if(~l&amp;1) ans = std::max(ans , seg[l^1]); if(r&amp;1) ans = std::max(ans , seg[r^1]); &#125; return ans;&#125;struct Data&#123; int v , k; bool operator&lt;(const Data&amp; x)const&#123; return v &lt; x.v; &#125;&#125;t[maxn];int main()&#123; scanf("%d%d%d",&amp;a,&amp;r,&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d%d",&amp;p[i].x,&amp;p[i].y,&amp;p[i].v); std::sort(p+1,p+n+1); for(int i = 1 ; i &lt;= n ; ++i) t[i].v = p[i].y , t[i].k = i; std::sort(t+1,t+n+1);// t[0].v = 3154651; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(t[i].v == t[i-1].v) h[t[i].k] = tot; else h[t[i].k] = ++tot; &#125; for(int i = 1 ; i &lt;= n ; ++i) v[i] = p[i].v; for(pos = 1 ; pos &lt; tot ; pos &lt;&lt;= 1); int ans = -0x7ffffff; for(int i = 1 ; i &lt;= n ; ++i) &#123; f[i] = query(1,h[i]) + v[i]; ans = std::max(ans , f[i]); update(h[i] , f[i]); &#125; printf("%d\n",ans);&#125; CF86D Powerful array题意翻译题意：给出一个n个数组成的数列a，有t次询问，每次询问为一个[l,r]的区间，求区间内每种数字出现次数的平方×数字的值 的和。 输入：第一行2个正整数n,t。 接下来一行n个正整数，表示数列a_1a1~a_nan的值。 接下来t行，每行两个正整数l,r，为一次询问。 输出：t行，分别为每次询问的答案。 数据范围：1 \leq n,t \leq 2*10^5,1 \leq a_i \leq 10^6,1 \leq l,r \leq n1≤n,t≤2∗105,1≤ai≤106,1≤l,r≤n 题目描述An array of positive integers a_{1},a_{2},…,a_{n}a1,a2,…,an is given. Let us consider its arbitrary subarray a_{l},a_{l+1}…,a_{r}al,al+1…,ar , where 1&lt;=l&lt;=r&lt;=n1&lt;=l&lt;=r&lt;=n . For every positive integer ss denote by K_{s}Ks the number of occurrences of ss into the subarray. We call the power of the subarray the sum of products K_{s}·K_{s}·sKs⋅Ks⋅s for every positive integer ss . The sum contains only finite number of nonzero summands as the number of different values in the array is indeed finite. You should calculate the power of tt given subarrays. 输入输出格式输入格式： First line contains two integers nn and tt ( 1&lt;=n,t&lt;=2000001&lt;=n,t&lt;=200000 ) — the array length and the number of queries correspondingly. Second line contains nn positive integers a_{i}ai ( 1&lt;=a_{i}&lt;=10^{6}1&lt;=ai&lt;=106 ) — the elements of the array. Next tt lines contain two positive integers ll , rr ( 1&lt;=l&lt;=r&lt;=n1&lt;=l&lt;=r&lt;=n ) each — the indices of the left and the right ends of the corresponding subarray. 输出格式： Output tt lines, the ii -th line of the output should contain single positive integer — the power of the ii -th query subarray. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preferred to use cout stream (also you may use %I64d). 输入输出样例输入样例#1： 12343 21 2 11 21 3 输出样例#1： 复制 1236 输入样例#2： 123458 31 1 2 2 1 3 1 12 71 62 7 输出样例#2： 123202020 说明Consider the following array (see the second sample) and its [2, 7] subarray (elements of the subarray are colored): Then K_{1}=3K1=3 , K_{2}=2K2=2 , K_{3}=1K3=1 , so the power is equal to 3^{2}·1+2^{2}·2+1^{2}·3=2032⋅1+22⋅2+12⋅3=20 . 题解很水但这是我的第一道莫队题。 好像除了边界调了会，其他直接根据原理写不难的。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 200005#define maxv 1000005#define int long longint v[maxn] , n , f[maxv] , curans , bl , m , ans[maxn];inline void upd(int x , int ty)&#123; curans += v[x] + 2 * f[v[x]] * v[x] * ty; f[v[x]] += ty;&#125;struct Node&#123; int l , r , id; bool operator&lt;(const Node&amp; x)const&#123; if(l/bl == x.l/bl) return r &lt; x.r; return l/bl &lt; x.l/bl; &#125;&#125;q[maxn];inline void solve()&#123; bl = (int)pow(n,0.5); std::sort(q+1,q+m+1); int l = 1 , r = 1; for(int i = 1 ; i &lt;= m ; ++i) &#123; while(l &gt; q[i].l) upd(--l , 1); while(r &lt; q[i].r) upd(r++ , 1) ; while(l &lt; q[i].l) upd(l++ , -1); while(r &gt; q[i].r) upd(--r , -1); ans[q[i].id] = curans; &#125;&#125;signed main()&#123; scanf("%lld%lld",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;v[i]); for(int i = 1 ; i &lt;= m ; ++i) scanf("%lld%lld",&amp;q[i].l,&amp;q[i].r) , ++q[i].r ,q[i].id = i; solve(); for(int i = 1 ; i &lt;= m ; ++i) printf("%lld\n",ans[i]);&#125;]]></content>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 29]]></title>
    <url>%2F2018%2F12%2F23%2F2018.12.23%2F</url>
    <content type="text"><![CDATA[「SHOI2015」超能粒子炮・改题目描述曾经发明了脑洞治疗仪与超能粒子炮的发明家 SHTSC 又公开了他的新发明：超能粒子炮・改——一种可以发射威力更加强大的粒子流的神秘装置。 超能粒子炮・改相比超能粒子炮，在威力上有了本质的提升。它有两个参数 nn、kk，它会向每个编号为 00 到 kk（包含两端）的位置 ii 发射威力为 \mathrm{C}_n^i \mathbin{\mathrm{mod}} 2333Cnimod2333 的粒子流。 现在 SHTSC 给出了他的超能粒子炮・改的参数，让你求出其发射的粒子流的威力之和除以 23332333 所得的余数。 输入格式第一行一个整数 tt 表示数据组数。之后 tt 行，每行两个整数 nn、kk，含义如题面描述。 输出格式tt 行，每行一个整数，表示其粒子流的威力之和模 23332333 的值。 样例样例输入123435 510 71145 14 样例输出12332968763 数据范围与提示对于 $100\%$的数据，$t = 100000$，$n, k \leq 10^{18}$。 题解这道题是一道很好的数学题，昨天的推导已经放了（那就再放一次凑数吧） 值得一提的是这题计算的时候有很多细节。。 比如说千万不忘了那些细节，什么$k &lt; 0$ , $k=0$ , $n=0$ 这些细节值45分！（狗日的多组数据。。） 还有就是细节推导错误，虽然昨天我贴的题解是对的，但我并没有看而是自己推的，结果应该是$\frac{k}{p}-1$块整体处理我忘了减1，然后不完整的块我加了1.。。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define mod 2333#define LL long long LL n , k , f[mod+1][mod+1] , fac[mod+1] , g[mod+1];inline LL pow(LL x , LL y , LL m)&#123; LL ans = 1 , base = x; for( ; y ; y &gt;&gt;= 1 , (base *= base) %= m) if(y &amp; 1) ans = ans * base % m; return ans;&#125;void exgcd(int a , int b , int&amp; x , int&amp; y)&#123; if(!b) x = 1 , y = 0; else exgcd(b , a % b , y , x) , y -= a/b * x;&#125;inline LL inv(int k)&#123; int x , y; exgcd(k , mod , x , y); x = (x % mod + mod) % mod; return x;&#125;inline void pre()&#123; fac[0] = 1 , g[0] = inv(1); for(int i = 1 ; i &lt;= mod ; ++i) fac[i] = fac[i-1] * i % mod , g[i] = g[i-1] * inv(i) % mod;&#125;inline LL C(int n , int m)&#123; if(m &gt; n) return 0; return fac[n] * g[m] % mod * g[n-m]; &#125;inline LL lucas(LL n , LL m)&#123; if(!m) return 1; return C(n % mod , m % mod) * lucas(n / mod , m / mod) % mod;&#125;inline LL calc(int n , int k)&#123; return (f[n][k-1] + lucas(n,k)) % mod;&#125;inline void preF()&#123; f[0][0] = 1; for(int i = 1 ; i &lt;= mod ; ++i) f[i][0] = 1; for(int i = 1 ; i &lt;= mod ; ++i) for(int j = 1 ; j &lt;= mod ; ++j) f[i][j] = calc(i,j); return ;&#125;inline LL solve(LL n , LL k)&#123; if(k &lt; 0) return 0; if(!n || !k) return 1; if(n &lt;= mod &amp;&amp; k &lt;= mod) return f[n][k]; return solve(n/mod , k/mod-1) * solve(n % mod , mod-1) % mod + lucas(n/mod , k/mod) * solve(n%mod , k%mod) % mod;&#125;int main()&#123; pre(); preF(); int t; scanf("%d",&amp;t); while(~--t) &#123; scanf("%lld%lld",&amp;n,&amp;k); printf("%lld\n",solve(n,k) % mod); &#125;&#125; 无语，今天是真的废，三维偏序我调了一天了。。。哪种数据错我都分析了，只要重复元素多并且n较大就立刻完蛋，否则怎么也拍不出错来。。 这可咋整。。 感觉我的想法很正确，但就是不对，10分。。 完全想不到问题在哪，有点虚。 可能真的得抄题解才能过活的感觉。 我TM就不想炒题解，一下午没弄出来这破玩意！ 【模板】三维偏序（陌上花开）题目背景这是一道模板题 可以使用bitset，CDQ分治，K-DTree等方式解决。 题目描述有 nn 个元素，第 ii 个元素有 a_iai、b_ibi、c_ici 三个属性，设 f(i)f(i) 表示满足 a_j \leq a_iaj≤ai 且 b_j \leq b_ibj≤bi 且 c_j \leq c_icj≤ci 的 jj 的数量。 对于 d \in [0, n)d∈[0,n)，求 f(i) = df(i)=d 的数量 输入输出格式输入格式： 第一行两个整数 nn、kk，分别表示元素数量和最大属性值。 之后 nn 行，每行三个整数 a_iai、b_ibi、c_ici，分别表示三个属性值。 输出格式： 输出 nn 行，第 d + 1d+1 行表示 f(i) = df(i)=d 的 ii 的数量。 输入输出样例输入样例#1： 复制 123456789101110 33 3 32 3 32 3 13 1 13 1 21 3 11 1 21 2 21 3 21 2 1 输出样例#1： 复制 123456789103130101001 说明$1 \leq n \leq 100000, 1 \leq k \leq 200000$ 题解我就打这个错误的，能过除了一堆重复的外所有数据的CDQ。 这起码是我自己想的。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define maxv 200005int n , seg[maxv] , v[maxn] , ans[maxn] , k , c[maxn] ,tot , dsb[maxn];struct Node&#123; int a , b , c , id , cr; bool operator&lt;(const Node&amp; x)const&#123; if(a == x.a &amp;&amp; b == x.b) return c &lt; x.c; if(a == x.a) return b &lt; x.b; return a &lt; x.a; &#125;&#125;p[maxn] , tmp[maxn] , r[maxn];inline void pre()&#123; std::sort(p+1,p+n+1); int k = 0; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(p[i].a == p[k].a &amp;&amp; p[i].b == p[k].b &amp;&amp; p[i].c == p[k].c) ++v[p[k].id] , dsb[p[i].id] = p[k].id; else k = i , v[p[i].id] ++ , r[++tot] = p[i] , r[tot].cr = tot; &#125;&#125;inline void update(int pos , int v)&#123; for( ; pos &lt;= k ; pos += pos &amp; -pos) seg[pos] += v;&#125;inline int query(int pos)&#123; int ans = 0; for( ; pos ; pos -= pos &amp; -pos) ans += seg[pos]; return ans;&#125;bool cmp(const Node&amp; x , const Node&amp; y)&#123; if(x.b == y.b) return x.c &lt; y.c; return x.b &lt; y.b;&#125;void CDQ(int l , int r , Node* pt)&#123; if(l == r) return ; int mid = l + r &gt;&gt; 1; CDQ(l , mid , pt) , CDQ(mid + 1 , r , pt); for(int i = l ; i &lt;= r; ++i) tmp[i] = pt[i]; std::sort(tmp+l,tmp+r+1,cmp); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].cr &lt;= mid) update(tmp[i].c , v[tmp[i].id]); else if(tmp[i].cr &gt;= mid) ans[tmp[i].id] += query(tmp[i].c); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].cr &lt;= mid) update(tmp[i].c , -v[tmp[i].id]);&#125;int main()&#123; // freopen("data.in","r",stdin); // freopen("my.out","w",stdout); scanf("%d%d",&amp;n,&amp;k); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d%d",&amp;p[i].a,&amp;p[i].b,&amp;p[i].c) , p[i].id = i; pre(); CDQ(1,tot,r); for(int i = 1 ; i &lt;= n ; ++i) if(v[p[i].id]) ans[p[i].id] += v[p[i].id] - 1; for(int i = 1 ; i &lt;= n ; ++i) if(dsb[p[i].id]) ans[p[i].id] = ans[dsb[p[i].id]]; for(int i = 1 ; i &lt;= n ; ++i) ++c[ans[p[i].id]]; for(int i = 0 ; i &lt; n ; ++i) printf("%d\n",c[i]);&#125; 明明按理说有了重复元素只需要把每组元素中找出一个代表并且算出数量，然后CDQ，然后再把其他元素加在答案上就行，可是就是过不了！ 时间宝贵，告辞。 算了还是认真学一下题解的做法吧，毕竟三维偏序还是很重要的。 开始重构代码。。这次一定要思路清晰哪怕写长一点也不要弄得很难调。 这也是个教训，假设调试时间过长但是调试难度过大，不妨换个思路哪怕是换个更好的实现都是不错的选择。 成功用归并排序实现了一下小常数的三维偏序（中间归并一开始居然先归并了左边，注意细节） Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define maxv 200005int n , k , bit[maxv] , tot , c[maxn] , ans[maxn];struct Node&#123; int x , y , z , w , id; bool operator&lt;(const Node&amp; g)const&#123; if(x == g.x &amp;&amp; y == g.y) return z &lt; g.z; if(x == g.x) return y &lt; g.y; return x &lt; g.x; &#125;&#125;tmp[maxn] , num[maxn] , b[maxn];inline void pre()&#123; std::sort(num+1,num+n+1); int ct = 0; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(num[i].x == num[i+1].x &amp;&amp; num[i].y == num[i+1].y &amp;&amp; num[i].z == num[i+1].z) ++ct; else ++ct , b[++tot] = num[i] , b[tot].w = ct , b[tot].id = tot, ct = 0; &#125;&#125;inline void update(int pos , int v)&#123; for( ; pos &lt;= k ; pos += pos &amp; -pos) bit[pos] += v;&#125;inline int query(int pos)&#123; int ans = 0; for( ; pos ; pos -= pos &amp; -pos) ans += bit[pos]; return ans;&#125;void CDQ(int l , int r , Node* pt)&#123; if(l == r) return ; int mid = l + r &gt;&gt; 1 , L = l , R = mid + 1 , ld = l; CDQ(l , mid , pt) , CDQ(mid + 1 , r , pt); while(L &lt;= mid &amp;&amp; R &lt;= r) &#123; if(pt[L].y &lt;= pt[R].y) update(pt[L].z , pt[L].w) , tmp[ld++] = pt[L++]; else ans[pt[R].id] += query(pt[R].z) , tmp[ld++] = pt[R++]; &#125; for(int i = R ; i &lt;= r ; ++i) tmp[ld++] = pt[i] , ans[pt[i].id] += query(pt[i].z); for(int i = L ; i &lt;= mid ; ++i) tmp[ld++] = pt[i]; for(int i = l ; i &lt; L ; ++i) update(pt[i].z , -pt[i].w); for(int i = l ; i &lt;= r ; ++i) pt[i] = tmp[i];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d%d",&amp;num[i].x , &amp;num[i].y , &amp;num[i].z) , num[i].id = i; pre(); CDQ(1,tot,b); for(int i = 1 ; i &lt;= tot; ++i) c[b[i].w + ans[b[i].id] - 1] += b[i].w; for(int i = 0 ; i &lt; n ; ++i) printf("%d\n",c[i]);&#125; 莫队算法学习笔记Mostly from Sengxian and other great posts. Thanks 先声明一下，所有代码区间均为左闭右开 $[l, r)$，点的下标均从 0 开始。 概述莫队算法是由莫涛提出的算法，可以解决一类离线区间询问问题，适用性极为广泛。同时将其加以扩展，便能轻松处理树上路径询问以及支持修改操作。 形式普通莫队对于序列上的区间询问问题，如果从 $[l, r]$的答案能够 $O(1)$扩展到 $[l - 1, r], [l + 1, r],[l, r + 1],[l, r - 1] $的答案，那么可以在 $O(n\sqrt n)$ 的复杂度内求出所有询问的答案。 实现：离线后排序，顺序处理每个询问，暴力从上一个区间的答案转移到下一个区间答案。排序方法：设定块的长度为 $S$，按照 ($\lfloor\frac l S\rfloor, r$) 二元组从小到大排序。复杂度分析：设序列长度为 $n$，询问个数为 $m$。可以发现从 $(l_1, r_1)$ 转移到 $(l_2, r_2)$ 的代价为他们之间的曼哈顿距离。对于每一个询问序列中的每一个块（第一关键字相同），整个块内纵坐标最多变化 $n$ 长度（纵坐标必然单调不减），对于每个询问，横坐标最多变化 $S$。一共有 $\frac nS$​ 个块，相邻块之间转移的复杂度为 $O(n)$，所以复杂度为 $O(\frac {n^2} S + mS + \frac {n^2} S)$，不妨$n, m$ 同阶，取 $S = \sqrt n$ 时可达到最优复杂度 $O(n\sqrt n)$。 伪代码123456789101112131415161718int l = 0, r = 0, nowAns = 0;inline void move(int pos, int sign) &#123; // update nowAns&#125;void solve() &#123; BLOCK_SIZE = int(ceil(pow(n, 0.5))); sort(querys, querys + m); for (int i = 0; i &lt; m; ++i) &#123; const query &amp;q = querys[i]; while (l &gt; q.l) move(--l, 1); while (r &lt; q.r) move(r++, 1); while (l &lt; q.l) move(l++, -1); while (r &gt; q.r) move(--r, -1); ans[q.id] = nowAns; &#125;&#125; 带修改莫队考虑普通莫队加入修改操作，如果修改操作可以$O(1)$的应用以及撤销（同时也要维护当前区间的答案），那么可以在 $O(n^{\frac 5 3})$ 的复杂度内求出所有询问的答案。 实现：离线后排序，顺序遍历询问，先将时间转移到当前询问的时间，然后再像普通莫队一样转移区间。排序方法：设定块的长度为 $S_1$​ 和 $S_2$，按照 ($\lfloor\frac l {S_1}\rfloor, \lfloor\frac r {S_2}\rfloor, t$) 的三元组小到大排序，其中 $t $表示这个询问的时刻之前经历过了几次修改操作。复杂度分析：考虑询问序列中的每个小块，小块内每个询问的一二关键字相同。在这个小块内，显然 $t$ 最多变化 $m$，对于每个询问，$l, r$ 最多变化 $S_1$ 和 $S_2$，一共有 $\frac {n^2} {S_1S_2}$ 个这样的块，相邻块之间转移的复杂度为 $O(n)$（这里指的三个指针的转移复杂度，不难理解吧？），总复杂度就是 $O(mS_1 + mS_2 + \frac {n^2m} {S_1S_2} + \frac {n^3}{S_1S_2})$，不妨设 $n, m$同阶，取 $S_1 = S_2 = n ^ {\frac 2 3}$ 时可达到最优复杂度 $O(n^{\frac 5 3})$ 原作者Sengxian的分析好棒哦，让每个块组合（有$\frac{n^2}{S_1S_2}$个）的$l,r,t$的复杂度均达到最大。 我们还有一种简单些的。 考虑每个左端点的块，右端点必定单调不减，$t$每个询问最坏是$O(m)$ 设块长$S$,有$n/S$块 因此右端点的复杂度是$2\frac{N^2}{S}$ 左端点每次在块内最多变化$S$，所以复杂度是$O(mS)$ 所以最后复杂度就是$O(mS+2\frac{N^2}{S}+m^2)$ 恭喜喜提时间复杂度爆炸！ 所以我们怎么优化$t​$的复杂度呢？我们需要将$r​$也分块，可以证明最后块长和左端点一样（主要是懒得再写一个字母了qwq） 我终于体会到什么叫做平衡了，我们在普通莫队之所以不把第一维严格升序，是因为第二维复杂度会爆炸。 因此我们让一二维的指针每次都保持在一个可以接受的复杂度，化乘法为加法。尽量优化了询问间的曼哈顿距离。 我居然用了这么久才想明白这个问题。显然上面的推导十分的高明。 不过既然块之间的复杂度转移是$O(n)$,那最后的复杂度应该是 $O(mS_1 + mS_2 + \frac {n^2m} {S_1S_2} + \frac {n^3} {S_1S_2})$ 反正最后确实算的都对。 我个sb又花了2018.12.24的一晚上搞明白这东西。。。。。 啊，这位作者居然告诉我真是写错了，那我这个应该是对的。 突然挺高兴。 Code:12345678910111213141516171819202122232425int l = 0, r = 0, t = 0, nowAns = 0;inline void move(int pos, int sign) &#123; // update nowAns&#125;inline void moveTime(int t, int sign) &#123; // apply or revoke modification // update nowAns&#125;void solve() &#123; BLOCK_SIZE = int(ceil(pow(n, 2.0 / 3))); sort(querys, querys + m); for (int i = 0; i &lt; q1; ++i) &#123; const query q = querys[i]; while (t &lt; q.t) moveTime(t++, 1); while (t &gt; q.t) moveTime(--t, -1); while (l &lt; q.l) move(l++, -1); while (l &gt; q.l) move(--l, 1); while (r &lt; q.r) move(r++, 1); while (r &gt; q.r) move(--r, -1); ans[q.id] = nowAns; &#125;&#125; 树上莫队对于树上的路径询问问题，如果能够在 $O(1)$ 的时间内加入、删除一个点的贡献，那么就可在 $O(n\sqrt n)$ 的复杂度内求出所有询问的答案。 实现：离线后排序，顺序遍历询问，暴力转移路径。 如何转移路径？设 $T_u$ 为 $u$ 到根的路径上边的集合，那么 $u$ 到 $v$ 的路径上边的集合就是 $T_u \bigtriangleup T_v$（$\bigtriangleup$ 是对称差）。我们要从$ u\rightarrow v$ 转移到 $u’\rightarrow v’$，等价于这样的转移： $T_u \bigtriangleup T_v \rightarrow T_{u’} \bigtriangleup T_{v’}$ 根据对称差的性质，有 $T_u \bigtriangleup T_u \bigtriangleup T_{u’} = T_{u’}$，所以只需要如下变换即可： $T_u \bigtriangleup T_v \bigtriangleup (T_u \bigtriangleup T_{u’}) \bigtriangleup (T_v \bigtriangleup T_{v’}) = T_{u’}\bigtriangleup T_{v’}$ 落实到程序上面，用 $\mathrm{in}[u]$ 记录点 $u$ 到父亲的边有没有被算进集合，从 $u\rightarrow v$ 转移到 $u’\rightarrow v’$ 的时候，暴力遍历路径 $u \rightarrow u’$ 和路径 $v \rightarrow v’$ 上的边，如果一条边已经加入，那么删掉它，如果没有加入，就加入它。这样就实现了对称差运算。 排序方法：按照 BZOJ 1086 的方法将树分块，设定块的大小为 $S$。按照 $(\mathrm{blockID}(u), \mathrm{dfn}(v))$ 的二元组从小到大排序。复杂度分析：有两种块，一个是树上的块，一个是询问序列中的块（第一关键字相同）。我们单独考虑询问序列中的每个块。每个询问中的 $u$ 属于同一个树上的块。先考虑对于 $u$ 的移动，由于树上的块内任意两个点之间的路径长度是 $O(S)$ 的，所以每个询问，$u$ 点移动的路径长度为 $O(S)$。对于 $v$ 的移动，块内每个询问的 $\mathrm{dfn}(v)$ 是递增的，我们知道，顺序走一边 DFS 序上的每个点，相当于每条边都被走了 2 次，所以每个块中 $v$ 移动的路径长度是 $O(n)$ 的。一共有 $O(\frac n S)$) 个块，相邻块之间转移的复杂度为 $O(n)$，总复杂度：$O(mS + \frac {n^2} S + \frac {n^2} S)$，不妨设 $n, m$ 同阶，取 $S = \sqrt n$ 可达到最优复杂度 $O(n\sqrt n)$。 Code:1234567891011121314151617181920212223242526272829int u = 0, v = 0, nowAns = 0;bool in[MAX_N];inline void flip(int u) &#123; // if u in S: remove u // else insert u // update nowAns&#125;inline int move(int u, int v) &#123; int lca = LCA(u, v); for (int cur = u; cur != lca; cur = anc[0][cur]) flip(cur); for (int cur = v; cur != lca; cur = anc[0][cur]) flip(cur);&#125;void solve() &#123; BLOCK_SIZE = int(ceil(pow(n, 0.5))); sort(querys, querys + m); for (int i = 0; i &lt; m; ++i) &#123; const query &amp;q = querys[i]; int lca = LCA(q.u, q.v); move(u, q.u), move(v, q.v); ans[q.id] = nowAns; u = q.u, v = q.v; &#125;&#125; 树上带修改莫队考虑树上莫队带修改，如果能$O(1)$ 的应用以及撤销修改，那么可以在 $O(n^{\frac 5 3})$ 的复杂度内求出所有询问的答案。思路与普通带修改莫队是类似的。 实现：离线后排序，顺序遍历询问，先将时间转移到当前询问的时间，接着暴力转移路径。排序方法：将树分块，设定块的大小为$S$。按照 $(\mathrm{blockID}(u), \mathrm{blockID}(v), t)$ 的三元组从小到大排序。复杂度分析：我们考虑询问序列中的每个块（一二关键字相同），每个询问 $u $和 $v$ 移动的距离都是 $O(S)$ 的，整个块时间最多变化 $m$。一共有 $O(\frac {n^2} {s^2})$ 个块，相邻块之间转移的复杂度为 $O(n)$，总复杂度：$O(mS + mS + \frac {n^2m} {s^2} + \frac {n^2m} {s^2})$，不妨设 $n, m$同阶，取 $S = n ^ {\frac 2 3}$ 时可达到最优复杂度 $O(n^{\frac 5 3})$。 Code:12345678910111213141516171819202122232425262728293031323334353637int u = 0, v = 0, t = 0, nowAns = 0;bool in[MAX_N];inline void flip(int u) &#123; // if u in S: remove u // else insert u // update nowAns&#125;inline void moveTime(int t, int sign) &#123; // apply or revoke modifications // update nowAns&#125;inline void move(int u, int v) &#123; int lca = ::lca(u, v); for (int cur = u; cur != lca; cur = anc[0][cur]) flip(cur); for (int cur = v; cur != lca; cur = anc[0][cur]) flip(cur);&#125;void solve() &#123; BLOCK_SIZE = int(ceil(pow(n, 2.0 / 3))); sort(querys, querys + m); for (int i = 0; i &lt; q2; ++i) &#123; const query q = querys[i]; while (t &lt; q.t) moveTime(t++, 1); while (t &gt; q.t) moveTime(--t, -1); int lca = LCA(q.u, q.v); move(q.u, u), move(q.v, v); ans[q.id] = nowAns; u = q.u, v = q.v; &#125;&#125; 还有四道例题尽在：https://blog.sengxian.com/algorithms/mo-s-algorithm 好吧说实话我好像只看懂了第一个，明天做道莫队的题。。]]></content>
      <tags>
        <tag>lucas 可持久化 莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 28]]></title>
    <url>%2F2018%2F12%2F22%2F2018.12.22%2F</url>
    <content type="text"><![CDATA[[SDOI2010]古代猪文题目背景“在那山的那边海的那边有一群小肥猪。他们活泼又聪明，他们调皮又灵敏。他们自由自在生活在那绿色的大草坪，他们善良勇敢相互都关心……” ——选自猪王国民歌 很久很久以前，在山的那边海的那边的某片风水宝地曾经存在过一个猪王国。猪王国地理位置偏僻，实施的是适应当时社会的自给自足的庄园经济，很少与外界联系，商贸活动就更少了。因此也很少有其他动物知道这样一个王国。 猪王国虽然不大，但是土地肥沃，屋舍俨然。如果一定要拿什么与之相比的话，那就只能是东晋陶渊明笔下的大家想象中的桃花源了。猪王勤政爱民，猪民安居乐业，邻里和睦相处，国家秩序井然，经济欣欣向荣，社会和谐稳定。和谐的社会带给猪民们对工作火红的热情和对未来的粉色的憧憬。 小猪iPig是猪王国的一个很普通的公民。小猪今年10岁了，在大肥猪学校上小学三年级。和大多数猪一样，他不是很聪明，因此经常遇到很多或者稀奇古怪或者旁人看来轻而易举的事情令他大伤脑筋。小猪后来参加了全猪信息学奥林匹克竞赛(Pig Olympiad in Informatics, POI)，取得了不错的名次，最终保送进入了猪王国大学(Pig Kingdom University, PKU)深造。 现在的小猪已经能用计算机解决简单的问题了，比如能用P++语言编写程序计算出A + B的值。这个“成就”已经成为了他津津乐道的话题。当然，不明真相的同学们也开始对他刮目相看啦~ 小猪的故事就将从此展开，伴随大家两天时间，希望大家能够喜欢小猪。 题目描述猪王国的文明源远流长，博大精深。 iPig在大肥猪学校图书馆中查阅资料，得知远古时期猪文文字总个数为N。当然，一种语言如果字数很多，字典也相应会很大。当时的猪王国国王考虑到如果修一本字典，规模有可能远远超过康熙字典，花费的猪力、物力将难以估量。故考虑再三没有进行这一项劳猪伤财之举。当然，猪王国的文字后来随着历史变迁逐渐进行了简化，去掉了一些不常用的字。 iPig打算研究古时某个朝代的猪文文字。根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的k分之一，其中k是N的一个正约数（可以是1和N）。不过具体是哪k分之一，以及k是多少，由于历史过于久远，已经无从考证了。 iPig觉得只要符合文献，每一种能整除N的k都是有可能的。他打算考虑到所有可能的k。显然当k等于某个定值时，该朝的猪文文字个数为N / k。然而从N个文字中保留下N / k个的情况也是相当多的。iPig预计，如果所有可能的k的所有情况数加起来为P的话，那么他研究古代文字的代价将会是G的P次方。 现在他想知道猪王国研究古代文字的代价是多少。由于iPig觉得这个数字可能是天文数字，所以你只需要告诉他答案除以999911659的余数就可以了。 输入输出格式输入格式： 输入文件ancient.in有且仅有一行：两个数N、G，用一个空格分开。 输出格式： 输出文件ancient.out有且仅有一行：一个数，表示答案除以$999911659$的余数。 输入输出样例输入样例#1： 14 2 输出样例#1： 12048 说明数据规模 100%的数据中，$1 &lt;= G &lt;= 1000000000，1 &lt;= N &lt;= 1000000000$。 题解自从联赛前一个多月到现在，好久没有写过数学题了。 所以调了一年 让我先把一堆bug表出来。 显然这样子处理阶乘的逆元虽然慢一点但绝对不会错！ 取模漏掉等号可还行？ 先说这么多吧。 题意让你求 $G^{\sum_{d|n}C_{n}^{d}}$ 显然要用到欧拉定理处理上面的指数。 对于$mod-1$，我们发现可以把它拆成小质数的乘积（这也是本题唯一的难点吧233） 然后就可以对每个小质数都应用卢卡斯定理进行计算，然后CRT合并即可。 感觉还没EXLUCAS的板子难 分析时间复杂度：考虑到模数分解的4个小质数都要计算，是一个常数4,。对于每次计算，我们需要$O(\sqrt{n})$的枚举其约数，然后对于每个约数，用卢卡斯定理$O(plog_pn)$算出其值。 可以分析得到这就是整个程序的渐进复杂度，为$O(4\sqrt{n}plog_pn)$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define LL long longconst int mod = 999911659;LL n , h , f[50005] , g[50005];int fac[10] , tot;void exgcd(int a , int b , int&amp; x , int&amp; y)&#123; if(!b) x = 1 , y = 0; else exgcd(b , a % b , y , x) , y -= a/b * x;&#125;inline int inv(int a , int modm)&#123; int x , y; exgcd(a , modm , x , y); x = (x % modm + modm) % modm; if(!x) x += modm; return x;&#125;inline void pre(int k)&#123; f[0] = 1; g[0] = inv(1, k); for(int i = 1 ; i &lt;= k ; ++i) f[i] = 1ll * i * f[i-1] % k , g[i] = g[i-1] * inv(i , k) % k;&#125;inline LL C(int n , int m , int p)&#123; if(m &gt; n) return 0; LL ans = 1; ans = f[n] * g[m] % p * g[n-m] % p; return ans;&#125;LL lucas(int n , int m , int p)&#123; if(!m) return 1; return C(n % p , m % p , p) * lucas(n / p , m / p , p);&#125;inline void getFac()&#123; int lim = std::sqrt(mod - 1) , tmp = mod - 1; for(int i = 2 ; i &lt;= lim ; ++i) &#123; if(tmp % i == 0) &#123; ++tot; fac[tot] = i; while(tmp % i == 0) tmp /= i; &#125; &#125; if(tmp &gt; 1) fac[++tot] = tmp;&#125;inline LL calc(int modm)&#123; LL ans = 0; for(int i = 1 ; i * i &lt;= n ; ++i) &#123; if(n % i == 0) &#123; (ans += lucas(n , i , modm)) %= modm; if(n != i * i) (ans += lucas(n , n/i , modm)) %= modm; &#125; &#125; return ans;&#125;inline LL CRT(LL x , LL nowm)&#123; return x * ((mod-1)/nowm) * inv((mod-1)/nowm , nowm);&#125;inline LL solve()&#123; LL ans = 0; getFac(); for(int i = 1 ; i &lt;= tot ; ++i) &#123; int nowm = fac[i]; pre(nowm); (ans += CRT(calc(nowm) , nowm)) %= (mod - 1); &#125; return ans;&#125;inline LL pow(LL x , LL y , LL m)&#123; LL ans = 1 , base = x; for( ; y ; (base *= base) %= m , y &gt;&gt;= 1) if(y &amp; 1) ans = ans * base % m; return ans;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;h); if(h % mod == 0)&#123; puts("0"); return 0; &#125; printf("%lld\n",pow(h,solve(),mod));&#125; 「一本通 2.1 练习 8」收集雪花题目描述不同的雪花往往有不同的形状。在北方的同学想将雪花收集起来，作为礼物送给在南方的同学们。一共有 nn 个时刻，给出每个时刻下落雪花的形状，用不同的整数表示不同的形状。在收集的过程中，同学们不希望有重复的雪花。你可以从任意 aa 时刻开始，在 bb 时刻停止。aa 到 bb 时刻中间的雪花也都将被收集。他们希望收集的雪花最多。 输入格式第一行一个正整数 nn； 第 22 行 nn 个非负整数表示 nn 个时刻雪花的形状。 输出格式最多能收集雪花的数量。 样例输入样例1251 2 3 2 1 输出样例13 数据范围与提示对于 97 分的数据，$1\le n \le 10^6, 0\le x_i \le 10^8$（为原始数据） 应用户要求，加入 3 分的数据，$1\le n\le 10^6,0\le x_i\le 10^9$ 题解这种连续区间问题很容易想到双指针来做啦。 就是只要没出现，右指针就一直向右扩展，当一个元素出现过时，就向右移动左指针，应该算是一种贪心思想吧。 这道题就是这么简单啦。 Code：1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 1000005#define maxv 1000000005int n , a[maxn] , ans;bool cur[maxv];int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;a[i]); int L = 1 , R = 2 , cans = ans = 1; cur[a[1]] = true; while(R &lt; n) &#123; if(!cur[a[R]]) cur[a[R]] = true , ++cans , ++R; else cur[a[L]] = false , ++L , --cans; ans = std::max(ans , cans); &#125; printf("%d\n",ans);&#125; 这个快速算阶乘挺有意思（注意用完这个函数还得把那些pi质因子乘回去！） 12345678910111213inline LL fac(LL n , LL pi , LL pk)&#123; if(!n) return 1; LL ans = 1; if(n / pk)&#123; for(int i = 2 ; i &lt;= pk ; ++i) if(i % pi) (ans *= i) %= pk; ans = pow(ans , n / pk , pk); &#125; for(int i = 2 ; i &lt;= n % pk ; ++i) if(i % pi) (ans *= i) %= pk; return ans * fac(n / pi , pi , pk) % pk;&#125; 「SHOI2015」超能粒子炮・改题目描述曾经发明了脑洞治疗仪与超能粒子炮的发明家 SHTSC 又公开了他的新发明：超能粒子炮・改——一种可以发射威力更加强大的粒子流的神秘装置。 超能粒子炮・改相比超能粒子炮，在威力上有了本质的提升。它有两个参数 nn、kk，它会向每个编号为 00 到 kk（包含两端）的位置 ii 发射威力为 \mathrm{C}_n^i \mathbin{\mathrm{mod}} 2333Cnimod2333 的粒子流。 现在 SHTSC 给出了他的超能粒子炮・改的参数，让你求出其发射的粒子流的威力之和除以 23332333 所得的余数。 输入格式第一行一个整数 tt 表示数据组数。之后 tt 行，每行两个整数 nn、kk，含义如题面描述。 输出格式tt 行，每行一个整数，表示其粒子流的威力之和模 23332333 的值。 样例样例输入123435 510 71145 14 样例输出12332968763 数据范围与提示$t = 100000，n, k \leq 10^{18}$。题解题意就是说求出 $\sum_{i=0}^{k}C_n^i$ 这题好像除了用整除分块的思想外没有其他很好的方法。。 直接上其他人的题解就得了。 由于我突然想咕掉代码，所以明天底下会补上代码，今天就此结束。 End.]]></content>
      <tags>
        <tag>Exlucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 27]]></title>
    <url>%2F2018%2F12%2F21%2F2018.12.21%2F</url>
    <content type="text"><![CDATA[我爱过你，利落干脆 复习一下EXCRT吧！ 顺便贴下我以前的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long longll A[maxn] , B[maxn] , n;ll exgcd(ll a , ll b , ll&amp; x, ll&amp; y)&#123; if(!b) &#123; x = 1 , y = 0; return a; &#125; ll g = exgcd(b , a % b , y, x); y -= a/b * x; return g;&#125;inline ll mul(ll x , ll y , ll mod)&#123; ll ans = 0 , base = x; while(y) &#123; if(y &amp; 1) ans = (ans + base) % mod; (base &lt;&lt;= 1 ) %= mod; y &gt;&gt;= 1; &#125; return ans;&#125;ll EXCRT()&#123; ll ans = A[1] , P1 = B[1] , x , y;//init first equation for(int i = 2 ; i &lt;= n ; ++i) &#123; ll a = P1 , b = B[i] , c = (A[i] - ans % b + b) % b , gcd = exgcd(a,b,x,y) , poc = b / gcd; x = mul(x , c / gcd , poc); x = (x + poc) % poc; // make sure x is a positive integer if(c % gcd) return -1; ans += x * P1; P1 *= poc; ans = (ans % P1 + P1) % P1; &#125; return ans;&#125;int main()&#123; scanf("%lld",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld%lld",&amp;B[i],&amp;A[i]); printf("%lld",EXCRT());&#125; 模数LCM需要小于long long范围（实在不行只能写高精度这种恶心的东西了） 顺便看下Lucas定理（又是抄袭）： 卢卡斯定理我的大部分式子都是展开形式就是一堆没有的展开 首先我们需要证明$C_p^i\equiv\frac{p}{i}C_{p-1}^{i-1}\equiv 0~~~(mod~p),(1&lt;=i&lt;=p-1)$ $C_p^i=\frac{p!}{i!(p-i)!}=\frac{p}{i} \frac{(p-1)!}{(i-1)!(p-1-i+1)!} \frac{p}{i} \frac{(p-1)!}{(i-1)!(p-i)!}=\frac{p}{i}C_{p-1}^{i-1}$ 得证。 然后根据这种性质和二项式定理。，我们马上得出 $(1+x)^p\equiv C_p^01^p+C_p^1x^{2}+….+C_p^px^p\equiv C_p^01^px^0+C_p^p1^0x^p\equiv 1+x^p(mod ~p)$ 然后我们接下来要求证 $C_a^b\equiv C_{a_0}^{b_0}\cdot C_{a_1p}^{b_1p} \cdot C_{a_2p^2}^{b_2p^2}…..(mod~p)$ 其实我们令$a=lp+r,b=sp+j$好奇怪的变量名呀,随便起的~~ 求证$C_a^b\equiv C_{lp}^{sp}\cdot C_{r}^{j}(mod~p)$然后利用性质递归求解就可以了。 继续从二次项定理出发 $(1+x)^a=(1+x)^{lp} \cdot (1+x)^r$ 然后展开$(1+x)^{lp}$ $(1+x)^{lp} \equiv ((1+x)^p)^l \equiv (1+x^p)^l(mod~p)$ $\therefore (1+x)^a \equiv (1+x^p)^l \cdot (1+x)^r(mod~p)$ 观察项$x^b$的系数 $\because C_a^bx^b \equiv C_l^sx^{sp} \cdot C_r^jx^j(mod~p)$ $\therefore C_a^bx^b \equiv C_l^s \cdot C_r^jx^b(mod~p)$ $\therefore C_a^b\equiv C_l^s\cdot C_r^j \equiv C_{\lfloor \frac{a}{p} \rfloor}^{\lfloor \frac{b}{p} \rfloor}\cdot C_{a~mod~p}^{b~mod~p}(mod~p)$ //上面的取模写法好像不大严谨，还请见谅（并没有系统的学过同余） 得证 实现的时候注意可能出现计算组合数m比n大的情况，这个时候需要返回0不然会算错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long longll n , m , k;int t;int exgcd(int a, int b , int&amp; x , int&amp; y)&#123; if(!b)&#123; x = 1 , y = 0; return a; &#125; int g = exgcd(b , a % b , y, x); y -= a/b * x; return g;&#125;inline int inv(int num)&#123; int x , y , gcd = exgcd(num , k , x , y); x = (x % k + k) % k; return x;&#125;inline ll C(int x , int y)&#123; ll ans = 1; if(y &gt; x) return 0; for(int i = y + 1 ; i &lt;= x ; ++i) (ans *= i) %= k; for(int i = 1 ; i &lt;= x - y ; ++i) (ans *= inv(i)) %= k; return ans;&#125;inline ll lucas(int x , int y)&#123; if(!y) return 1; ll ans = 1; return C(x % k , y % k) * lucas(x / k , y / k) % k;&#125;int main()&#123; scanf("%d",&amp;t); while(~--t) &#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); printf("%lld\n",lucas(n+m,m)); &#125;&#125; 然后愉快的看ExLucas原理 扩展卢卡斯定理。 首先，得确定先会扩展欧几里得算法和扩展中国剩余定理。至于卢卡斯定理，那并不重要。 设$p=\prod p_i^{k_i}$，则: 假如你已经求出了$\binom{n}{m}\bmod{p_i^{k_i}}$，那么明显是可以利用exCRT来合并答案的。 那么问题转换为如何求出$\binom{n}{m}\bmod{p^k}$(p是质数)。 可以知道:$\binom{n}{m}=\frac{n!}{m!(n-m)!}$那么问题即转化为求出几个阶乘和阶乘的逆元。 现在，问题归为如何快速求出阶乘。 为了便于统计出现了多少个$p$的次幂，先将阶乘中所有p的倍数提出来。可以简单算出，一共有$\displaystyle\lfloor\frac{n}{p}\rfloor$个。这中间每一项都除去p，可以得到$\displaystyle\lfloor\frac{n}{p}\rfloor!$。该部分可以选择递归求解。 那么接下来只剩下非$p$的倍数的几项了。通过简单观察可以知道（这里很玄学），剩余几项具有循环节，循环节长度小于$p^k$。原因是剩余项关于$p$具有循环节，而$a+p^k\equiv a\pmod{p^k}$，所以可以一起计算。结果会剩下几项凑不齐一个循环节，但是这几项长度已经小于一个循环节了，可以选择暴力求解。 为了更好地理解上方几条，可以举个栗子: 这样就可以在可承受的时间复杂度内求出阶乘。但是，为了达到除法的效果，我们需要考虑$p$的次幂一共出现了多少次。根据前面的计算，可以知道只除去一个$p$时，$n!$内包括了$\displaystyle\lfloor\frac{n}{p}\rfloor$个$p!$。剩下的数字如果要可能存在$p$的次幂也可以归为一个阶乘，即$\displaystyle\lfloor\frac{n}{p}\rfloor$!。设$f(n)$表示$n!$中有多少个$p$的因数，那么，我们就可以得到一个递推式$f(n)=f(\displaystyle\lfloor\frac{n}{p}\rfloor)+\displaystyle\lfloor\frac{n}{p}\rfloor$边界为:$f(x)=0(x&lt;p)$ 开始计算时间复杂度。 首先是中国剩余定理的复杂度，是$O(plogP)$的。(其中P是模数，p是最大质因子)。 然后是求阶乘复杂度。当求$n!\bmod p^k$时，时间复杂度为$O(p^klogn(log_pn-k))$ 最后是求逆元的复杂度。利用扩展欧几里得可以做到$O(logp)$ 因此，总复杂度为$O(\sum p^klogn(log_pn-k)+plogP)$ 这个复杂度和$O(PlogP)$同级。 献上因为写完10分钟，有个函数没开$ll$调了两小时的玄学EXLUCAS模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 1000005#define ll long longll n , m , mod;ll exgcd(ll a , ll b , ll&amp; x , ll&amp; y)&#123; if(!b)&#123; x = 1 , y = 0 ; return a; &#125; ll g = exgcd(b , a % b , y , x); y -= a/b * x; return g;&#125;inline ll inv(ll a , ll mod)&#123; ll x , y , gcd = exgcd(a , mod , x , y); x = (x % mod + mod) % mod; if(!x) x += mod; return x;&#125;inline ll pow(ll x, ll y , ll mod)&#123; ll ans = 1 , base = x; while(y) &#123; if(y &amp; 1) ans = (ans * base) % mod; base = (base * base) % mod; y &gt;&gt;= 1; &#125; return ans;&#125;ll f(ll x , ll p)&#123; if(x &lt; p) return 0; ll ans = f(x/p , p); return ans + x / p;&#125;inline ll fac(ll n , ll pi , ll pk)&#123; if(!n) return 1; ll ans = 1; if(n / pk)&#123; for(int i = 2 ; i &lt;= pk ; ++i) if(i % pi) (ans *= i) %= pk; ans = pow(ans , n / pk , pk); &#125; for(int i = 2 ; i &lt;= n % pk ; ++i) if(i % pi) (ans *= i) %= pk; return ans * fac(n / pi , pi , pk) % pk;&#125;inline ll C(ll n , ll m , ll pi , ll pk)&#123; if(m &gt; n) return 0; ll k = f(n , pi) - f(m , pi) - f(n-m , pi); ll a = fac(n , pi , pk) , b = fac(m , pi , pk) , c = fac(n - m , pi , pk); return a * inv(b , pk) % pk * inv(c , pk) % pk * pow(pi , k , pk) % pk;&#125;inline ll CRT(ll x , ll pk)&#123; return x * (mod / pk) % mod * inv(mod / pk , pk) % mod;&#125;inline ll exlucas(ll n , ll m)&#123; ll ans = 0; for(ll tmp = mod , i = 2 ; i &lt;= mod ; ++i) &#123; if(tmp % i == 0) &#123; int pk = 1; while(!(tmp % i)) pk *= i , tmp /= i; (ans += CRT(C(n , m , i , pk) , pk)) %= mod; &#125; &#125; return ans;&#125;int main()&#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;mod); printf("%lld\n",exlucas(n,m)); return 0;&#125; 在写exlucas之前我们最好学习一下CRT(中国剩余定理)，这样exlucas的代码量就可以少一点。 中国剩余定理 我们如何证明它的正确性呢？ 这样我们只需要看看如何通过上述定理合并两个同余方程。 1inline ll CRT(ll b,ll mod)&#123;return b*inv(p/mod,mod)%p*(p/mod)%p;&#125; p是所有模数乘起来（就是所有mod乘起来），mod是当前模数，然后就是上面一模一样的定理。我们可以用这个在$O(logn)$的时间里合并同余方程（各模数互质）。 然后就可以补上最上面那个玄学定理（没有确定的时间复杂度和正确性保证。。）的题解代码。 简单的扩欧写法： 12345void exgcd(LL a,LL b,LL &amp;x,LL &amp;y)&#123; if (!b) x=1LL,y=0LL; else exgcd(b,a%b,y,x),y-=a/b*x;&#125; 数论题有的地方忘了开long long调试真是痛苦的事情。。。。 幸好debug能力变强了一点，不过还是看了2小时。。。。以后用long long就全用得了。。 总结：四个有趣的数论定理回顾了一下，EXLUCAS玄学算法无正确性证明，我还是那么菜。]]></content>
  </entry>
  <entry>
    <title><![CDATA[RBZ Diary]]></title>
    <url>%2F2018%2F12%2F21%2FRBZ's%20Diary%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RBZ general course notes]]></title>
    <url>%2F2018%2F12%2F20%2FRBZ%20General%20course%20note%2F</url>
    <content type="text"><![CDATA[若想生长，贫瘠的土壤阻止不了发芽的希望，若想生存，绝境也能求生。 2018.12.20化学正盐就是在酸跟碱完全中和生成的盐中，不会有酸中的氢离子，也不会有碱中的氢氧根离子，只有金属阳离子和酸根离子的盐。化学中的盐分为单盐和合盐，单盐分为正盐、酸式盐、碱式盐，合盐分为复盐和络盐。 中文名 正盐 定 义 化学中的盐分为单盐和合盐 解 释 呈中性的盐 特 点 不含氢离子和氢氧根离子 目录 1 定义性质 ▪ 定义 ▪ 性质 2 正盐分类 ▪ 强酸强碱盐 ▪ 强酸弱碱盐 ▪ 强碱弱酸盐 ▪ 弱酸弱碱盐 定义性质编辑 定义既不含能电离的氢离子，又不含氢氧根离子的盐。 性质正盐是酸和碱完全中和的产物，但正盐的水溶液不一定显中性，如Na2CO3（碳酸钠）溶液显碱性，$(NH4)_2SO_4$（硫酸铵）溶液显酸性。 酸跟碱完全中和生成的盐中，不会有酸中的氢离子，也不会有碱中的氢氧根离子，只有金属阳离子和酸根离子，这样的盐为正盐。生成正盐的反应，如： $HCl+NaOH=NaCl+H_2O$ $H2SO_4+Cu(OH)_2 = CuSO_4+2H_2O$ $H_2SO_4+2NaOH=Na_2SO_4+2H_2O$等 正盐分类编辑 强酸强碱盐不发生水解，因为它们电离出来的阴、阳离子不能破坏水的电离平衡，所以呈中性。 强酸弱碱盐我们把弱碱部分叫弱阳，弱碱离子能把持着从水中电离出来的氢氧根离子，破坏了水的电离平衡，使得水的电离正向移动，结果溶液中的氢离子浓度大于氢氧根离子浓度，使水溶液呈酸性。 强碱弱酸盐我们把弱酸部分叫弱阴，同理弱阴把持着从水中电离出来的氢离子，使得溶液中氢氧根离子浓度大于氢离子浓度，使溶液呈碱性。 弱酸弱碱盐弱酸部分把持氢，弱碱部分把持氢氧根，生成两种弱电解质，再比较它们的电离常数Ka、Kb值的大小（而不是水解度的大小），在一温度下，弱电解质的电离常数（又叫电离平衡常数）是一个定值，这一比较就可得出此盐呈什么性了，谁强呈谁性，电离常数是以10为底的负对数，谁负得少谁就大。总之一句话，盐溶液中的阴、阳离子把持着从水中电离出来的氢离子或氢氧根离子能生成弱电解质的反应叫盐类的水解。还有有机物类中的水解，例如酯类的水解，是酯和水反应（在无机酸或碱的条件下）生成对应羧酸和醇的反应叫酯的水解，还有卤代烃的碱性水解，溴乙烷和氢氧化钠水溶液反应生成乙醇和溴化钠叫卤烷的水解，还有蛋白质的水解，最终产物为氨基酸等等。 酸式酸根是指由正盐酸根离子结合一个或多个氢离子得到的酸根阴离子。 中文名 酸式酸根 得 到 酸根阴离子 硫氢根离子 硫离子结合一个氢离子 只 溶 钾、钠、铵 例如： 碳酸氢根离子（HCO₃ -)：碳酸根离子结合一氢离子，水解程度大于电离程度，和强碱形成的盐显碱性； 硫酸氢根离子（HSO₄ -)：硫酸根离子结合一氢离子，电离程度大于水解程度，实际在水溶液中不是完全电离，但在中学阶段认为是完全电离，和强碱形成的溶液显酸性； ； 磷酸氢根离子(HPO₄ 2-)：一个磷酸根离子结合一个氢离子，基本上所有盐溶液都溶于水； 磷酸二氢根离子(H₂PO₄ -)：一个磷酸根离子结合两个氢离子，。 强酸与弱酸的阴离子，弱酸的酸式酸根离子不能大量共存。 强碱与弱碱的阳离子，弱酸的酸式酸根离子不能大量共存。 本词条由“科普中国”科学百科词条编写与应用工作项目 审核 。 洗气就是把混合气体中杂质气体除去的过程，比如用浓硫酸除去混在氧气中的水蒸气，洗气的对象为水蒸气。 中文名 洗气 对 象 洗气的对象为水蒸气 浓硫酸 适用范围:中性及酸性气体 不适用范围: 有机不饱和化合物 目录 1 常见干燥剂 ▪ 酸性干燥剂 ▪ 碱性干燥剂 ▪ 中性干燥剂 ▪ 盐类干燥剂 2 洗气的举例 3 洗气方式 ▪ 物理方式 ▪ 化学方式 4 注意事项 常见干燥剂编辑 : 酸性干燥剂1、浓硫酸： 适用范围：中性及酸性气体。 不适用范围：有机不饱和化合物(烯，炔等)碱性物质。 2、五氧化二磷： 适用范围：主要用于干燥有机物，由于生成的磷酸会覆盖表面，所以常与载体连用。 不适用范围：醇 有机酸 HCl(盐酸) HF(氢氟酸)等。 3、十氧化四磷：主要用于干燥浓硫酸。 碱性干燥剂1、碱石灰：主要用于干燥碱性气体，不能干燥酸类和酯类。 2、金属钠：用于干燥非极性有机物，不能干燥含水量过多的物质，否则有危险。 3、碱金属的氢氧化物：不能干燥酸性物质。 中性干燥剂硅胶：可以干燥除HF外的几乎所有物质，掺入氯化钴可以制成变色硅胶，用途非常广泛（如食品保干）。 盐类干燥剂无水硫酸铜,氯化钙，硫酸镁，硫酸钠，硫酸钙，碳酸钾等等，应用广泛，其中氯化钙要避免氨气等有配合性的物质，以免失效。 [1] 本词条由“科普中国”科学百科词条编写与应用工作项目 审核 。 洗气就是把混合气体中杂质气体除去的过程，比如用浓硫酸除去混在氧气中的水蒸气，洗气的对象为水蒸气。 中文名 洗气 对 象 洗气的对象为水蒸气 浓硫酸 适用范围:中性及酸性气体 不适用范围: 有机不饱和化合物 目录 1 常见干燥剂 ▪ 酸性干燥剂 ▪ 碱性干燥剂 ▪ 中性干燥剂 ▪ 盐类干燥剂 2 洗气的举例 3 洗气方式 ▪ 物理方式 ▪ 化学方式 4 注意事项 常见干燥剂编辑 : 酸性干燥剂1、浓硫酸： 适用范围：中性及酸性气体。 不适用范围：有机不饱和化合物(烯，炔等)碱性物质。 2、五氧化二磷： 适用范围：主要用于干燥有机物，由于生成的磷酸会覆盖表面，所以常与载体连用。 不适用范围：醇 有机酸 HCl(盐酸) HF(氢氟酸)等。 3、十氧化四磷：主要用于干燥浓硫酸。 碱性干燥剂1、碱石灰：主要用于干燥碱性气体，不能干燥酸类和酯类。 2、金属钠：用于干燥非极性有机物，不能干燥含水量过多的物质，否则有危险。 3、碱金属的氢氧化物：不能干燥酸性物质。 中性干燥剂硅胶：可以干燥除HF外的几乎所有物质，掺入氯化钴可以制成变色硅胶，用途非常广泛（如食品保干）。 盐类干燥剂无水硫酸铜,氯化钙，硫酸镁，硫酸钠，硫酸钙，碳酸钾等等，应用广泛，其中氯化钙要避免氨气等有配合性的物质，以免失效。 [1] 洗气的举例编辑 要除去氮气中含有的少量的二氧化碳，水蒸气，氢气，某同学设计了如下实验步骤，正确的操作顺序是( ) 1、 通过浓硫酸的洗气瓶 2、 通过盛氢氧化钠溶液的洗气瓶 3、 通过盛有灼热氧化铜的试管 这里面是除去三种气体，很明显，浓硫酸是除去水蒸气的；氢氧化钠是除去二氧化碳的（但是注意，气体从氢氧化钠溶液里面出来会带出水蒸气，所以，这步必须放在浓硫酸的前面，）；灼热氧化铜，是用来除去氢气的，这个跟2差不多，氢气被还原以后，也会生成水，所以正确的操作顺序应该是231 。 最后总结，除去气体，有水，水通常放最后除去。 检验气体，检验水，水通常放第一步除去。 认为是231 不用3做为第一个的理由是。CO2+H2=CO+H2O （合成水煤气的反应、要加热） 引入CO后无法在后二个步骤中除去。 所以先通过2，除去CO2。 再通过3，除去H2，这里会有水生成了。 最后通过1，完全将水除去。 [2] 洗气装置 洗气方式编辑 物理方式气体中需要被去除的杂质在洗液中溶解度较大，并且杂质气体仅仅是单纯的溶解于洗液。 化学方式杂质气体可以与水发生反应从而生成新的化合物溶解在洗液中或生成沉淀析出。例如：杂质气体为氨气用水做洗液，氨气与水生成碱性的氨水；杂质气体为二氧化碳石灰水做洗液生成碳酸钙沉淀。 [3] 注意事项编辑 直型玻璃管（盛固），接短进短出。 装置：广口瓶或试管（盛液），长进短出。 溶液不会与所要提纯的气体发生化学或物理反应。 洗气瓶 溶液在除去混合气中非目的气时不会产生新的杂质气体。 除去氯气中混有HCl的气体HCl在水中溶解度很大，1体积水可以溶解500体积的HClCl2溶于水后发生可逆反应$Cl2+H2O==HCl+HClO$饱和食盐水中大量的Cl(-)，抑制该可逆反应，使平衡向左移动，更减少了Cl2在水中的溶解（1体积水能溶解2体积的Cl2）。所以用饱和食盐水可以除去氯气中混有的少量HCl。 所以用饱和NaCl溶液]]></content>
      <tags>
        <tag>补课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 26]]></title>
    <url>%2F2018%2F12%2F20%2F2018.12.20%2F</url>
    <content type="text"><![CDATA[别让执念 毁掉了昨天 来看一道简单题 IOI Tree题目描述给你一棵TREE,以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于K 输入输出格式输入格式： $N（n&lt;=40000）$ 接下来n-1行边描述管道，按照题目中写的输入 接下来是$k$ 输出格式： 一行，有多少对点之间的距离小于等于$k$ 输入输出样例1234567871 6 13 6 3 9 3 5 7 4 1 3 2 4 20 4 7 2 10 15 题解假如了解过点分治不难想到做法。 对于这种统计路径并且对于一个点p能分治成过p和不过p的，可以很容易联想到点分治做法。 求出当前树的重心 dfs求出每个点到当前重心的距离，排序后用双指针扫描统计，注意容斥，把重心每个子树在这样做一遍即可 递归每个子树重心（注意，如果递归的点已经被访问，代表已经被处理，返回即可。） 整个做法的时间复杂度是$O(nlog^2n)$ 第二步的容斥网上都讲的繁琐玄学。。。然后我就想到这个方法，可能慢一点但很好理解，就代表去掉相同子树里的点对（不属于简单路径）。 还有就是为什么递归重心最多只需要$logn$次，给出证明： 这个命题等价于将重心删除后，最大联通块小于等于树大小的一半，这里我们可以反证。 如果最大联通块的大小超过一半，那么其它的加起来小于一半，此时重心取那个最大联通块与当前重心相连的点时比当前重心优，即当前重心不满足重心定义，与初始条件矛盾。所以 最大联通块小于等于树大小的一半。 然后就没什么了。 考虑点分治奇多无比的细节与今天阴暗的内心世界，我决定咕掉代码。 树的经典问题和方法 路经统计 欧拉序列 树的动态查询问题 轻重路径剖分 第一个标题即树分治算法，略过，最后一个标题仅仅复习一些重要性质的证明。 欧拉序列DFS一颗树不管刚访问还是回溯都把这个点加进欧拉序列，然后在这个序列上可以做很多有趣的事情，比起树链剖分这个似乎简单一些。 动态查询问题改单边或单点查询也是单边或单点使用欧拉序列+树状数组即可，否则HPD解决一切。 轻重路径划分简单叙述原理以及对时间复杂度的论述: 原理就是将树划分成重链轻链，然后通过适当的编号将重链接成序列用线段树维护，而由重儿子和轻儿子的定义可知，对于节点u的轻儿子v， sz[v]=size(vi)(i>1) size(vi)+size(vi)=2∗size(vi)vk−>vroot−>...−>v1−>...−>v2−>...−>vk−>...−>v(其中 −>v1,−>v2,...,−>vk−>v1,−>v2,...,−>vk为轻边) size(vk)>=size(v)>=1 size(vk的前趋)>=2∗size(vk)(性质1)>=2同理可得： size(vk−1的前趋)>=2∗size(vk的前趋)>=22size(vk−1的前趋)>=2∗size(vk的前趋)>=2^2所以有： n=size(root)>=size(v1的前趋)>=2kn=size(root)>=size(v1的前趋)>=2^k所以 k=O(logn)从root到v的路径中有k条轻边，那么路径上其他边即为重边，那么重链数=k+1，所以重链$O(logn)$。 从上面的阐述中我们也可以理解到为什么树链剖分的常数那么小，因为很显然每一步放缩都是在2个节点并且是在轻重儿子最接近的情况下得出的结论。 我自己抄自己，是不是和CCF一样牛逼？ 就到这里吧，滚回去学文化课。]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 25]]></title>
    <url>%2F2018%2F12%2F19%2F2018.12.19%2F</url>
    <content type="text"><![CDATA[多幸运 在最美的年纪 遇见你 没有遗憾和可惜 调出一道分块的较高难度的一道题（用了3小时以上） 原因是什么呢？经过各种造数据，对拍，二分错误位置，精确定位，精确数据分析后，终于发现是变量名写错了！ 原来写成了vector数组比较（怪不得一开始不但WA还TLE）。。 这种睿智的错误出一次不少时间就浪费掉，导致现在我还是机房垫底水平。。。 我们一起来看看这道题。 [Violet]蒲公英题目背景亲爱的哥哥： 你在那个城市里面过得好吗？ 我在家里面最近很开心呢。昨天晚上奶奶给我讲了那个叫「绝望」的大坏蛋的故事的说！它把人们的房子和田地搞坏，还有好多小朋友也被它杀掉了。我觉得把那么可怕的怪物召唤出来的那个坏蛋也很坏呢。不过奶奶说他是很难受的时候才做出这样的事的…… 最近村子里长出了一大片一大片的蒲公英。一刮风，这些蒲公英就能飘到好远的地方了呢。我觉得要是它们能飘到那个城市里面，让哥哥看看就好了呢！ 哥哥你要快点回来哦！ 爱你的妹妹 Violet Azure 读完这封信之后微笑了一下。 “蒲公英吗……” 题目描述在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。 为了简化起见，我们把所有的蒲公英看成一个长度为n的序列 (a_1,a_2..a_n)(a1,a2..an)，其中 a_iai 为一个正整数，表示第i棵蒲公英的种类编号。 而每次询问一个区间 [l,r]，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。 注意，你的算法必须是在线的 输入输出格式输入格式： 第一行两个整数 n,m ，表示有n株蒲公英，m 次询问。 接下来一行n个空格分隔的整数 a_iai ，表示蒲公英的种类 再接下来m 行每行两个整数 l_0,r_0l0,r0，我们令上次询问的结果为 x（如果这是第一次询问， 则 x=0）。 令 $l=(l_0+x-1)\bmod n + 1,r=(r_0+x-1) \bmod n + 1$，如果 l&gt;r，则交换 l,r 。 最终的询问区间为[l,r]。 输出格式： 输出m 行。每行一个整数，表示每次询问的结果。 输入输出样例123456 3 1 2 3 2 1 2 1 5 3 6 1 5 1231 2 1 说明对于 100% 的数据，保证 $1\le n \le 40000,1\le m \le 50000,1\le a_i \le 10^9$ 题解比起思路，我倒想记录下对于这种题该怎么综合调试。 首先，虽然题目要求强制在线，但如果你本地调试也“强制在线”，那就是个傻瓜。 然后对于这种暴力很好写的题，在发现程序出错后在15分钟内拼手速打出对拍加数据生成器。 拍出组你认为可调试的，比如对于这道题来说，n不要很大，不然实在难调，但是询问尽量多，可以更容易拍出错误的同时并不会增加调试难度。 对于出错的询问，就得看自己的观察力了。 说说这题的思路。 首先你需要先想到分块这种东西（想不到就爱莫能助了），发现一个区间是如何大段维护的，然后考虑怎么快速处理边角，这就是大体思路了。 Solve1首先说一个比较好想的。 离散化，必须的。 我们对序列分块，分T块。 枚举整块区间$O(T^2)$，对于每个整块区间，将每个数出现的次数都存起来，是一个$O(n)$的复杂度。顺便统计每个区间的众数。 上述预处理的过程时空复杂度均为$O(nT^2)$ 那么接下来我们如何处理每一个查询呢？设查询左右端点为$l$，$r$. 一个众数要么是其中内嵌最大整块区间，要么是边角的数，我们就可用“大段维护，边角暴力”来解决这个问题了。 我们只需要把边角的数扔进最大整块区间的桶里，扔的时候注意及时判断，最后扫一遍肯定是不行的（讲真一开始我想如何快速统计众数就差点没从整个扫一遍中找出做法来） 然后回答询问，然后把边角的数减掉就行了。这样每次最多就是两块，也就是说每次$O(n/T)$ 这样做的时间复杂度是$O(nT^2+mn/T)$ 求导求拐点，算出最优T大概是$^3\sqrt{n}$ 此时空间复杂度可以接受，时间复杂度为$O(n^{\frac{5}{3}})$ 没错就是莫队复杂度。。 这也是我能想出来的解法了，让我们看一个更神仙的解法 solve2这次我们只处理出整段区间的众数。时间复杂度$O(nT)$ 然后$O(n)$把每个离散化的元素用个vector桶把每个元素的位置都push进去 讲真这种方法牛逼就牛逼在这个vector的灵活的应用，它使得我们可以以$O(logn)$的时间完成对任意元素在一个区间里出现的次数。 如何想到这种方法是一个很有意思的问题，其实想到边角快速处理就已经接近了，只不过这个确实挺难想到。 然后后面的就好办了，每次暴力查询边角更新答案即可。 时间复杂度$O(nT+mn/Tlogn)$ 这东西不是很会分析。。总之以后写分块定义两个变量，块大小和块数量，方便调块大小。 好像$T=\sqrt{nlogn}$取得最优值，为$O(n\sqrt{nlogn})$ 第一种实在简单没写，写了第二种，由于忘了调块大小，所以跑的很慢。。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define maxn 40005#define maxm 50005#define maxsqrt 205std::vector&lt;int&gt; pos[maxn];int n , m , base , lastans , tmp[maxn] , p[maxsqrt][maxsqrt] , c[maxsqrt][maxsqrt] , st[maxn] , L[maxn] , R[maxn] , v[maxn] , tot , b[maxn];struct Node&#123; int v, k; bool operator&lt;(const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;a[maxn];inline int find(const std::vector&lt;int&gt; &amp;val , int bndl , int bndr)&#123; int l = 0 , r = val.size() - 1 , ans1 = 0 , ans2 = 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(val[mid] &lt;= bndr) ans1 = mid , l = mid + 1; else r = mid - 1; &#125; l = 0 , r = val.size() - 1; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(val[mid] &gt;= bndl) ans2 = mid , r = mid - 1; else l = mid + 1; &#125; return ans1 - ans2 + 1;&#125;inline void pre()&#123; base = std::sqrt(n); for(int i = 1 ; i &lt;= base ; ++i) L[i] = (i-1) * base + 1, R[i] = i * base; if(R[base] &lt; n) ++base , L[base] = R[base-1] + 1 , R[base] = n; for(int i = 1 ; i &lt;= base ; ++i) for(int j = L[i] ; j &lt;= R[i] ; ++j) st[j] = i; std::sort(a+1,a+n+1); for(int i = 1 ; i &lt;= n ; ++i) &#123; if(a[i].v == a[i-1].v) v[a[i].k] = tot , b[tot] = a[i].v; else v[a[i].k] = ++tot , b[tot] = a[i].v; &#125; for(int i = 1 ; i &lt;= n ; ++i) pos[v[i]].push_back(i); for(int i = 1 ; i &lt;= base ; ++i) &#123; int now = 0 , ans = 0; std::memset(tmp,0,sizeof(tmp)); for(int j = i ; j &lt;= base ; ++j) &#123; for(int k = L[j] ; k &lt;= R[j] ; ++k)&#123; ++tmp[v[k]]; if(tmp[v[k]] &gt; now) now = tmp[v[k]] , ans = v[k]; else if(tmp[v[k]] == now &amp;&amp; v[k] &lt; ans) ans = v[k]; &#125; c[i][j] = now , p[i][j] = ans; &#125; &#125;&#125; inline int query(int l , int r)&#123; if(st[l] == st[r]) &#123; int ans = 0 , now = 0; for(int i = l ; i &lt;= r ; ++i) &#123; int cur = find(pos[v[i]] , l , r); if(cur &gt; now) now = cur , ans = v[i]; else if(cur == now &amp;&amp; v[i] &lt; ans) ans = v[i]; &#125;// printf("equal %d %d %d ",l,r,now); return ans; &#125; int posl = 0 , posr = 0; if(l != L[st[l]]) posl = L[st[l]+1]; else posl = l; if(r != R[st[r]]) posr = R[st[r]-1]; else posr = r; int ans = p[st[posl]][st[posr]] , now = c[st[posl]][st[posr]]; for(int i = l ; i &lt; posl ; ++i) &#123; int curnow = find(pos[v[i]] , l , r); if(curnow &gt; now)&#123; now = curnow , ans = v[i]; &#125; else if(curnow == now &amp;&amp; v[i] &lt; ans) ans = v[i]; &#125; for(int i = posr + 1 ; i &lt;= r ; ++i)&#123; int curnow = find(pos[v[i]] , l , r); if(curnow &gt; now)&#123; now = curnow , ans = v[i]; &#125; else if(curnow == now &amp;&amp; v[i] &lt; ans) ans = v[i]; &#125;// printf("NONEQUAL %d %d %d ",l,r,now); return ans;&#125;int main()&#123;// freopen("data.in","r",stdin);// freopen("my.out","w",stdout); scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;a[i].v) , a[i].k = i; pre(); while(~--m) &#123; int l , r; scanf("%d%d",&amp;l,&amp;r); l = (l + lastans - 1) % n + 1 , r = (r + lastans - 1) % n + 1; if(l &gt; r) std::swap(l,r); printf("%d\n",lastans = b[query(l,r)]); &#125;&#125; 看到篇不错的文章，作者省队水平？ https://czyhe.me/other/other/noip-mess/ 开始学文化课。。 一定要明白如何解决下面这个问题： 给定一个序列长度为$n$，如何快速查找$m$次某一元素值在一个区间内出现的次数。$n,m \leq 100000$ 方法是将序列离散化（如果值过大），然后用vector数组的下标当桶映射元素值，将每个元素的位置从左到右push进元素值相应的vector里，不难发现任意vector的下标都是从左到右递增的，因此可以分治查找。 时间复杂度$O((n+m)logn)$]]></content>
      <tags>
        <tag>根号算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 24]]></title>
    <url>%2F2018%2F12%2F18%2F2018.12.18%2F</url>
    <content type="text"><![CDATA[导言：Po主最近太懒，状态太差，不想Coding….. 希望自己能早点找回原来精力充沛的状态。。 话说感觉这次月考稳定1000+名啊，无话可说，智商硬伤。。 点分治略解我们来抽象一点描述（好掩盖不会的事实.?） 对于一类树上路径统计问题，我们在选取任意一点p为根后，发现路径可以分为这样的两类：过p和不过p的，然后就可以递归分治。在我们每次选取树的重心的情况下可以证明递归层数是$logn$层。 每一层一般处理的时候需要一个较高效的统计方法，一般是$O(nlogn)$或$O(n)$的。 略解就到这里233. 分块初步（终于写了道题，结果调了半天） 分块是一种根号算法，主要是利用根号平衡的思想均摊每项操作的复杂度。 操作上很简单，自己体会下“大段维护，小段朴素”的思想自己yy出代码并不难。 不过就是边界情况容易漏掉就是了。。我调了一个小时区间加就是因为忘了查询修改可以在同一块，必须特殊处理。。 上道模板题 A Simple Problem with IntegersYou have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.InputThe first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.Each of the next Q lines represents an operation.“C a b c“ means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.“Q a b“ means querying the sum of Aa, Aa+1, … , Ab.OutputYou need to answer all Q commands in order. One answer in a line. Sample Input10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output4 55 9 15HintThe sums may exceed the range of 32-bit integers. 题解懒得调格式了，总之就是区间加。 上分块代码，主要就是记录序列每个位置是哪个块，以及当前块的左右端点就可以轻松维护啦。 写的挺长的。。。可能是我姿势不对 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 100005int n , m , L[maxn] , R[maxn] , pos[maxn] , st;long long s[maxn&gt;&gt;3] , tag[maxn&gt;&gt;3] , a[maxn];inline void pre()&#123; st = std::sqrt(n); for(int i = 1 ; i &lt;= st ; ++i) L[i] = (i-1)*st+1 , R[i] = i * st; if(R[st] &lt; n) ++st , L[st] = R[st-1] + 1 , R[st] = n; for(int i = 1 ; i &lt;= st ; ++i) for(int j = L[i] ; j &lt;= R[i] ; ++j) pos[j] = i , s[i] += a[j];&#125;inline long long query(int l , int r)&#123; long long ans = 0; if(pos[l] == pos[r]) // special situation &#123; int p = pos[l]; for(int i = L[p] ; i &lt;= R[p] ; ++i) a[i] += tag[p]; tag[p] = 0; for(int i = l ; i &lt;= r ; ++i) ans += a[i]; return ans; &#125; if(l != L[pos[l]]) &#123; for(int i = L[pos[l]] ; i &lt;= R[pos[l]] ; ++i) a[i] += tag[pos[l]]; tag[pos[l]] = 0; for(int i = l ; i &lt;= R[pos[l]] ; ++i) ans += a[i]; l = L[pos[l] + 1]; &#125; if(r != R[pos[r]]) &#123; for(int i = L[pos[r]] ; i &lt;= R[pos[r]] ; ++i) a[i] += tag[pos[r]]; tag[pos[r]] = 0; for(int i = L[pos[r]] ; i &lt;= r ; ++i) ans += a[i]; r = R[pos[r] - 1]; &#125; for(int i = pos[l] ; i &lt;= pos[r] ; ++i) ans += s[i]; return ans;&#125;inline void update(int l , int r , int v)&#123; if(pos[l] == pos[r]) &#123; for(int i = l ; i &lt;= r ; ++i) a[i] += v; s[pos[l]] += 1ll * (r - l + 1) * v; return ; &#125; if(l != L[pos[l]]) &#123; for(int i = l ; i &lt;= R[pos[l]] ; ++i) a[i] += v , s[pos[i]] += v; l = L[pos[l]+1]; &#125; if(r != R[pos[r]]) &#123; for(int i = L[pos[r]] ; i &lt;= r ; ++i) a[i] += v , s[pos[i]] += v; r = R[pos[r]-1]; &#125; for(int i = pos[l] ; i &lt;= pos[r] ; ++i) s[i] += 1ll * (R[i] - L[i] + 1) * v , tag[i] += v;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;a[i]); pre(); while(~--m) &#123; int l , r; char op; scanf("\n%c%d%d",&amp;op,&amp;l,&amp;r); if(op == 'C') &#123; int v; scanf("%d",&amp;v); update(l , r, v); &#125; else if(op == 'Q') printf("%lld\n",query(l,r)); &#125;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Picture Post]]></title>
    <url>%2F2018%2F12%2F17%2F%E4%B8%8D%E6%AD%A3%E7%BB%8F%E7%9A%84Post%2F</url>
    <content type="text"><![CDATA[这是一篇不正经的Post。。 主要用来记录各种]]></content>
      <tags>
        <tag>images</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 23]]></title>
    <url>%2F2018%2F12%2F17%2F2018.12.17%2F</url>
    <content type="text"><![CDATA[刚刚做了到sb题，结果没过（probset的第一题）。。。感觉自己做思路不难但是细节巨多的题的能力真是很弱，可能每个选手都有擅长的方面吧（不像我） 然后看到一篇NOI.AC系列比赛题解的Post，就看了看，感觉作者最起码是省队水准。。场场前10qwq 我打的时候能切一道题就不错了 突然发现博主的名字首字母在blog名里，一查是个金牌爷。。。 真可怕。。怪不得每道题没做出完全正解都有接近正解复杂度的思路。。 哦，突然发现他说他是GX的，那也是个初三省队，高一银牌爷qwq 唉。。。 而且我感觉我记忆力最近真是极差无比，这是咋回事啊，我每天休息的都挺好啊。。 看道题。 Delete题目大意： 一个长为$n$ 的序列A ，要删去其中恰好$k$ 个数，使得剩下的数中，$A_i=i$ （权值和下标相等）的元素数量最多，求这个最多的数量。 题解以前不怎么懂偏序类的问题。 这道题真的是一道思维难度挺大的题。 然后我一开始愣是没看懂银牌爷的思路： 然后我自己想到一个推理的方法：我们能够得到其删完数后的位置$2i-A_i$ 那么我们有对于$i&lt;j$ $A_i &lt; A_j$(显然，不可能后面的数能到选中的前面的位置) $A_j-A_i \leq j-i$（表明删前两数位置之差必须大于等于删后位置的差,不可能越删越多吧。。） 看上去可以直接二维偏序，但是题目要求有个k。 然后就不会了，找到官方题解，发现题解根本没管这个k？？然后我去看了看别人的代码，发现关于k的只有一行： 1if (a[i].w &gt;= 0 &amp;&amp; a[i].w &lt;= k &amp;&amp; n - a[i].a &gt;= k) &#123; 然后我好像懂了，因为前面删除的数对于后面也相当于删除，所以只要当前这个数删除的元素小于等于$k$并且它的目标位置大于等于$k$就可以了。 然后我发现上面那个思路我也看懂了，这道题大概是懂了吧。主要是找到偏序关系。是道好题。 思路题不用代码。 看到个很牛逼的，以后也许会用到的资料？https://blog.csdn.net/lemonoil/article/details/54405613 可能到时候学替罪羊树SBT看看这个，红黑树AVL是不可能的。。 blog主水平还是很不错的，虽然最后联赛遗憾退役。 感觉看一些有决赛水平的人的blog确实很有帮助，尤其是看到他们思维的闪光点。 然后去看了看NOWCODER和51Nod的题，感觉Wannafly和51Nod数学相关（得等我学习数学相关后啦）的题目质量很不错，以后也会做一些。 然后复习下可持久化与Splay的各种维护，开始学习一下基于值域的整体分治（好像就是整体二分）了。 以后做思维题主要： POI noi.ac和nowcoder的各种比赛（联赛前没看到noi.ac又办了那么多次模拟赛巨亏） 就酱。]]></content>
      <tags>
        <tag>CDQ 思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 22]]></title>
    <url>%2F2018%2F12%2F16%2F2018.12.16%2F</url>
    <content type="text"><![CDATA[我们总是东张西望，唯独漏了自己想要的，这就是我们至今难以如愿以偿的原因。 有时候我们需要单点修改区间查询的小常数线段树，这就是zkw线段树。 zkw整个学习时间不超过5分钟。 zkw线段树学习笔记Note：注意使用位运算优化常数。 zkw线段树建树的方式就是首先输入叶子结点的信息然后再一路向上传递信息，直到根结点。这时问题又来了….Where is the first leaf？？？我怎么找到第一个叶子在哪？假设我们的单点数量（叶子数量）正好是 $2^k$ ，那么我们手里就握着一个满二叉树了，这样我们就能轻松地计算出来第一个结点的位置是： $2^{k}$ 。但是如果不是满二叉树怎么办呢？没有关系，现在的电脑内存不是问题！直接开成满二叉树就好啦~~。这样一来，第一个叶子结点的位置就是： $2^k+1(k=\lceil\log_2N\rceil)$ (见代码下的解释)，也就是比 大的最小的 $2^k$。找到叶子结点之后，直接输入叶子结点信息，然后一个一个结点上传信息到父亲结点。于是我们得到了这样的代码： 123456789inline void Maintain(int x) &#123; tree[x] = tree[x&lt;&lt;1] + tree[x&lt;&lt;1|1];&#125;inline void Build() &#123; for(M=1;M&lt;N;M&lt;&lt;=1); for(int i=M+1;i&lt;=M+N;++i) scanf("%d", &amp;tree[i]); for(int i=M-1;i;--i) Maintain(i);&#125; 简洁明了，注意从M+1开始比较好 NOTICE：看到评论中很多朋友问为什么要在 $M+1$ 处开始输入。我这里统一解释一下，评论中我所说的也有问题(这里说声抱歉，昨天一天都在路上，没有时间思考….)，以文章此处为标准好啦。 建议先看完下一节（区间和计算）再来看此处有助于理解。从 $M+1$开始是为了进行区间查询。 假设我们查询的区间就是 ，这时为了进行查询我们会将 转换为 ，看上去没有区别，其实是有区别的。由于位于 上的数字是否能被统计上与左端点位置相关$L=M+1-1=M$，如果从 开始输入会导致查询时统计不到位于 上的信息，因为 初始位置就是第一个叶子的位置了$L=M$ .. 但是如果换成 开始，查询时 的位置依旧是 $L=M+1-1=M$ ，但是第一个叶子的位置在 $M+1 $上，这样就能够统计到那个叶子上的信息啦。因此要从 $M+1 $ 开始输入信息。 更新操作不难，就是直接找到叶子然后向上pushup即可 12345inline void Update(int pos,int v) &#123; pos += M; tree[pos] = v; for(pos&gt;&gt;=1;pos;pos&gt;&gt;=1) Maintain(pos);&#125; 接下来是略有难度的区间查询 我们需要把L,R分别向左向右一个位置，然后查询。 Q：为什么？ Ans：就是得这样啊。。不然你端点开始就查错了。查询原理如下： 当遇到区间和查询时，问题双来了….传统线段树通过递归查询需要加和的区间最后统计所有的和，但是Zkw线段树….没法从顶上找到需要加和的区间啊QwQ….怎么办呢？但是换个方向思考…从底向上，查询区间为 $[L,R]$，我们只能知道当前区间是否在查询区间内，即：如果当前查询区间左端点 $L$向结点是线段树某个结点的左儿子且 $R-1 \ne L$(即右端点指向结点不是左端点指向结点的兄弟)，那么它的兄弟结点$ L+1$ 必然在查询区间内。同理，如果 $R$所指向结点的兄弟结点不是$L$，那么它的兄弟结点必然包含在查询区间内。如图： 讲真这个东西确实不是很自然，主要是考虑$1$~$n$查询，其边界这样做依旧正确，就行了。 123456789101112inline int Sum(int l,int r) &#123; int ans = 0; // l=l+M-1-&gt;将查询区间改为L-1，r=r+M+1-&gt;将查询区间改为R+1 // l^r^1 -&gt; 相当于判断l与r是否是兄弟节点 for(l=l+M-1,r=r+M+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1) &#123; if(~l&amp;1) // l % 2 == 0 即l是l/2的左儿子 ans += tree[l^1]; if(r&amp;1) // r % 2 == 1 即r是r/2的右儿子 ans += tree[r^1]; &#125; return ans;&#125; 这样zkw线段树就基本上介绍完毕了，可以试试优化天使玩偶了！ 果然依靠zkw线段树在72秒内跑过了 不过还要在想想zkw的各种边界。 AC code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 500005#define maxv 1000005#define INF 0x7ffffffint ans[maxn&lt;&lt;1] , n , m , seg[maxv&lt;&lt;2] , mx , base;inline void pushup(int x)&#123; seg[x] = std::max(seg[x&lt;&lt;1] , seg[x&lt;&lt;1|1]);&#125;inline void build()&#123; for(base = 1 ; base &lt; mx ; base &lt;&lt;= 1); for(int i = base ; i &lt;= base + mx ; ++i) seg[i] = -INF; for(int i = base - 1; i ; --i) seg[i] = -INF;&#125;inline void update(int pos , int v)&#123; pos += base; seg[pos] = v; for(pos &gt;&gt;= 1; pos ; pos &gt;&gt;= 1) pushup(pos);&#125;inline int query(int L , int R)&#123; int ans = -INF; for(int l = L + base - 1 , r = R + base + 1 ; l ^ r ^ 1 ; l &gt;&gt;= 1 , r &gt;&gt;= 1) &#123; if(~l&amp;1) ans = std::max(ans , seg[l^1]); if(r&amp;1) ans = std::max(ans , seg[r^1]); &#125; return ans;&#125;struct Node&#123; int x , y , ty ,num; bool operator&lt;(const Node&amp; k)const&#123; if(x == k.x) return ty &lt; k.ty; return x &lt; k.x; &#125;&#125;q[maxn&lt;&lt;1] , tmp[maxn&lt;&lt;1];bool cmp(const Node&amp; a , const Node&amp; b)&#123; if(a.x == b.x) return a.ty &lt; b.ty; return a.x &gt; b.x;&#125;inline void solve(int l , int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; solve(l , mid); solve(mid + 1, r); for(int i = l ; i &lt;= r ; ++i) tmp[i] = q[i]; std::sort(tmp+l,tmp+r+1); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , tmp[i].x + tmp[i].y); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , tmp[i].x + tmp[i].y - query(0 , tmp[i].y)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , -INF); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , tmp[i].x - tmp[i].y); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , tmp[i].x - tmp[i].y - query(tmp[i].y,mx)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , -INF); std::sort(tmp+l,tmp+r+1,cmp); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , tmp[i].y-tmp[i].x); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , tmp[i].y-tmp[i].x-query(0,tmp[i].y)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , -INF); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , -tmp[i].y-tmp[i].x); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , -tmp[i].x-tmp[i].y-query(tmp[i].y , mx)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , -INF);&#125;inline int read()&#123; register int x = 0; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') ch = getchar(); while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x&lt;&lt;3)+(x&lt;&lt;1) + ch - 48 , ch = getchar(); return x;&#125;int main()&#123; std::memset(ans,0x7f,sizeof(ans)); n = read() , m = read(); for(int i = 1 ; i &lt;= n ; ++i)&#123; q[i].x = read() , q[i].y = read() ,q[i].num = i , q[i].ty = 1 , mx = std::max(mx , q[i].x) , mx = std::max(mx , q[i].y); &#125; for(int i = 1 ; i &lt;= m ; ++i) q[n+i].ty = read() , q[n+i].x = read() , q[n+i].y = read() ,q[i+n].num = n+i, mx = std::max(mx , q[n+i].x) , mx = std::max(mx , q[n+i].y); ++mx; build(); solve(1,n+m+1); for(int i = 1 ; i &lt;= n + m ; ++i) if(q[i].ty == 2) printf("%d\n",ans[i]); return 0;&#125; 刚刚又去研究了下zkw线段树，发现比如它维护长度为5的序列，如果你画图会发现这颗线段树每个节点向下不再是中点二分维护区间了，比如上述就是根的左子节点维护1~4，右子节点维护5，但是无论是正确性还是时间复杂度都没有问题，因此对于这种数据结构的研究也就到此为止了。 开始复习点化学到9点。。。]]></content>
      <tags>
        <tag>zkw线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 21]]></title>
    <url>%2F2018%2F12%2F14%2F2018.12.14%2F</url>
    <content type="text"><![CDATA[菜是原罪，有bb,感叹人生以及给自己打气的时间不如现在就清楚的意识到自己是个渣渣的本质 然后去刷几道题来提升一下你本来就没多少的水平 — shadowice1984 今天脑子清醒了点，开始做题。 BZOJ2716. [Violet 3]天使玩偶DESCRIPTION Input Output 题解昨天看过这道题，结果由于太颓没有写完。 显然在纸上分类讨论四个象限后用线段树维护区间最值，然后CDQ分治即可。 感觉CDQ分治真的不是什么难东西啊，就是基础分治的思想而已。 简单来说就是每次递归然后用静态算法比如扫描线之类的去处理问题，复杂度昨天分析了。。。。 因此这道题可以在$O((n+m)log^2(n+m))$的时间里解决 上理论可以AC但实际卡常的代码。。换权值成树状数组维护前缀最大值或者换成对结构体基数排序应该都能AC。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 500005#define maxv 1000005#define INF 0x7ffffffint ans[maxn&lt;&lt;1] , n , m , seg[maxv&lt;&lt;2] , mx;inline void pushup(int x)&#123; seg[x] = std::max(seg[x&lt;&lt;1] , seg[x&lt;&lt;1|1]);&#125;void update(int pos , int l , int r , int v , int node)&#123; if(l == r)&#123; seg[node] = v; return; &#125; int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) update(pos , l , mid , v , node &lt;&lt; 1); else update(pos , mid + 1 , r , v , node &lt;&lt; 1 | 1); pushup(node);&#125;int query(int l , int r , int L , int R , int node)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return seg[node]; int mid = l + r &gt;&gt; 1 , ans = -0x7ffffff; if(L &lt;= mid) ans = std::max(ans , query(l , mid , L , R , node &lt;&lt; 1)); if(R &gt; mid) ans = std::max(ans , query(mid + 1 , r , L , R , node &lt;&lt; 1|1)); return ans;&#125;struct Node&#123; int x , y , ty ,num; bool operator&lt;(const Node&amp; k)const&#123; if(x == k.x) return ty &lt; k.ty; return x &lt; k.x; &#125;&#125;q[maxn&lt;&lt;1] , tmp[maxn&lt;&lt;1];bool cmp(const Node&amp; a , const Node&amp; b)&#123; if(a.x == b.x) return a.ty &lt; b.ty; return a.x &gt; b.x;&#125;inline void solve(int l , int r)&#123; if(l == r) return; int mid = l + r &gt;&gt; 1; solve(l , mid); solve(mid + 1, r); for(int i = l ; i &lt;= r ; ++i) tmp[i] = q[i]; std::sort(tmp+l,tmp+r+1); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , tmp[i].x + tmp[i].y , 1); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , tmp[i].x + tmp[i].y - query(0 , mx , 0 , tmp[i].y , 1)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , -INF , 1); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , tmp[i].x - tmp[i].y , 1); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , tmp[i].x - tmp[i].y - query(0,mx,tmp[i].y,mx,1)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , -INF , 1); std::sort(tmp+l,tmp+r+1,cmp); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , tmp[i].y-tmp[i].x , 1); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , tmp[i].y-tmp[i].x-query(0,mx,0,tmp[i].y,1)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , -INF , 1); for(int i = l ; i &lt;= r ; ++i) &#123; if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , -tmp[i].y-tmp[i].x , 1); else if(tmp[i].ty == 2 &amp;&amp; tmp[i].num &gt; mid) ans[tmp[i].num] = std::min(ans[tmp[i].num] , -tmp[i].x-tmp[i].y-query(0 , mx , tmp[i].y , mx , 1)); &#125; for(int i = l ; i &lt;= r ; ++i) if(tmp[i].ty == 1 &amp;&amp; tmp[i].num &lt;= mid) update(tmp[i].y , 0 , mx , -INF , 1);&#125;inline int read()&#123; register int x = 0; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') ch = getchar(); while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x&lt;&lt;3)+(x&lt;&lt;1) + ch - 48 , ch = getchar(); return x;&#125;int main()&#123; std::memset(ans,0x7f,sizeof(ans)); n = read() , m = read(); for(int i = 0 ; i &lt;= (1000000&lt;&lt;2);++i) seg[i] = -INF; for(int i = 1 ; i &lt;= n ; ++i)&#123; q[i].x = read() , q[i].y = read() ,q[i].num = i , q[i].ty = 1 , mx = std::max(mx , q[i].x) , mx = std::max(mx , q[i].y); &#125; for(int i = 1 ; i &lt;= m ; ++i) q[n+i].ty = read() , q[n+i].x = read() , q[n+i].y = read() ,q[i+n].num = n+i, mx = std::max(mx , q[n+i].x) , mx = std::max(mx , q[n+i].y); ++mx; solve(1,n+m+1); for(int i = 1 ; i &lt;= n + m ; ++i) if(q[i].ty == 2) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two-Week Post 2]]></title>
    <url>%2F2018%2F12%2F14%2FTwo%20Week%20Post%202%20On%2020181214%2F</url>
    <content type="text"><![CDATA[Welcome here Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 20]]></title>
    <url>%2F2018%2F12%2F13%2F2018.12.13%2F</url>
    <content type="text"><![CDATA[人生最遗憾的莫过于，轻易地放弃了不该放弃的，固执地坚持了不该坚持的。 这次真的下定决心不用luogu了。。题意翻译不清，社区平均质量低下。。实在令人很生气！(可千万别几天后又用的美滋滋) 貌似今天什么都没做，仅仅是又思考了下Splay一道题和一道貌似是树上贪心的题目，还没写。。 基于时间的分治算法-CDQ分治对于一些的数据结构题，我们可以把每个询问视为初始数据与询问之前的修改对这个询问所做的影响。 这样我们就可以高效的解决一些问题。 设$solve(l,r)$能够处理$l$~$r$内的操作，那么我们可以通过如下递归分治来解决： 递归计算$solve(l,mid)$ 递归计算$solve(mid+1,r)$ 计算左边的修改对右边的询问的影响 假设第三步的复杂度是$O(f(n))$，显然整个算法的复杂度就是$O(f(n)logn)$ 比如说求逆序对的归并排序其实就是一种CDQ分治（我是这么想的）。 我看到一个描述挺清晰的CDQ讲解，如下： CDQ分治 查询的限制——序 对于一个数据结构题而言（或者需要运用数据结构的地方），我们无非就是做两件操作，一是修改，二是查询对于修改而言，有插入，删除，变更（其实等价于删除再插入）这几种方式那么查询的本质是什么呢我们思考所遇到过的数据结构题，可以发现查询实际上就在做一件事情：把符合本次查询的限制的修改对答案产生的效果合并起来满足这种限制通常表现为一种序的要求，并且这种序是广义的，符合限制的操作往往是按某种序（或多种序）排序后的操作的前缀通常来说,查询一定有时间上的限制,也就是要求考虑发生在某个时刻之前的所有查询,对于一个问题而言,假如所有查询要求的发生时刻相同,那这就是一个静态查询问题,如果要求发生的时刻随着查询而变,那这就是一个动态修改问题,动态修改问题较静态查询而言复杂很多,往往需要高级数据结构,可持久化等手段,而静态查询简单很多,例如时间倒流,twopointers之类的方法都是很好的选择 动态修改-&gt;静态查询 CDQ分治算法的核心就在于:去掉时间的限制,将所有查询要求发生的时刻同化,化动态修改为静态查询(其实对于有些问题来说可以把某一维的限制通过排序看作时间限制然后运用CDQ分治)我们记过程$DivideConquer(l,r)$表示处理完$[l,r]$内的修改对查询的影响此时我们引入分治思想,将操作序列划分为$[l,mid]$,$[mid+1,r]$两个区间这两个区间内部的修改对区间内部的查询的影响是完全相同的子问题,我们递归处理处理完之后剩下来只要考虑$[l,mid]$中的修改对$[mid+1,r]$中的查询的影响这时我们发现这其实已经变成了一个静态查询问题,因为所有的查询都发生在修改之后,我们只需要考虑静态查询的问题如何处理即可 介绍就到这里，举出一道例题。 [Violet 3]天使玩偶Description.gif) Input.gif) Output.gif) Hint.gif) 题解DARKBZOJ是个好东西。 这道题我们对于每个询问最好分类讨论。 对于左上角的我们可以把每个询问转换成$(x+y)-(x_p+y_p)_{max}$ 并且要求$x_p&lt;x$ , $y_p&lt;y$ 其他三部分同理可得。 那么我们把最初的n个点看成n个添加操作，对于这个长度为$(n+m)$的操作序列进行CDQ分治。 显然递归边界就是只有一个的情况，直接返回即可（询问会被之前的修改更新，不用管）。 然后这道题就变得非常简单了啊，用线段树（或者树状数组）维护前缀最大最小值，然后分类讨论坐标即可。 Code明天再写，今天状态实在太差，明天上午最后三节课解决这个问题。]]></content>
      <tags>
        <tag>Splay 可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 19]]></title>
    <url>%2F2018%2F12%2F12%2F2018.12.12%2F</url>
    <content type="text"><![CDATA[Because of love, even if it hurts to the extreme, we will not be old. 去zyf学姐的blog转了转，找到她在这个时候做的题去做了做，感觉还OK。 然后看到一道二维树状数组的题，就写了写，不过树状数组还是原理重要，显然实现非常简单 BZOJ 1452: [JSOI2009]CountDescription一个N*M的方格，初始时每个格子有一个整数权值，接下来每次有2个操作: 改变一个格子的权值 求一个子矩阵中某个特定权值出现的个数 Input每一行有两个数字N，M 接下来N行，每行M个数字。第i+1行第j个数字表示格子(i,j)的初值 接下来输入一个Q，后面Q行每行描述一个操作 操作1: $1$ x y c，表示将格子(x,y)的值变为c 操作2: $2 ~x1~ x2~ y1~ y2~ c$，表示询问所有满足格子中数字为c的格子数字 $(n,m&lt;=300,Q&lt;=5000)$ $(1&lt;=x&lt;=N,1&lt;=y&lt;=M,1&lt;=c&lt;=100)$ $(x1&lt;=x&lt;=x2,y1&lt;=y&lt;=y2)$ Output对于每个操作2,按输入中出现的顺序，依次输出一行一个整数表示所求得的个数 Sample Input3 3 1 2 3 3 2 1 2 1 3 3 2 1 2 1 2 1 1 2 3 2 2 2 3 2 3 2 Sample Output1 2 题解单点修改，查询特定值，较少的询问次数与很小的值域使得这道题目没有任何的难度。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/************************************************************** Problem: 1452 User: RBZNO1 Language: C++ Result: Accepted Time:4592 ms Memory:39808 kb****************************************************************/ #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 305#define maxk 105int s[maxn][maxn] , tr[maxk][maxn][maxn] , n , m , q;inline int query(int t , int x , int y)&#123; int ans = 0; if(!x || !y) return ans; for(int i = x ; i ; i -= i &amp; -i) for(int j = y ; j ; j -= j &amp; -j) ans += tr[t][i][j]; return ans;&#125;inline void insert(int val , int x , int y, int v)&#123; for(int i = x ; i &lt;= n; i += i &amp; -i) for(int j = y ; j &lt;= m ; j += j &amp; -j) tr[val][i][j] += v; return;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) scanf("%d",&amp;s[i][j]) , insert(s[i][j] , i , j , 1); scanf("%d",&amp;q); for(int i = 1 ; i &lt;= q ; ++i) &#123; int op; scanf("%d",&amp;op); if( op == 2 ) &#123; int x1 , x2 , z1 , z2 , val; scanf("%d%d%d%d%d",&amp;x1,&amp;z1,&amp;x2,&amp;z2,&amp;val); int a1 = query(val, z1,z2) , a2 = query(val , z1, x2 - 1) , a3 = query(val , x1 - 1 , z2) , a4 = query(val , x1 - 1 , x2 - 1); printf("%d\n",a1-a2-a3+a4); &#125; else if(op == 1)&#123; int x , y , v; scanf("%d%d%d",&amp;x,&amp;y,&amp;v); insert(s[x][y] , x , y , -1); s[x][y] = v; insert(s[x][y] , x , y , 1); &#125; &#125;&#125; 序列终结者题目背景网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量…… 这样我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。 这道题目就叫序列终结者吧。 题目描述给定一个长度为N的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作： 将[L,R][L,R]这个区间内的所有数加上VV。 将[L,R][L,R]这个区间翻转，比如1 2 3 4变成4 3 2 1。 求[L,R][L,R]这个区间中的最大值。 最开始所有元素都是00。 输入输出格式输入格式： 第一行两个整数N，M。M为操作个数。 以下M行，每行最多四个整数，依次为K，L，R，V。K表示是第几种操作，如果不是第1种操作则K后面只有两个数。 输出格式： 对于每个第3种操作，给出正确的回答。 输入输出样例输入样例#1： 123454 41 1 3 21 2 4 -12 1 33 2 4 输出样例#1： 12 说明$N \le 50000,M \le 100000N≤50000,M≤100000。$ 题解这道题调了4个小时。。一道仅仅是Splay扩展了一点的题。 显然还是要充分灵活运用懒标记来维护区间信息。 我们这次换一种简单点的建树方式，直接让节点编号等于下标（显然这随意） 假设我们成功将区间放在根的右孩子的左子树，下面让我们想想如何完成区间操作 显然可以只在根节点打懒标记！只要我们从上面访问到这个节点我们就下推标记，在旋转的时候我们就上传标记。这样既保证复杂度又保证正确性（因为假如树的形态没变，整个子树相对关系没变，进行完全操作是在浪费时间，完全可以等查询的需要时在进行操作，但是假如这个点被访问，并且之后会发生旋转等操作，那么需要下推哦） 同理向上旋转的时候必须pushup。 Splay的懒标记应用非常重要，因此Splay可以支持一切线段树支持的操作，并且支持更高级的一些操作比如区间插入，区间删除等等。 常数较大。 最关键也是坑我4小时的地方是：0号节点在pushup中是存在的（除非你一堆特判），必须赋成-INF！！！！ 还有根的右儿子和根节点不需要pushup。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005#define ls s[node][0]#define rs s[node][1]#define INF 0x7ffffff#define _DEBUG puts("DEBUG") , print(root);int s[maxn][2] , f[maxn] , sz[maxn] , id[maxn] , add[maxn] , rev[maxn] , mx[maxn] , v[maxn] , a[maxn] , root , tot , n , m;inline void pushdown(int node)&#123; if(add[node]) &#123; if(ls) add[ls] += add[node] , mx[ls] += add[node] , v[ls] += add[node]; if(rs) add[rs] += add[node] , mx[rs] += add[node],v[rs] += add[node]; add[node] = 0; &#125; if(rev[node] ) &#123; if(ls) rev[ls] ^= 1 ; if(rs) rev[rs] ^= 1; rev[node] = 0; std::swap(ls, rs); &#125;&#125;inline void pushup(int node)&#123; mx[node] = std::max(v[node] , std::max(mx[ls] , mx[rs])); sz[node] = sz[ls] + sz[rs] + 1;&#125;inline int get(int x)&#123; return s[f[x]][1] == x;&#125;inline void rotate(int node)&#123; int fx = f[node] , ffx = f[fx] , son = get(node); s[fx][son] = s[node][son^1] , f[s[node][son^1]] = fx; s[node][son^1] = fx , f[fx] = node; f[node] = ffx; if(ffx) s[ffx][s[ffx][1] == fx] = node; pushup(fx) , pushup(node);&#125;inline void splay(int node , int pos)&#123; for(int fx ; (fx = f[node]) != pos ; rotate(node)) if(f[fx] != pos) rotate(get(node) == get(fx)? fx : node); if(!pos) root = node;&#125;void build(int l , int r , int&amp; node , int fa) &#123; if(l &gt; r) return; int mid = l + r &gt;&gt; 1 ; node = mid; v[node] = a[mid]; f[node] = fa; build(l , mid - 1 , ls , node); build(mid + 1 , r , rs , node); pushup(node);&#125;inline int find(int x)&#123; int node = root; while(node) &#123; pushdown(node); if(sz[ls] &gt;= x) node = ls; else&#123; x -= sz[ls] + 1; if(!x) return node; node = rs; &#125; &#125; return -1;&#125;inline int split(int l , int r)&#123; int fl = find(l) , fr = find(r + 2); splay(fl , 0); splay(fr , fl); return s[s[root][1]][0];&#125;inline void Add(int l , int r, int val)&#123; int node = split(l , r); add[node] += val; v[node] += val; mx[node] += val;&#125;inline void Reverse(int l , int r)&#123; int node = split(l , r); rev[node] ^= 1;&#125;inline int queryMax(int l , int r)&#123; return mx[split(l,r)];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); a[1] = a[n+2] = mx[0] = -INF; build(1,n + 2 , root , 0); for(int i = 1 ; i &lt;= m ; ++i) &#123; int k; scanf("%d",&amp;k); if(k == 1)&#123; int l ,r , t; scanf("%d%d%d",&amp;l,&amp;r,&amp;t); Add(l , r , t); &#125; else if(k == 2)&#123; int l ,r ; scanf("%d%d",&amp;l,&amp;r); Reverse(l , r); &#125; else &#123; int l , r; scanf("%d%d",&amp;l,&amp;r); int ans = queryMax(l,r); printf("%d\n",ans); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Fenwick_Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 18]]></title>
    <url>%2F2018%2F12%2F11%2F2018.12.11%2F</url>
    <content type="text"><![CDATA[从不依靠，从不寻找，非常沉默，非常骄傲。 Splay区间翻转显然在Post 17Splay基本操作讲清楚了，又有如下几个问题 求x的前驱其实就是求x的左子树的最右边的一个结点，后继是求x的右子树的左边一个结点（想一想为什么？） 答案非常简单，如果我们把x先插入旋转到根上，左子树全部不大于x，右子树全部不小于x，左子树最右边节点保证在左子树内最大，右子树最左边节点同理。不大于x的最大值与不小于x的最小值就是前驱后继的定义（不过有可能重复）。 为什么Splay提取一个区间是将区间左端点的前驱旋转至根，右端点后继旋转至根的右儿子，右儿子的左子树就是区间呢？ 这个问题非常重要，是区间操作的基本原理。 显然第一次旋转后左端点在根的右子树，第二次旋转后右端点在根的右儿子的左子树，在区间(L,R)内，任何一个节点既不能在根的左子树（BST性质，它们大于左端点），又不能在根的右儿子的右子树（同样不能大于右端点），因此整个闭区间所有节点都在根的右儿子的左子树内了！ 还有个我认为非常难证明的问题，就是为什么懒标记是正确的。。。线段树懒标记正确在于它的形态是不会发生改变的，显然每个节点代表了固定的区间。但是Splay显然作为子树的根的节点只是临时的，那会不会造成错误的标记呢？ 这个问题让我想了半天。实际上是这样的。考虑暴力Splay翻转区间是从根的右儿子的左儿子u开始，对于每个节点我们都交换左右子树，这相当于一组操作。显然只要我们没有访问一个点，它的子树交不交换并没有什么区别。也就是说我们没必要重复交换，只需要在访问的时候确保进行操作并下传标记即可。那么对于当前根，我们交换子树并给这个点打上标记，后面只要访问到这个点就下推标记并操作，这样确保每个该翻转的子树翻转了，也能优化复杂度（具体严格复杂度证明以后补上吧）。 总结一下这个问题就是：只要子树不旋转，这个子树的根就不pushdown，这其实就是懒标记的思想，尽管Splay不像线段树形态固定，只要遵循这一原则就一定不会出错。 上述问题都理解了的话，一遍写过Splay十分轻松（97行） 那么区间操作也不是很难了，我们只需要在提取的区间根节点交换左右儿子并打上懒标记即可。 献上我自己靠理解写的小常数Splay (⊙o⊙)。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005#define INF 0x7ffffff#define ls s[node][0]#define rs s[node][1] int f[maxn] , s[maxn][2] , key[maxn] , val[maxn] , n , m , sz[maxn] , rev[maxn] , tot, root;inline void update(int node)&#123; if(node)&#123; sz[node] = 1; sz[node] += sz[ls]; sz[node] += sz[rs]; &#125;&#125;inline void pushdown(int node)&#123; if(node &amp;&amp; rev[node]) &#123; rev[node] = 0; rev[ls] ^= 1; rev[rs] ^= 1; std::swap(ls , rs); &#125;&#125;inline int get(int node)&#123; return s[f[node]][1] == node;&#125;inline void rotate(int node)&#123; int fx = f[node] , ffx = f[fx] , son = get(node); s[fx][son] = s[node][son^1] , f[s[node][son^1]] = fx; f[node] = ffx ; if(ffx) s[ffx][s[ffx][1]==fx] = node; s[node][son^1] = fx , f[fx] = node; update(node) , update(fx) ;&#125;inline void splay(int x , int pos)&#123; for(int fx ; (fx = f[x]) != pos ; rotate(x)) if(f[fx] != pos) rotate((get(x) == get(fx))? fx : x); if(!pos) root = x;&#125;int build(int l , int r , int fx)&#123; if(l &gt; r) return 0; int mid = l + r &gt;&gt; 1 , node = ++tot; key[node] = val[mid]; f[node] = fx; ls = build(l , mid - 1 , node); rs = build(mid + 1 , r , node); update(node); return node;&#125;int find(int k)&#123; int node = root; while(node) &#123; pushdown(node); if(k &lt;= sz[ls]) node = ls; else&#123; k -= sz[ls] + 1; if(!k) return node; node = rs; &#125; &#125; return -1;&#125;void print(int node)&#123; pushdown(node); if(ls) print(ls); if(key[node] != -INF &amp;&amp; key[node] != INF) printf("%d ",key[node]); if(rs) print(rs);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); val[1] = -INF , val[n+2] = INF; for(int i = 2 ; i &lt;= n + 1 ; ++i) val[i] = i-1; root = build(1 , n + 2 , 0); while(~(--m)) &#123; int l , r; scanf("%d%d",&amp;l,&amp;r); int posl = find(l) , posr = find(r+2); splay(posl , 0); splay(posr , posl); rev[s[s[root][1]][0]] ^= 1; &#125; print(root);&#125; 接下来就继续学习进阶指南了。 感觉动力有点不足]]></content>
      <tags>
        <tag>Splay dp 可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 17]]></title>
    <url>%2F2018%2F12%2F09%2F2018.12.9%2F</url>
    <content type="text"><![CDATA[不管前方的路有多苦，只要走的方向正确，不管多么崎岖不平，都比站在原地更接近幸福。 可持久化线段树又名函数式线段树，是重要的数据结构之一。支持静态区间第k小。 主要思想就是能利用现有不变的节点就不开点，每次只会增加 log_2n个节点. 为了让BLOG看上去不是那么空，我们找几张图来理解一下 这张图应该很好懂每次插入。 主席树一个经典的运用是区间第k大问题。 显然它的内部结构是不变的，满足可减性。可以用差分来处理（减掉）左端点左边的。 又因为我们是把节点一个一个插进去的，因此对于每个前缀我们都能通过 root_i访问，就可以询问右端点。 现在我们知道如何确定在这个区间查询，然后在这个区间内如何用线段树查询区间第k大呢？ 很显然需要使用权值线段树，对于当前区间，我们记录每个值域节点有多少个数！假设查询到节点k，假如k的左节点的值大于k，就继续向左节点递归，否则递归右节点k-cnt。 和Treap是相似的。 还有一个奇怪的地方是离散化相同的值不能给相同的权排名，否则会WA 然后就可以上模板题了。 【模板】可持久化线段树 1（主席树）题目背景这是个非常经典的主席树入门题——静态区间第K小 数据已经过加强，请使用主席树。同时请注意常数优化 题目描述如题，给定N个正整数构成的序列，将对于指定的闭区间查询其区间内的第K小值。 输入输出格式输入格式： 第一行包含两个正整数N、M，分别表示序列的长度和查询的个数。 第二行包含N个正整数，表示这个序列各项的数字。 接下来M行每行包含三个整数l, r, kl,r,k , 表示查询区间[l, r][l,r]内的第k小值。 输出格式： 输出包含k行，每行1个正整数，依次表示每一次查询的结果 输入输出样例输入样例#1： 12345675 525957 6405 15770 26287 26465 2 2 13 4 14 5 11 2 24 4 1 输出样例#1： 12345640515770262872595726287 说明数据范围： 1 \leq N, M \leq 2\cdot 10^5,A_i]]></content>
      <tags>
        <tag>可持久化 Splay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 16]]></title>
    <url>%2F2018%2F12%2F08%2F2018.12.8%2F</url>
    <content type="text"><![CDATA[Your voice is full of beautiful memories we have yet to make. B Xor Sum链接： https://ac.nowcoder.com/acm/contest/272/B 来源：牛客网 题目描述 给定一棵n个点的树，每个点有权值。定义表示 到 的最短路径上，所有点的点权异或和。 对于，求所有的异或和。 输入描述:123第一行一个整数n。接下来n-1行，每行2个整数u,v，表示u,v之间有一条边。第n+1行有n个整数，表示每个点的权值。 输出描述:1输出一个整数，表示所有的异或和，其中。 示例1 输入1234541 21 31 41 2 3 4 输出15 备注: 题解这个题要注意是点权不是边权。。。这意味着LCA会被异或掉。。 所以不能两层前缀异或来做了。。我说我暴力怎么都不对。。 考虑每个点被经过了多少次！ 由于树上两点路径唯一，假如我们把这个点从树上删掉，树会分成若干个联通块，任意不同联通块两点间的路径显然都是经过这个点的。 要想高效统计，我们可以把它看做有根树，这样任意一点被删除产生的联通块就是它所有子树和子树外的点，显然可以前缀和优化，注意题目中一条路径端点是升序，意味着每条路径只被计算一次，注意减半的实现（可以最后除二也可以边加边算）。 只需要一次DFS即可计算，时间复杂度 O(n)Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005int v[maxn] , n , ans , head[maxn] , ct , sz[maxn];struct edge&#123; int next , to;&#125;e[maxn&lt;&lt;1];inline void add(int x , int y)&#123; e[++ct].next = head[x]; e[ct].to = y; head[x] = ct;&#125;void dfs(int x , int fx)&#123; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fx) continue; dfs(v , x) , sz[x] += sz[v]; &#125; long long tmp = 0; for(int i = head[x] , tot = n - sz[x] + 1; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fx) continue; tmp += 1ll * tot * sz[v] , tot += sz[v]; &#125; tmp += n - sz[x]; if(tmp&amp;1) ans ^= v[x];&#125;int main()&#123; scanf("%d",&amp;n); int x , y; for(int i = 1 ; i &lt;= n - 1 ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , add(y,x); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); dfs(1,1); printf("%d",ans);&#125; NOWCODER PRACTICE 32 C ballshttps://ac.nowcoder.com/acm/contest/272/C 题目描述 有一个盒子，里面有一个黑球和一个白球。每次随机取出盒子中的一个球，并将两个与取出球同色的球放进盒子（就是随机一种颜色将其个数+1）。 求n次取球后，盒子中白色球数目的期望。 输入描述:1输入一个整数n，表示取球次数。 输出描述:1输出一个实数，表示n次取球后白球数目的期望。答案保留7位小数。 示例1 输入12 输出12.0000000 说明1234567891011121314151617若第一次取出白球：放入两个白球，则现在有一个黑球两个白球，概率为1/2。若第二次取出白球，则现在有一个黑球三个白球，概率为1/2*2/3=1/3，期望个数为1/3*3=1；若第二次取出黑球，则现在有两个黑球两个白球，概率为1/2*1/3=1/6，期望个数为1/6*2=1/3。若第一次取出黑球：放入两个黑球，则现在有两个黑球一个白球，概率为1/2。若第二次取出黑球，则现在有三个黑球一个白球，概率为1/2*2/3=1/3，期望个数为1/3*1=1/3；若第二次取出白球，则现在有两个黑球两个白球，概率为1/2*1/3=1/6，期望个数为1/6*2=1/3。所以白球期望数目为2个。 备注: 0≤n≤10^6。题解一道不错的期望题。 先考虑暴力dp。 设f_{i,j}表示取$i$次后，有$j$个白球的概率是多少。 设计这个状态不难，因为很显然每次只会多一个球，因此只需要考虑上次取的是白球还是黑球。 因此 f_{i,j} = \frac{i+j-1}{i+1}f_{i-1,j} + \frac{j-1}{i+1}f_{i-1,j-1}前面表示这次取黑球，后面是取白球的情况。 然后题目只有一个输入，很容易想到：打表！ 发现答案是0.5 还有一种更神仙的做法： 白球黑球并没有本质的区别，对于一种取的可能性对黑白球取反的可能性是一样的，显然也是一一对应的。 因此答案就是1+n/2。（emmmm） Code：1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 5005double f[maxn][maxn] , ans;int n;int main()&#123; scanf("%d",&amp;n); f[0][1] = 1; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= i + 1; ++j) f[i][j] = f[i-1][j] * (i-j+1)/(i+1) + f[i-1][j-1] * (j-1)/(i+1); for(int i = 1 ; i &lt;= n + 1; ++i) ans += (double)i * f[n][i];&#125; D car链接： https://ac.nowcoder.com/acm/contest/315/D 来源：牛客网 题目描述 妞妞参加完Google Girl Hackathon之后,打车回到了牛家庄。 妞妞需要支付给出租车司机车费s元。妞妞身上一共有n个硬币，第i个硬币价值为p[i]元。 妞妞想选择尽量多的硬币，使其总价值足以支付s元车费(即大于等于s)。 但是如果从妞妞支付的这些硬币中移除一个或者多个硬币，剩下的硬币总价值还是足以支付车费的话，出租车司机是不会接受的。例如: 妞妞使用价值为2，5，7的硬币去支付s=11的车费,出租车司机是不会接受的，因为价值为2这个硬币是可以移除的。 妞妞希望能选取最大数量的硬币，使其总价值足以支付车费并且出租车司机能接受。 妞妞希望你能帮她计算最多可以支付多少个硬币。 输入描述: 123输入包括两行, 第一行包括两个正整数n和s(1 &lt;= n &lt;= 10, 1 &lt;= s &lt;= 1000), 表示妞妞的硬币个数和需要支付的车费。第二行包括n个正整数p[i] (1 &lt;= p[i] &lt;= 100)，表示第i个硬币的价值。保证妞妞的n个硬币价值总和是大于等于s。 输出描述:1输出一个整数, 表示妞妞最多可以支付的硬币个数。 输入125 94 1 3 5 4 输出13 题解 n]]></content>
      <tags>
        <tag>数学，数论 dp 图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 15]]></title>
    <url>%2F2018%2F12%2F07%2F2018.12.7%2F</url>
    <content type="text"><![CDATA[The easy is downhill. 盒子与小球之四描述 给定N个各不相同的小球，和M个不同的BOX，有多少种不同的放球方法，使得每个BOX里的小球个数不小于Ｋ。N,M,K均小于15 输入 每行给出Ｎ,M,K 以0 0 0结束 输出 如题 样例输入 12343 3 12 4 13 2 00 0 0 样例输出 123608 题解这题一开始想组合数学做法，结果发现怎么都会重。。。 既然这样那不如就写个组合dp好了。 设$f(i,j)$表示前$i$个小球放入$j$个盒子中的方案数。 显然我们只需要枚举当前盒子放了几个球。 f_{i,j} = \sum_{p=k}^{i}f_{i-p,j-1} * C_{n-i+p}^{p}n-i+p是因为我们要在剩下的球(前面状态带编号选了i-p个球)中选择p个球。 一开始组合数还写错了。。 Code： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 20#define ll long longll f[maxn][maxn] , c[maxn][maxn];int n , m , k;inline void pre()&#123; for(int i = 0 ; i &lt;= 15 ; ++i) c[i][0] = c[i][i] = 1; for(int i = 2 ; i &lt;= 15 ; ++i) for(int j = 1 ; j &lt;= 15 ; ++j) c[i][j] = c[i-1][j-1] + c[i-1][j];&#125;int main()&#123; pre(); while(scanf("%d%d%d",&amp;n,&amp;m,&amp;k) != EOF) &#123; if(n == 0 &amp;&amp; m == 0 &amp;&amp; k == 0) break; if(n &lt; m * k) &#123; puts("0"); continue; &#125; std::memset(f,0,sizeof(f)); for(int i = k; i &lt;= n ; ++i) f[i][1] = c[n][i]; for(int i = k ; i &lt;= n ; ++i) for(int j = 2 ; j &lt;= m ; ++j) for(int t = k ; t &lt;= i ; ++t) f[i][j] += f[i-t][j-1] * c[n-i+t][t]; printf("%lld\n",f[n][m]); &#125;&#125; UVA11324 The Largest Clique题目描述 给你一张有向图 G，求一个结点数最大的结点集，使得该结点集中的任意两个结点 u 和 v 满足：要么 u 可以达 v，要么 v 可以达 u（u,v相互可达也行）。 输入数据 第一行：测试数据组数T，每组数据的格式如下：第一行为结点数 n 和边数 m ，结点编号 1~n。以下m行每行两个整数 u 和 v ，表示一条有向边 u-&gt;v。 输出数据 每组数据输出最大结点集的结点数 题解是一道很水的题目(⊙o⊙)… 显然只需要根据一个非常容易得知的性质：有向图上一个点u能到另一点v，那所有到达点u的点都能到v。 这启发我们要用拓扑排序。 又考虑到图中有强联通分量ECC。 ECC内任意两点均可互相到达，满足题意，可以视为一个“大点” 因此先Tarjan缩点在写一个简单的dp就可以AC了 f_v = max(f_u') + sz_vu是能够到达点v的点。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#define maxn 1005int head[maxn] , ct , n , m, t , ecc[maxn] , ans , sz[maxn] , f[maxn] , tot , d[maxn];bool ins[maxn];struct edge&#123; int next , to;&#125;e[maxn&lt;&lt;9];struct tmp&#123; int fr , to;&#125;er[maxn&lt;&lt;9];inline void add(int x , int y)&#123; e[++ct].next = head[x]; e[ct].to = y; head[x] = ct; ++d[y];&#125;namespace FNT&#123; int dfn[maxn] , low[maxn] , idx; std::stack&lt;int&gt; st; void Tarjan(int x) &#123; dfn[x] = low[x] = ++idx; st.push(x); ins[x] = true; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(!dfn[v]) Tarjan(v) , low[x] = std::min(low[x] , low[v]); else if(ins[v]) low[x] = std::min(low[x] , dfn[v]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; ecc[st.top()] = tot; sz[tot] ++; ins[st.top()] = false; st.pop(); &#125; ecc[st.top()] = tot; ins[st.top()] = false; sz[tot] ++; st.pop(); &#125; &#125;&#125;inline void dp()&#123; std::queue&lt;int&gt; q; for(int i = 1 ; i &lt;= tot ; ++i) f[i] = sz[i]; for(int i = 1 ; i &lt;= tot ; ++i) if(!d[i]) q.push(i); while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = head[k] ; i ; i = e[i].next) &#123; int v = e[i].to; f[v] = std::max(f[v] , f[k] + sz[v]); if(!(--d[v])) q.push(v); &#125; &#125;&#125;inline void init()&#123; std::memset(head,0,sizeof(head)); std::memset(ecc,0,sizeof(ecc)); std::memset(FNT::dfn,0,sizeof(FNT::dfn)); std::memset(FNT::low , 0, sizeof(FNT::low)); std::memset(sz,0,sizeof(sz)); std::memset(f,0,sizeof(f)); std::memset(d,0,sizeof(d)); std::memset(ins,false,sizeof(ins)); FNT::idx = 0 ,ct = 0 , tot = 0 , ans = 0;&#125;int main()&#123; scanf("%d",&amp;t); while(~(--t)) &#123; scanf("%d%d",&amp;n,&amp;m); init(); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y; scanf("%d%d",&amp;x,&amp;y); add(x,y) , er[i].fr = x , er[i].to = y; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(!FNT::dfn[i]) FNT::Tarjan(i); std::memset(d,0,sizeof(d)); std::memset(head,0,sizeof(head)); ct = 0; for(int i = 1 ; i &lt;= m ; ++i) &#123; int u = er[i].fr , v = er[i].to; if(ecc[v] != ecc[u]) add(ecc[u] , ecc[v]); &#125; dp(); for(int i = 1 ; i &lt;= tot ; ++i) ans = std::max(ans , f[i]); printf("%d\n",ans); &#125;&#125; [ZJOI2007]最大半连通子图题目描述一个有向图G=(V,E)称为半连通的(Semi-Connected)，如果满足：?u,v∈V，满足u→v或v→u，即对于图中任意两点u，v,存在一条u到v的有向路径或者从v到u的有向路径。若G’=(V’,E’)满足V’?V，E’是E中所有跟V’有关的边，则称G’是G的一个导出子图。若G’是G的导出子图，且G’半连通，则称G’为G的半连通子图。若G’是G所有半连通子图中包含节点数最多的，则称G’是G的最大半连通子图。给定一个有向图G，请求出G的最大半连通子图拥有的节点数K，以及不同的最大半连通子图的数目C。由于C可能比较大，仅要求输出C对X的余数。 输入输出格式输入格式： 第一行包含两个整数N，M，X。N，M分别表示图G的点数与边数，X的意义如上文所述接下来M行，每行两个正整数a, b，表示一条有向边(a, b)。图中的每个点将编号为1,2,3…N，保证输入中同一个(a,b)不会出现两次。 输出格式： 应包含两行，第一行包含一个整数K。第二行包含整数C Mod X. 输入输出样例输入样例#1： 12345676 6 200706031 22 11 32 45 66 4 输出样例#1： 1233 说明对于100%的数据， N \le 100000, M \le 1000000, X \le 10^8题解比起上面那道题多了个方案数。 有没有想到最短路计数？显然严格大于就改成当前更新点的方案数，恰好等于就加上方案数。 所以要考虑重边！用map去重居然没有TLE，假如TLE也不是没办法，换成vector排序即可。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define maxn 100005#define ll long longint head[maxn] , tot , ct , n , m , d[maxn] , mod , f[maxn] , sz[maxn] , ecc[maxn];ll g[maxn] ;std::map&lt;int,int&gt; vis[maxn];bool ins[maxn];struct edge&#123; int next , to;&#125;e[maxn&lt;&lt;4];struct Emmm&#123; int fr , to;&#125;er[maxn&lt;&lt;4];inline void add(int x , int y)&#123; e[++ct].next = head[x]; e[ct].to = y; head[x] = ct; ++d[y];&#125;namespace FNT&#123; int dfn[maxn] , low[maxn] , idx; std::stack&lt;int&gt; st; void Tarjan(int x) &#123; dfn[x] = low[x] = ++idx; st.push(x); ins[x] = true; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(!dfn[v]) Tarjan(v) , low[x] = std::min(low[x] , low[v]); else if(ins[v]) low[x] = std::min(low[x] , dfn[v]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; ecc[st.top()] = tot; sz[tot] ++; ins[st.top()] = false; st.pop(); &#125; ecc[st.top()] = tot; ins[st.top()] = false; sz[tot] ++; st.pop(); &#125; &#125;&#125;inline void dp()&#123; std::queue&lt;int&gt; q; for(int i = 1 ; i &lt;= tot ; ++i) f[i] = sz[i] , g[i] = 1; for(int i = 1 ; i &lt;= tot ; ++i) if(!d[i]) q.push(i); while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = head[k] ; i ; i = e[i].next) &#123; int v = e[i].to; if(f[k] + sz[v] &gt; f[v]) &#123; g[v] = g[k]; f[v] = f[k] + sz[v]; &#125; else if(f[k] + sz[v] == f[v]) (g[v] += g[k]) %= mod; if(!(--d[v])) q.push(v); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;mod); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y; scanf("%d%d",&amp;x,&amp;y); add(x,y) , er[i].fr = x , er[i].to = y; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(!FNT::dfn[i]) FNT::Tarjan(i); std::memset(head,0,sizeof(head)); std::memset(d,0,sizeof(d)); ct = 0; for(int i = 1 ; i &lt;= m ; ++i) &#123; int u = er[i].fr , v = er[i].to; if(ecc[u] != ecc[v] &amp;&amp; !vis[ecc[u]][ecc[v]]) add(ecc[u] , ecc[v]) , vis[ecc[u]][ecc[v]] = 1; &#125; dp(); int ans1 = 0 ; ll ans2 = 0; for(int i = 1 ; i &lt;= tot ; ++i) &#123; if(ans1 &lt; f[i]) ans1 = f[i] , ans2 = g[i] % mod; else if(ans1 == f[i]) (ans2 += g[i]) %= mod; &#125; printf("%d\n%lld",ans1,ans2);&#125; 今天就此结束，明天也要认真学习哦！]]></content>
      <tags>
        <tag>组合数学 dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 14]]></title>
    <url>%2F2018%2F12%2F06%2F2018.12.6%2F</url>
    <content type="text"><![CDATA[如果手里捏着属于自己的泥土，看见青禾在晴空下微风里缓缓生长，算计着一年的收获，那份踏实的情绪，才是余生最好的答案。——三毛 今天尽管大概在机房带了6个多小时，却一道题都没有切。。 其实切了一道，只不过是联赛官方数据水才AC的。。其实思路是对的，只不过不知道哪里出了差错。。 NOIP 2018 D2T1 旅行题目描述小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。 小Y了解到， X国的 nn 个城市之间有 mm 条双向道路。每条双向道路连接两个城市。 不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且， 从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些 道路从一个城市前往另一个城市。 小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或 继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。 为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将 它的编号记录下来。她知道这样会形成一个长度为 nn 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？ 对于两个长度均为 nn 的序列 AA 和 BB，当且仅当存在一个正整数 xx，满足以下条件时， 我们说序列 AA 的字典序小于 BB。 对于任意正整数 1 ≤ i &lt; x1≤i&lt;x，序列 AA 的第 ii 个元素 A_iAi 和序列 BB 的第 ii 个元素 B_iBi 相同。 序列 AA 的第 xx 个元素的值小于序列 BB 的第 xx 个元素的值。 输入输出格式输入格式： 输入文件共 m + 1m+1 行。第一行包含两个整数 n,m(m ≤ n)n,m(m≤n)，中间用一个空格分隔。 接下来 m 行，每行包含两个整数 u,v (1 ≤ u,v ≤ n)u,v(1≤u,v≤n) ，表示编号为 uu 和 vv 的城市之 间有一条道路，两个整数之间用一个空格分隔。 输出格式： 输出文件包含一行，nn 个整数，表示字典序最小的序列。相邻两个整数之间用一个 空格分隔。 输入输出样例输入样例#1： 复制 1234566 5 1 3 2 3 2 5 3 4 4 6 输出样例#1： 复制 11 3 2 5 4 6 输入样例#2： 复制 12345676 6 1 3 2 3 2 5 3 4 4 5 4 6 输出样例#2： 11 3 2 4 5 6 说明【数据规模与约定】 对于 100\%100% 的数据和所有样例， 1 \le n \le 50001≤n≤5000 且 $m = n − 1$ 或 m = nm=n 。 对于不同的测试点， 我们约定数据的规模如下： 题解暴力断边就不说了，主要说说如何线性贪心。 每个点的vector先排序。 考虑到按树的方式贪心，直到第一个环上的点，我们称为根。 这个根显然可以按照环两点大小（小的称为lson，大的称为rson）分成5部分： 比lson小的，直接递归访问即可。 lson开始贪心 在lson至rson中间的，找出最小的，全部压进一个队列。 rson后面的，最后处理即可。 那么对于环该如何贪心呢？ 显然我们可以不断的从lson往环的另一边走，边走边记录假如它回溯第一个节点是什么，如果小于下一个环上的节点，那就回溯（反证贪心） 回来后把队列里的点递归访问子树。 然后从rson开始走，这个就纯模拟了。 走完把大于rson的点及其子树递归访问。然后return，这个环就解决了。 Code（实际上是错误的但AC了。。）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define maxn 500005std::vector&lt;int&gt; g[maxn];int id[maxn] , n , m , cir[maxn] , cirnum , ct , ans[maxn];struct Node&#123; int u , v;&#125;;std::stack&lt;Node&gt; p;std::queue&lt;int&gt; q;namespace circle&#123; int dfn[maxn] , low[maxn] , idx , tot , sz[maxn]; std::stack&lt;int&gt; st; void Tarjan(int x, int fx) &#123; dfn[x] = low[x] = ++idx; st.push(x); for(int i = 0 ; i &lt; (int)g[x].size(); ++i) &#123; int v = g[x][i]; if(!dfn[v]) Tarjan(v , x) , low[x] = std::min(low[x] , low[v]); else if(v != fx) low[x] = std::min(low[x] , dfn[v]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; cir[st.top()] = tot; sz[tot] ++; st.pop(); &#125; cir[st.top()] = tot; sz[tot] ++ ; st.pop(); &#125; &#125; inline void pre() &#123; Tarjan(1,1); for(int i = 1 ; i &lt;= tot ; ++i) if(sz[i] &gt; 1)&#123; cirnum = i; break; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(cir[i] != cirnum) cir[i] = 0; for(int i = 1 ; i &lt;= n ; ++i) if(g[i].size() &gt; 1) std::sort(g[i].begin() , g[i].end()); // puts("THE CICLE"); // for(int i = 1 ; i &lt;= n ; ++i) // if(cir[i]) // printf("%d ",i); &#125;&#125;void getID(int x, int fx)&#123; //printf("The Visit Tree point:%d %d\n",x,ct+1); id[x] = ++ct; if(cir[x]) &#123;// printf("The first point on the Circle: %d\n",x);// for(int i = 0 ; i &lt; (int)g[x].size() ; ++i)// printf("%d ",g[x][i]);// putchar(10); int lson = 0 ,rson = 0 , stp = -1 , pre = 0x7ffff; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) // find the two adjancent points &#123; int v = g[x][i]; if(v == fx) continue; if(lson &amp;&amp; rson)&#123; stp = i; break; &#125; if(!cir[v] &amp;&amp; lson &amp;&amp; v &gt; lson)&#123; pre = std::min(pre , v); q.push(v); continue; &#125; else if(!cir[v] &amp;&amp; v &lt; lson)&#123; getID(v , x); continue; &#125; if(!lson) lson = v; else if(lson &amp;&amp; !rson) rson = v; &#125; // printf("QQQQ%d %d\n",q.size() , pre); // printf("The lson , rson ans the stop points are:%d %d %d\n",lson,rson,stp);// puts("While lson process"); pre = std::min(pre , rson); while(lson != rson) &#123;// printf("The cur lson ans rson:%d %d\n",lson , rson); int u = lson; id[u] = ++ct; bool flag = false; for(int i = 0 ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(id[v]) continue; else if(cir[v])&#123; int k = 0; for(int j = i + 1 ; j &lt; (int)g[u].size() ; ++j) &#123; k = g[u][j]; if(cir[k]) continue; pre = k; break; &#125; p.push((Node)&#123;u ,i + 1&#125;);// printf("%d %d %d\n",pre,v,lson); if(v &gt; pre)&#123; flag = true; break; &#125; lson = v; break; &#125; else getID(v , u); &#125; if(flag) break; &#125; // puts("Backforward to visit the lsons tree points"); while(!p.empty()) &#123; // printf("Now the tree point source is : %d\n",p.top().u); int u = p.top().u , fr = p.top().v; p.pop(); for(int i = fr ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(cir[v]) continue; getID(v , u); &#125; &#125; while(!q.empty()) &#123; int k = q.front(); q.pop(); getID(k , x); &#125; // printf("for pre : %dVisit from rson:%d\n",pre,rson);// puts("Now the rson remain"); while(lson != rson) &#123; int next = -1;// printf("now the rson is:%d\n",rson); int u = rson; id[u] = ++ct; for(int i = 0 ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(id[v]) continue; else if(cir[v]) &#123; next = v; p.push((Node)&#123;u , i + 1&#125;); break; &#125; else getID(v , u); &#125; if(~next) rson = next; else break; &#125;// puts("Backforward to visit the rsons tree points"); while(!p.empty()) &#123; // printf("Now the backforward point is:%d\n",p.top().u); int u = p.top().u , fr = p.top().v; p.pop(); for(int i = fr ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(cir[v]) continue; getID(v , u); &#125; &#125; // puts("The remain points of source:"); if(!(~stp)) return; for(int i = stp ; i &lt; (int)g[x].size() ; ++i)&#123; //visit the remain tree points int v = g[x][i]; // printf("%d\n",v); if(v == fx) continue; getID(v , x); &#125;// printf("The last visit:%d\n", ct); return; &#125; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i]; if(v == fx) continue; getID(v , x); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y; scanf("%d%d",&amp;x,&amp;y); g[x].push_back(y); g[y].push_back(x); &#125; circle::pre(); getID(1,1); for(int i = 1 ; i &lt;= n ; ++i) ans[id[i]] = i; for(int i = 1 ; i &lt;= n ; ++i) printf("%d ",ans[i]);&#125; 正确的写法应该是这样的，但是今天一天都没调出来，明天继续加油。。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define maxn 500005std::vector&lt;int&gt; g[maxn];int id[maxn] , n , m , cir[maxn] , cirnum , ct , ans[maxn];struct Node&#123; int u , v;&#125;;std::stack&lt;Node&gt; p;std::queue&lt;int&gt; q;namespace circle&#123; int dfn[maxn] , low[maxn] , idx , tot , sz[maxn]; std::stack&lt;int&gt; st; void Tarjan(int x, int fx) &#123; dfn[x] = low[x] = ++idx; st.push(x); for(int i = 0 ; i &lt; (int)g[x].size(); ++i) &#123; int v = g[x][i]; if(!dfn[v]) Tarjan(v , x) , low[x] = std::min(low[x] , low[v]); else if(v != fx) low[x] = std::min(low[x] , dfn[v]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; cir[st.top()] = tot; sz[tot] ++; st.pop(); &#125; cir[st.top()] = tot; sz[tot] ++ ; st.pop(); &#125; &#125; inline void pre() &#123; Tarjan(1,1); for(int i = 1 ; i &lt;= tot ; ++i) if(sz[i] &gt; 1)&#123; cirnum = i; break; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(cir[i] != cirnum) cir[i] = 0; for(int i = 1 ; i &lt;= n ; ++i) if(g[i].size() &gt; 1) std::sort(g[i].begin() , g[i].end()); // puts("THE CICLE"); // for(int i = 1 ; i &lt;= n ; ++i) // if(cir[i]) // printf("%d ",i); &#125;&#125;void getID(int x, int fx)&#123; //printf("The Visit Tree point:%d %d\n",x,ct+1); id[x] = ++ct; if(cir[x]) &#123;// printf("The first point on the Circle: %d\n",x);// for(int i = 0 ; i &lt; (int)g[x].size() ; ++i)// printf("%d ",g[x][i]);// putchar(10); int lson = 0 ,rson = 0 , stp = -1 , pre = 0x7ffff; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) // find the two adjancent points &#123; int v = g[x][i]; if(v == fx) continue; if(lson &amp;&amp; rson)&#123; stp = i; break; &#125; if(!cir[v] &amp;&amp; lson &amp;&amp; rson &amp;&amp; v &gt; lson &amp;&amp; v &lt; rson)&#123; pre = std::min(pre , v); q.push(v); continue; &#125; else if(!cir[v] &amp;&amp; v &lt; lson)&#123; getID(v , x); continue; &#125; if(!lson) lson = v; else if(lson &amp;&amp; !rson) rson = v; &#125; // printf("QQQQ%d %d\n",q.size() , pre); // printf("The lson , rson ans the stop points are:%d %d %d\n",lson,rson,stp);// puts("While lson process"); pre = std::min(pre , rson); while(lson != rson) &#123;// printf("The cur lson ans rson:%d %d\n",lson , rson); int u = lson , next = -1; id[u] = ++ct; bool flag = false; for(int i = 0 ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(id[v]) continue; else if(cir[v]) &#123; int k = 0; for(int j = i + 1 ; j &lt; (int)g[u].size() ; ++j) &#123; k = g[u][j]; if(cir[k]) continue; pre = k; break; &#125; p.push((Node)&#123;u ,i + 1&#125;);// printf("%d %d %d\n",pre,v,lson); if(v &gt; pre)&#123; flag = true; break; &#125; next = v; break; &#125; else getID(v , u); &#125; if(flag) break; if(~next) lson = next; else break; &#125; // puts("Backforward to visit the lsons tree points"); while(!p.empty()) &#123; // printf("Now the tree point source is : %d\n",p.top().u); int u = p.top().u , fr = p.top().v; p.pop(); for(int i = fr ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(cir[v]) continue; getID(v , u); &#125; &#125; while(!q.empty()) &#123; int k = q.front(); q.pop(); getID(k , x); &#125; // printf("for pre : %dVisit from rson:%d\n",pre,rson);// puts("Now the rson remain"); while(lson != rson) &#123; int next = -1;// printf("now the rson is:%d\n",rson); int u = rson; id[u] = ++ct; for(int i = 0 ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(id[v]) continue; else if(cir[v]) &#123; next = v; p.push((Node)&#123;u , i + 1&#125;); break; &#125; else getID(v , u); &#125; if(~next) rson = next; else break; &#125;// puts("Backforward to visit the rsons tree points"); while(!p.empty()) &#123; // printf("Now the backforward point is:%d\n",p.top().u); int u = p.top().u , fr = p.top().v; p.pop(); for(int i = fr ; i &lt; (int)g[u].size() ; ++i) &#123; int v = g[u][i]; if(cir[v]) continue; getID(v , u); &#125; &#125; // puts("The remain points of source:"); if(!(~stp)) return; for(int i = stp ; i &lt; (int)g[x].size() ; ++i)&#123; //visit the remain tree points int v = g[x][i]; // printf("%d\n",v); if(v == fx) continue; getID(v , x); &#125;// printf("The last visit:%d\n", ct); return; &#125; for(int i = 0 ; i &lt; (int)g[x].size() ; ++i) &#123; int v = g[x][i]; if(v == fx) continue; getID(v , x); &#125;&#125;int main()&#123; freopen("travel.in","r",stdin); freopen("my.out","w",stdout); scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= m ; ++i) &#123; int x , y; scanf("%d%d",&amp;x,&amp;y); g[x].push_back(y); g[y].push_back(x); &#125; circle::pre(); getID(1,1); for(int i = 1 ; i &lt;= n ; ++i) ans[id[i]] = i; for(int i = 1 ; i &lt;= n ; ++i) printf("%d ",ans[i]);&#125; 感觉代码写着写着就又臭又长了啊。。明天重构一下代码吧，把能写成函数的写成函数。 Linux下code真好，超级稳定，从不卡崩溃什么的。 剩下的时间写写数学了]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 13]]></title>
    <url>%2F2018%2F12%2F05%2F2018.12.5%2F</url>
    <content type="text"><![CDATA[我不想当烟花般灿烂的瞬间，只想当你普通的永远。 试着在Linux下编译并运行程序。。。 结果Linux死活装不上qwq，然后就拷贝了慎老师的虚拟机文件。 以后就尽量使用Linux写代码了，提前适应环境。 今天用了大半天联系Linux基本操作，好不容易终于写出了一道题。 记录一下常用Linux命令（虽然我从来没用过但是凭感觉就能写出很多常用命令，感觉Linux还是挺不错的）： 修改vimrc配置：sudo vim ~/.vimrc（比较好看的字体：Tlwg typo medium） 查看当前目录：ls 切换目录：cd 运行程序：./xxx vim编译NOI Linux下可以直接F9 ， 当然也可以：g++ xx -o xx -Wall 现在唯一严重的问题是我不知道为什么复制粘贴没法使用，Vim内部粘贴很好用，但是从Vim复制到命令行什么的就不行，到时候再试试。 写了道不难的题，一开始算错了表达式结果还写了暴力。。 5131 求和2015一条狭长的纸带被均匀划分出了 n 个格子，格子编号从 1 到 n。每个格子上都染了一种颜色colori（用[1，m]当中的一个整数表示），并且写了一个数字number定义一种特殊的三元组：(x, y, z)，其中 x，y，z 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：\1. x, y, z都是整数,x &lt;y &lt;z,y−x=z−y\2. colorx= colorz满足上述条件的三元组的分数规定为(x + z) ∗ (numberx+ numberz)。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 10,007 所得的余数即可。 输入描述 Input Description 第一行是用一个空格隔开的两个正整数n和m，n代表纸带上格子的个数，m代表纸带上颜色的种类数。第二行有n个用空格隔开的正整数，第i个数字numberi代表纸带上编号为i的格子上面写的数字。第三行有n个用空格隔开的正整数，第i个数字colori代表纸带上编号为i的格子染的颜色。 输出描述 Output Description 共一行，一个整数，表示所求的纸带分数除以 10,007 所得的余数。 样例输入 Sample Input 输入样例1 6 2 5 5 3 2 2 2 2 2 1 1 2 1 输入样例2 15 4 5 10 8 2 2 2 9 9 7 7 5 6 4 2 4 2 2 3 3 4 3 3 2 4 4 4 4 1 1 1 样例输出 Sample Output输出样例1 82 输出样例2 1388 数据范围及提示 Data Size &amp; Hint【输入输出样例 1 说明】纸带如题目描述中的图所示。所有满足条件的三元组为：(1,3,5),(4,5,6)。所以纸带的分数为(1 + 5) ∗ (5 + 2) + (4 + 6) ∗ (2 + 2) = 42 + 40 = 82。【数据说明】对于第 1 组至第 2 组数据，1 ≤ n ≤ 100,1 ≤ m ≤ 5；对于第 3 组至第 4 组数据，1 ≤ n ≤ 3000,1 ≤ m ≤ 100；对于第 5 组至第 6 组数据，1 ≤ n ≤ 100000,1 ≤ m ≤ 100000，且不存在出现次数超过 20 的颜色；对 于 全 部 10 组 数 据 ， 1 ≤ n ≤ 100000,1 ≤m ≤ 100000,1 ≤ colori≤ m,1 ≤numberi≤ 100000。 题解显然只有同奇同偶的数对中间才能存在y 然后我们把题目中的计算表达式乘开，并且考虑对当前位置能否快速统计和前面的数构成二元组对答案的贡献。 \sum_{y}(x + y)(V_x+V_y) = kxV_x + x\sum{V_y} + \sum_{y}*V_x+\sum{yV_y}我们需要维护的量也很清楚了，用三个数组每次保存当前按下标奇偶性分类的相同颜色的（就是桶）三个和式。 时间复杂度 O(n)Code:1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long long#define mod 10007ll f[2][maxn] , g[2][maxn] , ans , ct[2][maxn] , h[2][maxn];int v[maxn] , c[maxn] , n , m;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); for(int i = 1 ; i &lt;= n ;++i) scanf("%d",&amp;c[i]); for(int i = 1 ; i &lt;= n ; ++i) &#123; ans += 1ll*ct[i&amp;1][c[i]] * i * v[i] + 1ll*i * f[i&amp;1][c[i]] + 1ll*v[i] * g[i&amp;1][c[i]] % mod + 1ll*h[i&amp;1][c[i]]; ans %= mod; f[i&amp;1][c[i]] += v[i]; g[i&amp;1][c[i]] += i; h[i&amp;1][c[i]] += 1ll * i * v[i]; f[i&amp;1][c[i]] %= mod , g[i&amp;1][c[i]] %= mod , h[i&amp;1][c[i]] %= mod; ct[i&amp;1][c[i]] ++; &#125; printf("%lld",ans);&#125; 数据包的调度机制 总时间限制: 1000ms 内存限制: 65536kB 描述随着 Internet的迅猛发展,多媒体技术和电子商务应用日益广泛,Internet上的服务质量(QoS,Qualityof Service)问题已越来越受到重视。网络中采用的数据包调度机制与网络的服务质量 QoS 有着密切的关系。研究表明传统的基于队列的调度机制已不能满足网络服务质量QoS 的需求。服务质量 QoS 取决于数据包的延迟。每一个数据包都有一个延迟惩罚值。由于数据包承载的数据不同,不同数据包的延迟惩罚值也可能不同。此外,数据包的延迟也和它的发送顺序有关。如果一个数据包被第K个发送,假设它的延迟惩罚值是D,则这个数据包的最终延迟是 (K - 1) * D。北京大学2012 级信息学院的同学在程序设计课堂上,设计了一种新的基于栈的数据包的调度算法。同学们通过栈的先进后出(Last in First out)的原理,改变数据包的发送顺序,以减小数据包的延迟总值。给定N 个等待调度的数据包,起始这N 个数据包排成一个队列等待发送。接着,这些数据包按序进栈,调度算法可以控制数据包的出栈顺序。因此通过栈,可以将后面的数据包先于前面的数据包发送出去。请你实现一个调度算法使N 个数据包的延迟总值最小。 输入 标准的输入包含若干组测试数据。输入第一行是整数T(1 &lt;= T &lt;= 1000)，表明有T组测试数据。紧接着有T组连续的测试。每一组测试数据的第1行是 N（N &lt;= 100）,表述数据包的个数。接着的 N 行,每一行是一个整数,第i 行表示数据包i的延迟惩罚值( &lt;=50 )。 输出 对于每组测试数据，输出最小的延迟总值。 样例输入1 5 5 4 3 2 2 样例输出24 题解可以想到这是一个 O(n^3)的dp 然后我们可以猜是区间dp。 。。。好菜啊，一道dp都不会 我们考虑枚举一个区间最后出去的那个元素，然后这种情况必定是左边先全出去，然后右边都出去，最后是它自己（但是这种东西好难想啊，最优子结构也不会证啊。。) 但是就是可以区间dp啊。。 Code： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 155int f[maxn][maxn] , n , v[maxn] , s[maxn];int main()&#123; int t; scanf("%d",&amp;t); while(~(--t)) &#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); for(int i = 1 ; i &lt;= n ; ++i) s[i] = s[i-1] + v[i]; std::memset(f,0,sizeof(f)); for(int len = 2 ; len &lt;= n ; ++len) for(int fr = 1 , to ; (to = fr + len - 1) &lt;= n ; ++fr) &#123; f[fr][to] = 0x7ffff; for(int k = fr ; k &lt;= to ; ++k) f[fr][to] = std::min(f[fr][to] , f[fr][k-1] + f[k+1][to] + v[k] * (len-1) + (s[to]-s[k])*(k-fr)); &#125; printf("%d\n",f[1][n]); &#125;&#125;]]></content>
      <tags>
        <tag>随笔 Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 12]]></title>
    <url>%2F2018%2F12%2F04%2F2018.12.4%2F</url>
    <content type="text"><![CDATA[I’m going where you are there. Power收集题目背景据说在红雾异变时，博丽灵梦单身前往红魔馆，用十分强硬的手段将事件解决了。 然而当时灵梦在Power达到MAX之前，不具有“上线收点”的能力，所以她想要知道她能收集多少P点，然而这个问题她答不上来，于是她找到了学OI的你。 题目描述可以把游戏界面理解成一个N行M列的棋盘，有K个格子上有P点，其价值为val(i,j) 初始灵梦可以选择在第一行的任意一个格子出发，每秒她必须下移一格。 灵梦具有一个左右移动的速度T，可以使她每秒向左或右移动至多T格,也可以不移动，并且不能折返。移动可视为瞬间完成，不经过路途上的点，只能获得目标格子的P点。 求最终她能获得的POWER值最大是多少？ 输入输出格式输入格式： 第一行四个数字，N,M,K,T 接下来K行每行3个数字x,y,v,代表第x行第y列有一个val为v的P点，数据保证一个格子上最多只有1个P点。 输出格式： 一个数字 输入输出样例输入样例#1： 123453 3 4 11 1 31 2 12 2 33 3 3 输出样例#1： 19 说明对于40%的测试点，1&lt;=N,M,T,K&lt;=200 对于100%的测试点，1&lt;=N,M,T,K&lt;=4000 v&lt;=100，N,M,K,T均为整数 题解这种dp已经是最基本的了，再不会就别学了 先随手写个 O(n^3)的dp：设f_{i,j}表示第i行走到位置j的最大利益，然后枚举上一行的合法点转移即可 f_{i,j} = max\{f_{i-1,j-k}\}+v_{i,j}然后单调队列优化，结果单调队列的判断非空写反了，空的不空，不空是空。。。然后调了半天 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 4005int f[maxn][maxn] , n , v[maxn][maxn] , t , k , m , ans;struct Deque&#123; int que[maxn]; int l , r; Deque()&#123; l = 1 , r = 0; std::memset(que,0,sizeof(que)); &#125; inline void clear()&#123; l = 1 , r = 0; std::memset(que,0,sizeof(que)); &#125; inline void pop_front()&#123; que[l++] = 0; &#125; inline void pop_back()&#123; que[r--] = 0; &#125; inline void push_back(int x)&#123; que[++r] = x; &#125; inline int front()&#123; return que[l]; &#125; inline int back()&#123; return que[r]; &#125; inline int size()&#123; return r - l + 1; &#125; inline void print() &#123; puts("THE ELES :"); for(int i = l ; i &lt;= r ; ++i) printf("%d ",que[i]); putchar(10); &#125;&#125;q;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;t); for(int i = 1 ; i &lt;= k ; ++i)&#123; int x ,y , val; scanf("%d%d%d",&amp;x,&amp;y,&amp;val); v[x][y] = val; &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123; int now = 1; for(int j = 1 ; j &lt;= m ; ++j) &#123; while(now &lt;= j + t &amp;&amp; now &lt;= m)&#123; while(q.size() &amp;&amp; f[i-1][q.back()] &lt; f[i-1][now]) q.pop_back(); q.push_back(now); ++now; &#125; while(q.size() &amp;&amp; q.front() &lt; j - t) q.pop_front(); f[i][j] = f[i-1][q.front()] + v[i][j]; ans = std::max(ans , f[i][j]); &#125; q.clear(); &#125; printf("%d",ans);&#125; [POI2007]EGZ-Driving Exam题目描述The Byteotian driving licence exam takes place in an area in which there are nn straight, parallel, unidirectional, north-oriented streets (that is the allowed driving direction is south to north). Each of the streets is exactly mm meters long, all of them begin and end on the same level. These streets are numbered from 11 to nn starting the westernmost. There are also pp unidirectional, east or west-oriented streets perpendicular to the abovementioned, each one of them connecting a pair of adjacent north-oriented streets. It is also possible that an east-oriented and a west-oriented street overlap, thus forming a bidirectional one. An exemplary testing area (n=4, m=3, p=5n=4,m=3,p=5). The examiner chooses a north-oriented street, at the beginnig of which the examination starts and anothernorth-oriented street, where it is to come to an end. The task of the applicant is to drive from the starting tothe final point, observing the allowed directions.The examiner always chooses as starting point a street, from which it is possible to drive to the endpointof any other north-oriented street.The work of the examiners is a very tedious one, because they always have to start at the beginning ofone of the few suitable streets. The board of directors have decided to build a new testing area on the basis ofpre-existent plans. It has been calculated, that available funds allow for no more than kk east or west-orientedstreets to be built. Those new streets are to be constructed in such a way, so as to add the largest possiblenumber of potential starting points (there may or may not exist starting points on the pre-existent plan). Newstreets have to connect pairs of adjacent north-oriented streets. TaskWrite a programme which: reads a description of the testing area and the number kk from the standard input, calculates the greatest number of potential new starting points for the examination, generated by adding no more than kk east or west-oriented streets, writes the outcome to the standard output. 成都的驾驶考试在一个有n条平行的自南向北的单向的道路的场地中进行。每条道路长度为m米，并且都在同一条水平线上开始和结束。街道从西向东分别编号为1到n。同样有p条单向的自西向东或自东向西的街道垂直于上面描述的街道，每一条这样的街道链接了两个相邻的自南向北的道路。当然自西向东和自东向西的道路可以重叠，那就是一个双向的街道了。 考生选择一个自南向北的道路作为他考试的起始点和另外一个自南向北的道路作为他考试的终止点。他们的考试项目是将车从开始的道路驾驶到作为终止点的道路。考生们总是选择一个可以到达所有其他街道的起始道路作为开始点。现在，考生们总是感到十分无趣因为他们只有很少的起始道路可以选择，所以教练们决定改造先有的考试场所，由于经费的限制，他们决定添加至多K条东西向的道路，使得能够选择的起始道路尽量地多。 输入输出格式输入格式： In the first line of the standard input there are four integers nn, mm, pp and kk (2 \le n \le 100\ 0002≤n≤100 000, 1 \le m, k, \le 100\ 0001≤m,k,≤100 000, 0 \le p \le 100\ 0000≤p≤100 000), separated by single spaces, denoting respectively: the number of north-oriented streets, the length of each one of them, the number of pre-existent east or west-oriented streets, the maximal number of new streets to be built. The north-oriented streets are numbered from 11 to nn, starting with the westernmost. The following pp lines contain three integers each: n_ini, m_imi and d_idi (1 \le n_i \le n1≤ni≤n, 0 \le m_i \le m0≤mi≤m, d_i \in \{0, 1\}di∈{0,1}), separated by single spaces, denoting the ‘th east-oriented (for d_i=0di=0) or west-oriented (for d_i=1di=1) street. This street connects north-oriented streets nn and n+1n+1, intersecting them in points m_imi meters distant from their beginning. 输出格式： The first and only line of the standard output should contain a single integer, denoting the maximal numberof new examination starting points generated by building no more than kk east or west-oriented streets. Thenewly built streets do not have to intersect the north-oriented streets in points, whose distance from thebeginning of the street is an integer. The newly built east or west-oriented streets may overlap, thus formingbidirectional streets. 输入输出样例输入样例#1： 1234564 3 5 22 0 02 2 13 3 11 1 13 3 0 输出样例#1： 12 题解这道题实际上是道最长单调子序列啊。。 首先不难想到答案一定是一个连续的区间去掉本来就能到达任意点的点数。 考虑最长单调子序列的性质：在权重相同的情况下用最小的改变代价使得整个序列单调。 这个性质很好证明，反证法即可，假如有另一个序列使得剩下的（剩下的必定每个都要调整，因为不然就可以加进当前的子序列）用更少的步数单调，那这个就比最长单调子序列长了。 假如看不懂上面的论述，可以自己用反证法想想。 有这个性质后，我们可以预处理出每个点到左边最少需要建的路，到右边需要建的路。 预处理出这个后，发现这两个相加的和满足某种单调性。具体来说，我们可以选取一段区间，使得左端点能到最右边，右端点能到最左边，这个区间里的点除掉那些一开始就满足条件的就是当前答案。 取最大即可。 没有写Code [SCOI2009]粉刷匠题目描述windy有 N 条木板需要被粉刷。 每条木板被分为 M 个格子。 每个格子要被刷成红色或蓝色。 windy每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。 如果windy只能粉刷 T 次，他最多能正确粉刷多少格子？ 一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。 输入输出格式输入格式： 第一行包含三个整数，N M T。 接下来有N行，每行一个长度为M的字符串，’0’表示红色，’1’表示蓝色。 输出格式： 包含一个整数，最多能正确粉刷的格子数。 输入输出样例输入样例#1： 12343 6 3111111000000001100 输出样例#1： 116 说明30%的数据，满足 1 &lt;= N,M &lt;= 10 ； 0 &lt;= T &lt;= 100 。 100%的数据，满足 1 &lt;= N,M &lt;= 50 ； 0 &lt;= T &lt;= 2500 。 题解一道对我来说好难好难的dp啊，mhr学长觉得我连这种题都不会，联赛分数肯定上不了350QAQ。（真实 %mhr学长秒切，稳进省队。 首先由于每块木板之间不能连续刷，一个很自然的子问题之一就是木板数。 然后我们也许可以知道对于一块木板前i个格子刷了k次能粉刷的最多格子数，然后就可以愉快的泛化物品用分组背包解决。 然后这种比较麻烦的预处理我一向是不会写的，其实不是个很难的划分dp。 设 g_{i,j,0/1}表示当前木板前$i$个格子粉刷$j$次，涂0/1颜色的最大粉刷格子数。 枚举当前位置，枚举最后粉刷的一段的左端点，然后很自然想到枚举已经刷的次数，显然和上一段有很简单的递推关系。假如和上一段颜色相同，相当于从上一段接着刷的，假如不同，说明需要多用一次。然后加上当前枚举的颜色这一段的个数。 然后这个预处理复杂度小于背包过程复杂度，因此时间复杂度为 O(nm^2T)Code： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 55#define maxT 2505#define ll long longint g[maxn][maxn][2] , f[maxT] , n , m , t , ct[2][maxn];char s[maxn][maxn];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;t); for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%s",s[i]+1); char *now = s[i]; std::memset(ct,0,sizeof(ct)); for(int j = 1 ; j &lt;= m ; ++j) ct[now[j]-48][j] = ct[now[j]-48][j-1] + 1 , ct[(now[j]-48)^1][j] = ct[(now[j]-48)^1][j-1]; for(int j = 1 ; j &lt;= m ; ++j) for(int k = 1 ; k &lt;= j ; ++k) for(int l = 1 ; l &lt;= m ; ++l) for(int x = 0 ; x &lt; 2 ; ++x) g[j][l][x] = std::max(g[k-1][l][x] , g[k-1][l-1][x^1]) + ct[x][j] - ct[x][k-1]; for(int j = t ; ~j ; --j) for(int k = 1 ; k &lt;= j &amp;&amp; k &lt;= m ; ++k) for(int p = 1 ; p &lt;= m ; ++p) f[j] = std::max(f[j] , f[j-k] + std::max(g[p][k][0],g[p][k][1])); &#125; int ans = 0; for(int i = 1; i &lt;= t ; ++i) ans = std::max(ans , f[i]); printf("%d",ans);&#125; [USACO17JAN]Promotion Counting晋升者计数题目描述The cows have once again tried to form a startup company, failing to remember from past experience that cows make terrible managers! The cows, conveniently numbered 1 \ldots N1…N (1 \leq N \leq 100,0001≤N≤100,000), organize the company as a tree, with cow 1 as the president (the root of the tree). Each cow except the president has a single manager (its “parent” in the tree). Each cow ii has a distinct proficiency rating, p(i)p(i), which describes how good she is at her job. If cow ii is an ancestor (e.g., a manager of a manager of a manager) of cow jj, then we say jj is a subordinate of ii. Unfortunately, the cows find that it is often the case that a manager has less proficiency than several of her subordinates, in which case the manager should consider promoting some of her subordinates. Your task is to help the cows figure out when this is happening. For each cow ii in the company, please count the number of subordinates jj where p(j) &gt; p(i)p(j)&gt;p(i). 奶牛们又一次试图创建一家创业公司，还是没有从过去的经验中吸取教训—牛是可怕的管理者！ 为了方便，把奶牛从 1 \cdots N(1 \leq N \leq 100, 000)1⋯N(1≤N≤100,000) 编号，把公司组织成一棵树，1 号奶牛作为总裁（这棵树的根节点）。除了总裁以外的每头奶牛都有一个单独的上司（它在树上的 “双亲结点”）。所有的第 ii 头牛都有一个不同的能力指数 p(i)p(i)，描述了她对其工作的擅长程度。如果奶牛 ii 是奶牛 jj 的祖先节点（例如，上司的上司的上司），那么我们我们把奶牛 jj 叫做 ii 的下属。 不幸地是，奶牛们发现经常发生一个上司比她的一些下属能力低的情况，在这种情况下，上司应当考虑晋升她的一些下属。你的任务是帮助奶牛弄清楚这是什么时候发生的。简而言之，对于公司的中的每一头奶牛 ii，请计算其下属 jj 的数量满足 p(j) &gt; p(i)p(j)&gt;p(i)。 输入输出格式输入格式： The first line of input contains NN. The next NN lines of input contain the proficiency ratings p(1) \ldots p(N)p(1)…p(N) for the cows. Each is a distinct integer in the range 1 \ldots 1,000,000,0001…1,000,000,000. The next N-1N−1 lines describe the manager (parent) for cows 2 \ldots N2…N. Recall that cow 1 has no manager, being the president. 输入的第一行包括一个整数 NN。 接下来的 NN 行包括奶牛们的能力指数 p(1) \cdots p(N). 保证所有数互不相同，在区间 1 \cdots 10^9 之间。 接下来的 N-1 行描述了奶牛 2 \cdots N 的上司（双亲节点）的编号。再次提醒，1 号奶牛作为总裁，没有上司。 输出格式： Please print N lines of output. The ith line of output should tell the number of subordinates of cow i with higher proficiency than cow i. 输出包括 NN 行。输出的第 ii 行应当给出有多少奶牛 ii 的下属比奶牛 ii 能力高。 输入输出样例输入样例#1： 1234567891058042893848469308876816927787146369169577477941123 输出样例#1： 1234520100 题解一道挺水的题。 显然求子树中大于它的可以离散化后用权值树状数组解决。只需要按深度优先的顺序让每个点的子树全都在它前插入即可，注意去除兄弟子树的影响，解决方法是记录下当前的数量。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int head[maxn] , cnt, bit[maxn] , f[maxn] , g[maxn] , n , v[maxn] , tot , sz[maxn];struct edge&#123; int next , to;&#125;e[maxn&lt;&lt;1];struct Node&#123; int v , k; bool operator&lt;(const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;p[maxn];inline int query(int x)&#123; int ans = 0; for(int i = x ; i ; i -= i &amp; -i) ans += bit[i]; return ans;&#125;inline void update(int x , int v)&#123; for(int i = x ; i &lt;= tot ; i += i &amp; -i) bit[i] += v;&#125;inline void add(int x, int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;void pre(int x , int fx)&#123; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) pre(e[i].to , x) ,sz[x] += sz[e[i].to];&#125;void DFS(int x , int fx)&#123; g[x] = query(v[x]); for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fx) continue; DFS(v , x); &#125; //printf("%d %d %d %d\n",x,sz[x],query(v[x]),g[x]); f[x] = sz[x] - 1 - (query(v[x]) - g[x]); update(v[x] , 1);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1; i &lt;= n ; ++i) scanf("%d",&amp;p[i].v) , p[i].k = i; for(int i = 2 ; i &lt;= n ; ++i)&#123; int x; scanf("%d",&amp;x); add(i , x) , add(x , i); &#125; std::sort(p+1,p+n+1); p[0].v = 425727; tot = 1; for(int i =1 ; i &lt;= n ; ++i) &#123; if(p[i].v == p[i-1].v) v[p[i].k] = tot; else v[p[i].k] = ++tot; &#125; pre(1,1); DFS(1,1); for(int i = 1; i &lt;= n ; ++i) printf("%d\n",f[i]);&#125; 1638 - Pole Arrangement题目描述小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 nn 个建筑，每个建筑的高度是 11到 nn 之间的一个整数。 小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 AA 个建筑，从最右边（所有建筑都在左边）看能看到 BB 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？ 如果建筑 ii 的左(右)边没有任何建造比它高，则建筑 ii 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。 输入输出格式输入格式： 第一行一个整数 TT，代表 TT 组数据。 接下来 TT 行，每行三个整数 n,A,Bn,A,B。 输出格式： 对于每组数据输出一行答案 \text{mod } 10^9+7输入输出样例输入样例#1： 12323 2 23 1 2 输出样例#1： 1221 题解作为建筑师的弱化版，我们只需要一个 O(n^3)的算法。 显然设 f_{i,j,k}表示前$i$个数，从左边能看到$j$个，从右边能看到$k$个。 我们发现正着插进去算方案数不是很好算，我们考虑把最矮的插进去。（非常巧妙了qwq） 然后像普通的组合递推一样用加法原理合并状态就好了。（分三种情况，插在最左边，插在最右边，插在中间） f_{i,j,k} = f_{i-1,j-1,k} + f_{i-1,j,k-1} + (i-2) * f_{i-1,j,k}比较经典和基础的一道递推，学习了。。。 Code： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 125#define ll long long#define mod 1000000007ll f[maxn][maxn][maxn] , n , l , r;ll DFS(int k , int ls , int rs)&#123; if(~f[k][ls][rs]) return f[k][ls][rs]; if(k == 1 &amp;&amp; ls == 1 &amp;&amp; rs == 1) return f[k][ls][rs] = 1; else if(k &lt;= 1) return f[k][ls][rs] = 0; return f[k][ls][rs] = DFS(k-1 , ls - 1 , rs) % mod + DFS(k-1 , ls , rs - 1) % mod + 1ll* (k - 2) * DFS(k - 1 , ls , rs) % mod;&#125;int main()&#123; std::memset(f,-1,sizeof(f)); int t; scanf("%d",&amp;t); while(~(--t) &amp;&amp; scanf("%d%d%d",&amp;n,&amp;l,&amp;r)) std::cout &lt;&lt; DFS(n , l , r) % mod &lt;&lt; std::endl;&#125; 使用Vim想要编译需要记住的命令 1w&lt;cr&gt;: ! g++ %:r.cpp -o %:r.exe -g -Wall -DDebug&lt;cr&gt;: ! %:r.exe&lt;cr&gt;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 11]]></title>
    <url>%2F2018%2F12%2F03%2F2018.12.3%2F</url>
    <content type="text"><![CDATA[我想看一场盛大的流行陨落的过程、我要一直不停许愿、许到沧海桑田瞬息万变直到靠近你微笑淡晴的脸。 —From Zyf 学姐 [SHOI2007]园丁的烦恼题目描述很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。 有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……” “那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。 “嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……” “是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。 “该死的，你究竟是什么来头？” “陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。 看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。 这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。 输入输出格式输入格式： 第一行有两个整数n，m（0≤n≤500000，1≤m≤500000）。n代表皇家花园的树木的总数，m代表骑士们询问的次数。 文件接下来的n行，每行都有两个整数xi，yi，代表第i棵树的坐标（0≤xi，yi≤10000000）。 文件的最后m行，每行都有四个整数aj，bj，cj，dj，表示第j次询问，其中所问的矩形以（aj，bj）为左上坐标（cj，dj）为右下坐标。 输出格式： 共输出m行，每行一个整数，即回答国王以（aj，bj）和（cj，dj）为界的矩形里有多少棵树。 输入输出样例输入样例#1： 123453 10 0 0 11 00 0 1 1 输出样例#1： 13 题解首先可以将查询离线，然后用扫描线降维。 首先统计个数显然满足可减性，因此就可以把每个询问看成是两个横坐标左端点是1的差。 对纵坐标离散化后使用权值树状数组将点一个一个插进去，由于横坐标排序后升序，所以用一个指针表示当前处理到的询问，假如当前点横坐标大于询问的横坐标，就先查询询问的答案。 这道水题就做完了。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005struct Node&#123; int x , y; bool operator&lt;(const Node&amp; p)const&#123; return x &lt; p.x; &#125;&#125;p[maxn];struct Query&#123; int x , y1 , y2, type ,k; bool operator&lt;(const Query&amp; p)const&#123; return x &lt; p.x; &#125;&#125;q[maxn&lt;&lt;1];struct T&#123; int v , k ,type; bool operator&lt;(const T&amp; x)const&#123; return v &lt; x.v; &#125;&#125;o[maxn&lt;&lt;3];struct Fenwick_tree&#123; int tr[maxn&lt;&lt;2] , range; inline int query(int x)&#123; if(x==0) return 0; int ans = 0; for(int i = x ; i ; i -= i &amp; -i) ans += tr[i]; return ans; &#125; inline void update(int p , int v)&#123; for(int i = p ; i &lt;= range ; i += i &amp; -i) tr[i] += v; &#125;&#125;tr;int ans[3][maxn] , n , m , num , tot , cnt;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); for(int i = 1 ; i &lt;= m ; ++i)&#123; int x1 , y1 , x2 , y2; scanf("%d%d%d%d",&amp;x1,&amp;y1 ,&amp;x2, &amp;y2); q[++num].x = x1 -1, q[num].type = 1 , q[num].y1 = y1 , q[num].y2 = y2 , q[num].k = i; q[++num].x = x2 , q[num].type = 2 , q[num].y1 = y1 , q[num].y2 = y2 , q[num].k = i; &#125; std::sort(q+1,q+num+1); std::sort(p+1,p+n+1); for(int i = 1; i &lt;= n ; ++i)&#123; o[++cnt].v = p[i].y; o[cnt].k = i; o[cnt].type = 1; &#125; for(int i = 1 ; i &lt;= num ; ++i) &#123; o[++cnt].v = q[i].y1; o[cnt].k = i; o[cnt].type = 2; o[++cnt].v = q[i].y2; o[cnt].k = i; o[cnt].type = 3; &#125; std::sort(o+1,o+cnt+1); o[0].v = 19260817; for(int i = 1 ; i &lt;= cnt ; ++i) &#123; if(o[i].v != o[i-1].v) ++tot; if(o[i].type == 1) p[o[i].k].y = tot; else if(o[i].type == 2) q[o[i].k].y1 = tot; else q[o[i].k].y2 = tot; &#125; tr.range = tot; int L = 1; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(p[i].x &gt; q[L].x)&#123; while(q[L].x &lt; p[i].x &amp;&amp; L &lt;= 2*m) ans[q[L].type][q[L].k] = tr.query(q[L].y2) - tr.query(q[L].y1-1) , ++L; &#125; tr.update(p[i].y,1); &#125; for(int i = L ; i &lt;= 2*m ; ++i) ans[q[i].type][q[i].k] = tr.query(q[i].y2) - tr.query(q[i].y1-1); for(int i= 1; i &lt;= m ; ++i) printf("%d\n",ans[2][i] - ans[1][i]);&#125; 准备学习后缀数组，看的同时突然领悟道夏令营讲的那个双关键字桶排其实就是类似于后缀数组（当然不完全一样），于是写了个基数排序。。（stacall小姐姐真强） 基数排序 原理就是对当前关键字进行桶排并对应其排名。对于当前关键字，如果我们倒着扫就相当于已经利用了前面的关键字的排序结果，然后按照现在的关键字为第一关键字，前面所有为第二关键字来排序。 Code： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 10000005const int base = (1 &lt;&lt; 16) - 1;const int bits = 16;int a[maxn] , b[maxn] , tot[base+1] , n;inline int getKey(int x , int isFir)&#123; return (x&gt;&gt;(isFir*bits)) &amp; base;&#125;inline void Radix_sort()&#123; int *x = a , *y = b; for(int key = 0 ; key &lt; 2 ; ++key) &#123; for(int i = 0 ; i &lt;= base ; ++i) tot[i] = 0; for(int i = 0 ; i &lt; n ; ++i) tot[getKey(x[i] , key)] ++; for(int i = 1 ; i &lt;= base ; ++i) tot[i] += tot[i-1]; for(int i = n - 1 ; ~i ; --i) y[--tot[getKey(x[i],key)]] = x[i]; std::swap(x,y); &#125; for(int i = 0 ; i &lt; n ; ++i) printf("%d ",a[i]);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 0 ; i &lt; n ; ++i) scanf("%d",&amp;a[i]); Radix_sort();&#125; 这个程序非常易懂，并且如果想要更大数据范围排序只需要改成4关键字循环即可。 后缀数组上一张浅显易懂清晰的图 设k是当前倍增的值 对于 n-k+1到n这部分，显然是没有第二关键字的，把它们先都加进y数组中 然后对于 SA_i > k ，都可以作为 SA_i-k的第二关键字。 上一次处理的就是第一关键字，然后基数排序即可。 剩下的就是代码实现了，不算很难。 今天大脑有点不清醒，这么简单的都想了半天，所以今天好好学文化课得了。 好不容易边理解边写，交上去发现自己常数还挺小。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 1000006char s[maxn];int n , m , SA[maxn] , RK[maxn] , c[maxn] , x[maxn] , y[maxn];inline void Suffix_Array()&#123; for(int i = 1 ; i &lt;= n ; ++i) c[x[i] = s[i]] ++; for(int i = 1 ; i &lt;= m ; ++i) c[i] += c[i-1]; for(int i = n ; i &gt;= 1 ; --i) SA[c[x[i]]--] = i; for(int k = 1 ; k &lt;= n ; k &lt;&lt;= 1) &#123; int num = 0; for(int i = n - k + 1 ; i &lt;= n ; ++i) y[++num] = i; for(int i = 1 ; i &lt;= n ; ++i) if(SA[i] &gt; k) y[++num] = SA[i] - k; for(int i = 1 ; i &lt;= m ; ++i) c[i] = 0; for(int i = 1 ; i &lt;= num ; ++i) c[x[i]] ++; for(int i = 1 ; i &lt;= m ; ++i) c[i] += c[i-1]; for(int i = n ; i &gt;= 1 ; --i) SA[c[x[y[i]]]--] = y[i] , y[i] = 0; std::swap(x,y); x[SA[1]] = 1; num = 1; for(int i = 2 ; i &lt;= n ; ++i) x[SA[i]] = (y[SA[i]] == y[SA[i-1]] &amp;&amp; y[SA[i]+k] == y[SA[i-1]+k]) ? num : ++num; m = num; if(num == n) break; &#125; for(int i = 1 ; i &lt;= n ; ++i) printf("%d ",SA[i]);&#125; int main()&#123; scanf("%s",s+1); n = std::strlen(s + 1) , m = 122; Suffix_Array();&#125; [TJOI2007]调整队形题目背景学校艺术节上，规定合唱队要参加比赛，各个队员的衣服颜色不能很混乱：合唱队员应排成一横排，且衣服颜色必须是左右对称的。 例如：“红蓝绿蓝红”或“红蓝绿绿蓝红”都是符合的，而“红蓝绿红”或“蓝绿蓝红”就不符合要求。 合唱队人数自然很多，仅现有的同学就可能会有3000个。老师希望将合唱队调整得符合要求，但想要调整尽量少，减少麻烦。以下任一动作认为是一次调整： 题目描述1、在队伍左或右边加一个人（衣服颜色依要求而定）； 2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）； 3、剔掉一个人； 4、让一个人换衣服颜色； 老师想知道就目前的队形最少的调整次数是多少，请你编一个程序来回答他。 因为加入合唱队很热门，你可以认为人数是无限的，即随时想加一个人都能找到人。同时衣服颜色也是任意的。 输入输出格式输入格式： 第一行是一个整数n(1&lt;=n&lt;=3000)。 第二行是n个整数，从左到右分别表示现有的每个队员衣服的颜色号，都是1到3000的整数。 输出格式： 一个数，即对于输入队列，要调整得符合要求，最少的调整次数。 输入输出样例1251 2 2 4 3 12 题解这道题就是我凭感觉瞎写的转移啊。。。 显然题意没法让前i个最优，不是划分dp什么的，就试试区间dp。 对于当前区间，我们只需要确保两个端点被处理地最优（显然易得，不会证明） 要么我们删除左边，要么删除右边，要么改变下颜色呗（改变颜色并不需要考虑改变成哪边的颜色。。我一开始sb还考虑这个，后面转移自然包括改变左边或右边颜色。) f_{i,j} = min\{f_{i+1,j-1},f_{i+1,j},f_{i,j-1}\}+1当然这是在两边不相等的情况下，相等直接从里面的小区间转移就行。 Code:12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 3005int f[maxn][maxn] , n , p[maxn];int main()&#123; std::memset(f,0x3f,sizeof(f)); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]) ,f[i][i] = 0; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt; i ; ++j) f[i][j] = 0; for(int k = 1 ; k &lt; n ; ++k)&#123; for(int j = 1 ; j + k &lt;= n ; ++j)&#123; int to = k + j; if(p[j] == p[to]) f[j][to] = f[j+1][to-1]; else f[j][to] = std::min(f[j+1][to-1] + 1, std::min(f[j+1][to] + 1 , f[j][to-1] + 1)); &#125; &#125; printf("%d",f[1][n]);&#125; [TJOI2008]公共子串题目描述一个字符串的子串是在这个串基础上去掉0个或者若干个字符所形成的，例如abc, aa和abbc都是字符串aabbcc的子串，而aba不是。 现给你三个字符串，请问他们三个共同含有多少种子串（不算空串）? 注意： 有些相同的公共子串尽管出现在不同的位置，但仍算1种，详见样例。 输入输出格式输入格式： 每组测试数据只有3行，每行都是一个只包含有小写字母的字符串。 输出格式： 输出3个字符串共有的公共子串种类数。 输入输出样例输入样例#1： 123apartmentapacheapproach 输出样例#1： 16 说明3个字符串共有的公共子串有： “a”, “p”, “ap”, “pa”, “aa”, “apa”。 其中子串 “a” 有多个，但由于统计的是公共子串种类，所以 “a” 只算1种子串。 100%的数据中，字符串的长度不超过100。字符串中只含有小写字母。 题解一道很经典的方案数dp。 显然设 f_{i,j,k}表示第一个字符串前i位，第二个前j位，第三个前k位本质不同子序列的个数。 但是要求不能重复。。。这个我不会了，然后去翻了翻题解qwq。 发现假如想去重，可以试着枚举每一个结尾字符$c$，然后在枚举三个字符串的同时记录每个字符串出现每个字符最后一次的位置。 f_{i,j,k} = f_{i',j',k'}+1加的1就是它自己，其他的方案由其前面的公共方案数组成，可以保证不重不漏。（需要想一想） Code：12345678910111213141516171819202122232425262728293031#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 105#define ll long longll f[maxn][maxn][maxn] , ls[3][maxn&lt;&lt;1];int l1 , l2 , l3;char s1[maxn] , s2[maxn] , s3[maxn];int main()&#123; scanf("%s",s1+1); scanf("%s",s2+1); scanf("%s",s3+1); int l1 = std::strlen(s1+1) , l2 = std::strlen(s2+1) , l3 = std::strlen(s3+1); for(int i = 1 ; i &lt;= l1 ; ++i)&#123; ls[0][s1[i]] = i; std::memset(ls[1],0,sizeof(ls[1])); for(int j = 1 ; j &lt;= l2 ; ++j)&#123; ls[1][s2[j]] = j; std::memset(ls[2],0,sizeof(ls[2])); for(int k = 1 ; k &lt;= l3 ; ++k)&#123; ls[2][s3[k]] = k; for(int x = 'a' ; x &lt;= 'z' ; ++x) if(ls[0][x] &amp;&amp; ls[1][x] &amp;&amp; ls[2][x]) f[i][j][k] += f[ls[0][x]-1][ls[1][x]-1][ls[2][x]-1] + 1; &#125; &#125; &#125; printf("%lld",f[l1][l2][l3]);&#125; 关于模板类Template的基本用法一般用于函数，也可以用于类，主要关键字是typename 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100003template&lt;typename T&gt;inline void read(T&amp; x)&#123; char ch = getchar(); x = ch - 48;&#125;template&lt;typename T&gt;struct Stack&#123; T x[maxn]; int tot; inline void push(T&amp; g)&#123; x[++tot] = g; &#125; inline T top()&#123; return x[tot]; &#125;&#125;;Stack&lt;int&gt; st;int main()&#123; int n; read&lt;int&gt;(n); st.push(n); std::cout&lt;&lt;st.top();&#125; 总结：dp水平远远不够啊。。]]></content>
      <tags>
        <tag>离散化 权值树状数组 扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 10]]></title>
    <url>%2F2018%2F12%2F02%2F2018.12.2%2F</url>
    <content type="text"><![CDATA[那些上演着繁华不肯谢幕的年华里开出一朵地老天荒的花。—From zyf 学姐 [CQOI2017]小Q的棋盘题目描述小 Q 正在设计一种棋类游戏。 在小 Q 设计的游戏中，棋子可以放在棋盘上的格点中。某些格点之间有连线，棋子只能在有连线的格点之间移动。整个棋盘上共有 V 个格点，编号为0,1,2 … , V− 1，它们是连通的，也就是说棋子从任意格点出发，总能到达所有的格点。小 Q 在设计棋盘时，还保证棋子从一个格点移动到另外任一格点的路径是唯一的。 小 Q 现在想知道，当棋子从格点 0 出发，移动 N 步最多能经过多少格点。格点可以重复经过多次，但不重复计数。 输入输出格式输入格式： 第一行包含2个正整数V, N，其中 V 表示格点总数，N 表示移动步数。 接下来V − 1行，每行两个数a_i,b_iai,bi，表示编号为a_i,b_iai,bi的两个格点之间有连线。 输出格式： 输出一行一个整数，表示最多经过的格点数量。 输入输出样例输入样例#1： 123455 21 02 13 24 3 输出样例#1： 13 输入样例#2： 1234567899 50 10 22 64 28 11 33 73 5 输出样例#2： 15 说明【输入输出样例 1 说明】 从格点 0 出发移动 2 步。经过 0, 1, 2 这 3 个格点。 【输入输出样例 2 说明】 一种可行的移动路径为 0 → 1 → 3 → 5 → 3 → 7，经过 0, 1, 3, 5, 7 这 5 个格点。 【数据规模与约定】 对于 100%的测试点，N,V ≤ 100, 0 ≤a_i,b_i&lt; V 题解我想到了一个很不好写的dp做法。。。 设 f(u,k,0/1)表示节点u走k步不回来/回来访问的最大节点数。 对于回来的转移比较简单，因为回到这个点意味着访问完它的子树都要回去，一个纯粹的树上背包。 f(u,k) = max(f(u,k),f(v,t)+f(u,k-t-2))这部分时间复杂度是 O(n^2)但是对于不回来的转移就比较麻烦了，我们需要枚举当前点状态的基础上枚举每个回来的点和其状态，然后对于剩下的步数再做完全背包，时间复杂度在 O(n^4)以上。这样应该能勉强通过。 不过十分难写。。。 可以参考一下别人的代码 他加了一个优化：除掉一颗子树虽然没有办法直接减，但是可以处理f的前后缀最大值数组，然后把儿子看做线性排列每次转移0系列状态就直接用前后缀合并就可以了。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 205;struct edge &#123; int v, next;&#125; e[maxn &lt;&lt; 1];int head[maxn], cnt;void adde(const int &amp;u, const int &amp;v) &#123; e[++cnt] = (edge) &#123;v, head[u]&#125;; head[u] = cnt;&#125;int n, k, u, v, f[maxn][maxn];int Lf[maxn][maxn], Rf[maxn][maxn], g[maxn][maxn];int L[maxn], R[maxn], lst[maxn], tmp[maxn][maxn];void merge(int a[maxn], int b[maxn]) &#123; for(register int j = k; j &gt;= 2; --j) &#123; for(register int l = j - 2; l &gt;= 0; --l) a[j] = max(a[j], a[j - l - 2] + b[l]); &#125;&#125;void DPpref(int u) &#123; int now = lst[u]; if(now == -1) return; while(~L[now]) merge(Rf[L[now]], Rf[now]), now = L[now]; while(~R[now]) merge(Lf[R[now]], Lf[now]), now = R[now];&#125;void DPF(int u, int p) &#123; int last = -1; for(register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v == p) continue; if(~last) lst[u] = v, L[v] = last, R[last] = v; last = v, DPF(v, u); merge(f[u], f[v]); memcpy(Rf[v], f[v], sizeof(f[v])); memcpy(Lf[v], f[v], sizeof(f[v])); &#125; DPpref(u); for(register int j = k; j &gt;= 0; --j) if(f[u][j]) ++f[u][j]; f[u][0] = 1;&#125;void DPG(int u, int p) &#123; for(register int i = head[u]; i; i = e[i].next) &#123; int v = e[i].v; if(v == p) continue; DPG(v, u); if(~L[v]) merge(tmp[v], Lf[L[v]]); if(~R[v]) merge(tmp[v], Rf[R[v]]); for(register int j = k; j &gt;= 1; --j) &#123; for(register int l = j - 1; l &gt;= 0; --l) tmp[v][j] = max(tmp[v][j], tmp[v][j - l - 1] + g[v][l]); g[u][j] = max(g[u][j], tmp[v][j]); &#125; &#125; for(register int j = k; j &gt;= 0; --j) if(g[u][j]) ++g[u][j]; g[u][0] = 1;&#125;int main() &#123; memset(L, -1, sizeof(L)); memset(R, -1, sizeof(R)); memset(lst, -1, sizeof(lst)); scanf("%d%d", &amp;n, &amp;k); for(register int i = 1; i &lt; n; ++i) scanf("%d%d", &amp;u, &amp;v), adde(u, v), adde(v, u); DPF(0, -1); DPG(0, -1); printf("%d", g[0][k]); return 0;&#125; 我的暴力dp不知怎么错了。。。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 105int head[maxn] , cnt , f[maxn][maxn][2] , n , m , sz[maxn];struct edge&#123; int next , to;&#125;e[maxn&lt;&lt;1];inline void add(int x, int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;void dfs(int u , int fa)&#123; f[u][0][1] = f[u][0][0] = 1; sz[u] = 1; for(int i = head[u] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fa) continue; dfs(v ,u); sz[u] += sz[v]; for(int j = sz[u] ; j &gt;= 1; --j) for(int k = std::min(sz[v] , j - 2) ; k &gt;= 0 ; --k) if(j-k-2 &gt;= 0) f[u][j][1] = std::max(f[u][j][1] , f[v][k][1] + f[u][j-k-2][1]); &#125; for(int i = head[u] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fa) continue; for(int j = std::min(sz[u] , m) ; j &gt;= 1 ; --j) &#123; int tmp = 0; for(int k = 0 ; k &lt;= j &amp;&amp; k &lt;= sz[v] &amp;&amp; k &lt;= m - 1 &amp;&amp; j - k - 1 &gt;= 0; ++k) &#123; int rem = j - k - 1; for(int p = head[u] ; p ; p = e[p].next) &#123; if(p == fa || p == v) continue; for(int step = 1 ; step &lt;= sz[p] ; ++step) if(rem-step-2&gt;=0) tmp = std::max(tmp , f[v][k][0] + f[u][rem-step-2][1] + f[p][step][1]); &#125; &#125; f[u][j][0] = tmp; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x ,y; for(int i = 1 ; i &lt;= n - 1 ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); add(x+1,y+1) , add(y+1,x+1); &#125; dfs(1,0); printf("%d",std::max(f[1][m][1], f[1][m][0])+1);&#125; UVA1185 Big Number题意翻译题目背景没有营养，大意为求一个大数（很大很大）的阶乘的位数（即这个数的阶乘是几位数） 题解刚学的log函数性质emm Code： 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 10000007int T , n;double lg[maxn];int main()&#123; for(int i = 1 ; i &lt;= 1e7 ; ++i) lg[i] = (double)log10(i); for(int i = 1 ; i &lt;= 1e7 ; ++i) lg[i] += lg[i-1]; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); printf("%d\n",(int)lg[n]+1); &#125;&#125; 9:00了，今天除了道水题就做了一道题。。。死磕不是个好办法啊qwq，]]></content>
      <tags>
        <tag>树形dp 贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 9]]></title>
    <url>%2F2018%2F12%2F01%2F2018.12.1%2F</url>
    <content type="text"><![CDATA[只要心中有景、何处不是花香满径。 今天和昨天晚上补了补数学物理。 感觉自己水平还真是下降不少。。。 今天去书店想买数学物理提高的题结果没找到，就买了两本化学和地理的基础教辅。 月考化学地理不及格就尴尬了，尤其是地理基本没上过几节课 下午还得去图书馆当志愿者，又是形式主义的残余。 然后明天早晨又得滚回学校。。 今天不是很想学OI，补文化课去了。 下午去做了3小时的所谓志愿者活动，看了几个经典英文笑话，然后一直假装认真的转啊转。。 感觉这东西存在的意义就是浪费你的39个小时。 晚上收拾完东西已经9点了，对着微微发亮的屏幕发呆。 高考政策一年比一年恶心，语文各种刁难人政治化，数学越来越简单从而没有区分度。 似乎奥赛和自主招生是不可避免的路。 其实也不用太灰心啊，wqy大佬似乎就是榜样啊（不过也许人家第一年只是去玩的。。） NOIp 2019加油。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two-Week Post 1]]></title>
    <url>%2F2018%2F12%2F01%2FTwo%20Week%20Post%201%20On%2020181201%2F</url>
    <content type="text"><![CDATA[Welcome here Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 8]]></title>
    <url>%2F2018%2F11%2F30%2F2018.11.30%2F</url>
    <content type="text"><![CDATA[你知道人类最大的武器是什么吗？是豁出去的决心。 数学小周考又炸锅了。。。本来能全对的选择填空扣了20分，结果卡了及格线qwq 数学老师碰到我还鼓励我下次稳一点争取考140。。 回去买本数学题和物理题了，早点准备月考，感觉那些高考不考的科学的太好的确没什么意义。 来机房先过了道二分答案的水题。。 「一本通 1.2 例 1」愤怒的牛题目描述原题来自：USACO 2005 Feb. Gold 农夫约翰建造了一座有 nn 间牛舍的小屋，牛舍排在一条直线上，第 ii 间牛舍在 x_ixi 的位置，但是约翰的 mm 头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，因此决定把每头牛都放在离其它牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。 牛们并不喜欢这种布局，而且几头牛放在一个隔间里，它们就要发生争斗。为了不让牛互相伤害。John 决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是多少呢？ 输入格式第一行用空格分隔的两个整数 nn 和 mm； 第二行为 nn 个用空格隔开的整数，表示位置 x_ixi。 输出格式输出仅一个整数，表示最大的最小距离值。 样例样例输入125 31 2 8 4 9 样例输出13 样例解释把牛放在 11, 44 ,88 这样最小距离是 33 。 数据范围与提示 2 \leq n \leq 10^5 ， 0 \leq x_i \leq 10^9Code:1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int x[maxn] , n , m;inline bool check(int ans)&#123; int tot = 0 , cur = 0; for(int i = 2 , cur = 0; i &lt;= n ; ++i) &#123; cur += x[i] - x[i-1]; if(cur &gt;= ans) cur = 0 , ++tot; &#125; if(tot &gt;= m - 1) return true; else return false;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;x[i]); std::sort(x+1,x+n+1); int l = 0 , r = 100000000 , ans = 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(check(mid)) ans = mid , l = mid + 1; else r = mid - 1; &#125; printf("%d",ans);&#125; [USACO14JAN]记录奥林比克题目描述Being a fan of all cold-weather sports (especially those involving cows),Farmer John wants to record as much of the upcoming winter Moolympics as possible. The television schedule for the Moolympics consists of N different programs(1 &lt;= N &lt;= 150), each with a designated starting time and ending time. FJ has a dual-tuner recorder that can record two programs simultaneously. Please help him determine the maximum number of programs he can record in total. 农民约翰热衷于所有寒冷天气的运动（尤其是涉及到牛的运动）， 农民约翰想录下尽可能多的电视节目。 为moolympics电视时间表由N个不同的节目 （1 &lt; = n＝150），每个具有指定的开始时间和结束时间。FJ 有一个双调谐器录音机，可以同时录制两个节目。 请帮助他确定他能录制的节目的最大数量。 输入输出格式输入格式： * Line 1: The integer N. * Lines 2..1+N: Each line contains the start and end time of a single program (integers in the range 0..1,000,000,000). 第1行：整数n。 第2行.. 1 + n：每行包含单个的开始和结束时间 程序（范围为0…1000000000的整数）。 输出格式： * Line 1: The maximum number of programs FJ can record. 仅一行，节目FJ可以记录的最大数量。 输入输出样例输入样例#1： 123456760 36 73 101 52 81 9 输出样例#1： 14 说明INPUT DETAILS: The Moolympics broadcast consists of 6 programs. The first runs from time 0 to time 3, and so on. OUTPUT DETAILS: FJ can record at most 4 programs. For example, he can record programs 1 and 3 back-to-back on the first tuner, and programs 2 and 4 on the second tuner. Source: USACO 2014 January Contest, Silver 题解想出一个感觉很合理的贪心策略似乎并不难。 贪心需要满足无后效性，因此在正着枚举的时候右端点必须单调增，所以排序。 然后能让第一个听就让第一个听，不然就尽量让第二个听。 为什么这个简单的贪心策略是正确的呢？ 假设只有一个显然是正确的，只需要考虑决策的包容性。 假设现在有两个，如果当前物品可以放进第一个，那么按上述理论放入即可。 假设不能放入第一个但是能放入第二个，如果不放后面放入第二个的结束时间会更晚，显然不是最优决策。 又因为我们始终尽量放入第一个，所以R1&gt;=R2，那么显然放入R1不会比R2更差。 这题实际上可以推广到k个。 感觉我需要从进阶指南上学习严谨的贪心证明方法。 时间复杂度 O(nlogn)Code: 12345678910111213141516171819202122232425262728293031// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 305struct Node&#123; int b , e; bool operator&lt;(const Node&amp; x)const&#123; if(e == x.e) return b &gt; x.b; return e &lt; x.e; &#125;&#125;p[maxn];int n , ans;bool vis[maxn];int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].b,&amp;p[i].e); std::sort(p+1,p+n+1); int R1 = -0x7ffff , R2 = -0x7ffff; for(int i = 1 ; i &lt;= n ; ++i) &#123; if(p[i].b &gt;= R1) R1 = p[i].e , ++ans; else if(p[i].b &lt; R1 &amp;&amp; p[i].b &gt;= R2) R2 = p[i].e , ++ans; if(R1 &lt; R2) std::swap(R1,R2); //printf("%d %d %d %d\n",p[i].b,p[i].e,R1,R2); &#125; printf("%d",ans);&#125;]]></content>
      <tags>
        <tag>dp 图论 随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 7]]></title>
    <url>%2F2018%2F11%2F29%2F2018.11.29%2F</url>
    <content type="text"><![CDATA[过程和结局都有了、再去纠缠、连自己都觉得贪婪。 「一本通 5.6 例 2」任务安排 3输入格式第一行两个整数，分别为 N,SN,S；接下来 NN 行每行两个整数 T_i,C_iTi​,Ci​。 数据范围与提示对于全部数据， 1\le N\le 3\times 10^5,1\le S\le 2^8,|T_i|\le 2^8,0\le C_i\le 2^8题解这道题的斜率不再单增，但是后面的表达式依然与 f_i单调。 所以我们依旧维护每个点 (s_i,f_i)的斜率单调，使用单调栈即可，由于需要支持随机访问栈中元素，请手写一个栈。 然后二分一个最“凸”点即可。 二分边界细节及其恶心，这次终于靠着大量调试代码1个小时内调试出来了。 按照格式输出大量调试信息！ Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 300005#define LL long longLL f[maxn] , t[maxn] , s[maxn];int n , T;struct Stack&#123; int l , r , p[maxn]; Stack()&#123; l = 1 , r = 0; std::memset(p,0,sizeof(p)); &#125; inline void push_back(int x)&#123; p[++r] = x; &#125; inline void pop_back()&#123; p[r] = 0; --r; &#125; inline int size()&#123; return r - l + 1; &#125; inline int&amp; operator[](int x)&#123; return p[r-x+1]; &#125; inline int&amp; operator()(int x)&#123; return p[l+x-1]; &#125; inline int calc(int k) &#123; //puts("The find of"); int curL = l , curR = r; while(curL &lt;= curR) &#123; int mid = curL + curR &gt;&gt; 1; if(mid == l &amp;&amp; f[p[mid+1]]-f[p[mid]] &gt; k*(s[p[mid+1]]-s[p[mid]])) return p[mid]; else if(mid == l &amp;&amp; f[p[mid+1]]-f[p[mid]] &lt;= k*(s[p[mid+1]]-s[p[mid]])) return p[mid+1]; if(mid == r &amp;&amp; f[p[mid]]-f[p[mid-1]] &lt; k*(s[p[mid]]-s[p[mid-1]])) return p[mid]; else if(mid == r &amp;&amp; f[p[mid]]-f[p[mid-1]] &gt;= k*(s[p[mid]]-s[p[mid-1]])) return p[mid-1]; if(f[p[mid]]-f[p[mid-1]]&lt;k*(s[p[mid]]-s[p[mid-1]])&amp;&amp;f[p[mid+1]]-f[p[mid]]&lt;k*(s[p[mid+1]]-s[p[mid]])) curL=mid+1; else if(f[p[mid]]-f[p[mid-1]]&lt;=k*(s[p[mid]]-s[p[mid-1]])&amp;&amp;f[p[mid+1]]-f[p[mid]]&gt;=k*(s[p[mid+1]]-s[p[mid]])) return p[mid]; else curR=mid-1; &#125; &#125; inline void DEBUG() &#123; puts("DEBUG"); puts("Size"); printf("%d\n",r-l+1); puts("THE ELEMENTS"); for(int i = l ; i &lt;= r ; ++i) printf("%d ",p[i]); puts("THE SLOPE"); for(int i = l ; i &lt; r ; ++i) if(s[p[i+1]] != s[p[i]]) printf("%.2lf\n",(double)(f[p[i+1]]-f[p[i]])/(s[p[i+1]]-s[p[i]])); else puts("0"); &#125;&#125;q;int main()&#123; scanf("%d%d",&amp;n,&amp;T); for(int i=1;i&lt;=n;++i)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); t[i]=t[i-1]+x; s[i]=s[i-1]+y; &#125; f[0]=0; q.push_back(0); for(int i=1;i&lt;=n;++i) &#123; int k; k = q.calc(T+t[i]); // printf("The Transfer Point:%d\n",k); f[i] = f[k]+T*(s[n]-s[k])+t[i]*(s[i]-s[k]); // printf("The Best Cost:%lld\n",f[i]); // printf("The Query Slope: %lllld\n",T+t[i]); // q.DEBUG(); // printf("The cur Slope:%.2lf\n",(double)(f[i]-f[q[1]])/(s[i]-s[q[1]])); // puts("FINISH"); // putchar(10); while(q.size()&gt;1&amp;&amp;1ll*(f[i]-f[q[1]])*(s[q[1]]-s[q[2]])&lt;=1ll*(f[q[1]]-f[q[2]])*(s[i]-s[q[1]])) q.pop_back(); q.push_back(i); &#125; printf("%lld\n",f[n]);&#125; [USACO16OPEN]248题目描述Bessie likes downloading games to play on her cell phone, even though she doesfind the small touch screen rather cumbersome to use with her large hooves. She is particularly intrigued by the current game she is playing.The game starts with a sequence of NN positive integers (2 \leq N\leq 2482≤N≤248), each in the range 1 \ldots 401…40. In one move, Bessie cantake two adjacent numbers with equal values and replace them a singlenumber of value one greater (e.g., she might replace two adjacent 7swith an 8). The goal is to maximize the value of the largest numberpresent in the sequence at the end of the game. Please help Bessiescore as highly as possible! 给定一个1*n的地图，在里面玩2048，每次可以合并相邻两个（数值范围1-40），问最大能合出多少。注意合并后的数值并非加倍而是+1，例如2与2合并后的数值为3。 输入输出格式输入格式： The first line of input contains NN, and the next NN lines give the sequence of NN numbers at the start of the game. 输出格式： Please output the largest integer Bessie can generate. 输入输出样例输入样例#1： 1234541112 输出样例#1： 13 说明In this example shown here, Bessie first merges the second and third 1s to obtain the sequence 1 2 2, and then she merges the 2s into a 3. Note that it is not optimal to join the first two 1s. 题解一个还算可以的区间dp？我们不能设 f(i,j)表示i~j内能合成的最大数，而是设 f(i,j)表示这个区间最后合成了什么数（最大的那个数一定是一个连续的区间通过某种顺序合并的），然后标记一下那些数出现过。即可 Code：12345678910111213141516171819202122232425262728293031323334// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 305int f[maxn][maxn] , n , p[maxn];bool mark[maxn];int main()&#123; std::memset(f,-0x7f,sizeof(f)); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n; ++i)&#123; int x; scanf("%d",&amp;x); f[i][i] = x; p[i] = x; &#125; for(int k = 2 ; k &lt;= n ; ++k) for(int i = 1 ; i &lt;= n - k + 1; ++i) &#123; int fr = i , to = i + k - 1; for(int j = fr ; j &lt; to ; ++j) if(f[fr][j] &gt; 0 &amp;&amp; f[j+1][to] &gt; 0 &amp;&amp; f[fr][j] == f[j+1][to]) f[fr][to] = std::max(f[fr][to] , f[fr][j] + 1) , mark[f[fr][to]] = true; &#125; for(int i = 40 ; i &gt;= 1 ; --i) if(mark[i]) &#123; printf("%d",i); break; &#125;&#125; [USACO16OPEN]262144题目描述Bessie likes downloading games to play on her cell phone, even though she doesfind the small touch screen rather cumbersome to use with her large hooves. She is particularly intrigued by the current game she is playing.The game starts with a sequence of NN positive integers (2 \leq N\leq 262,1442≤N≤262,144), each in the range 1 \ldots 401…40. In one move, Bessiecan take two adjacent numbers with equal values and replace them asingle number of value one greater (e.g., she might replace twoadjacent 7s with an 8). The goal is to maximize the value of thelargest number present in the sequence at the end of the game. Pleasehelp Bessie score as highly as possible! Bessie喜欢在手机上下游戏玩（……），然而她蹄子太大，很难在小小的手机屏幕上面操作。 她被她最近玩的一款游戏迷住了，游戏一开始有n个正整数，(2&lt;=n&lt;=262144)，范围在1-40。在一步中，贝西可以选相邻的两个相同的数，然后合并成一个比原来的大一的数（例如两个7合并成一个8)，目标是使得最大的数最大，请帮助Bessie来求最大值。 输入输出格式输入格式： The first line of input contains NN, and the next NN lines give the sequence of NN numbers at the start of the game. 输出格式： Please output the largest integer Bessie can generate. 输入输出样例输入样例#1： 1234541112 输出样例#1： 13 说明In this example shown here, Bessie first merges the second and third 1s to obtain the sequence 1 2 2, and then she merges the 2s into a 3. Note that it is not optimal to join the first two 1s. 题解这个数据范围似乎要求更高效的算法了。。 从上题的思考过程中我们发现它实际上是连续的区间，只不过是按照某种顺序合并的。 然后题意又说两个相同的数合成大1的数，那这不很像倍增吗。。 所以我们记录每个位置合成每个数的右端点在哪，难想吗？挺难想。。（想出一半还是看了题解。。。） 转移到是很好想，当前位置若由比当前数小1的合成，位置就是 f(i-1,f(i-1,j))主要是状态难以思考出来。。 Code:12345678910111213141516171819202122232425262728// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 300005int f[60][maxn], n;bool mark[106];int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i)&#123; int x; scanf("%d", &amp;x); f[x][i] = i + 1; &#125; for(int i = 1 ; i &lt;= 59 ; ++i) for(int j = 1 ; j &lt;= n ; ++j) &#123; if(!f[i][j]) f[i][j] = f[i-1][f[i-1][j]]; if(f[i][j]) mark[i] = true; &#125; for(int i = 59 ; i &gt;= 1 ; --i) if(mark[i])&#123; printf("%d",i); break; &#125;&#125; [USACO16OPEN]分割田地Splitting the Field题目描述Farmer John’s NN cows (3 \leq N \leq 50,0003≤N≤50,000) are all located at distinct positions in his two-dimensional field. FJ wants to enclose all of the cows with a rectangular fence whose sides are parallel to the x and y axes, and hewants this fence to be as small as possible so that it contains every cow (cowson the boundary are allowed). FJ is unfortunately on a tight budget due to low milk production last quarter.He would therefore like to enclose a smaller area to reduce maintenance costs,and the only way he can see to do this is by building two enclosures instead of one. Please help him compute how much less area he needs to enclose, in total,by using two enclosures instead of one. Like the original enclosure, the two enclosures must collectively contain all the cows (with cows on boundaries allowed), and they must have sides parallel to the x and y axes. The two enclosures are not allowed to overlap — not even on their boundaries. Note that enclosures of zero area are legal, for example if an enclosure has zero width and/or zero height.在一个二维的牧场中，Farmer John的N（3&lt;=N&lt;=50000）头牛都各占一席。他想用边平行于x轴和y轴的矩形围栏围住所有牛，并且要让围栏尽可能小（牛可以在边界线上）。 不幸地，由于Farmer John的奶牛产量惨淡，导致最后一个季度预算紧张。因此，他希望封闭一个较小的地区来减少维修的费用，他能看到的唯一方法就是修建两个围栏而不是建一个。请编程告诉他用两个围栏比用一个围栏总共能够节省多少需要围住的面积。同样地，用两个围栏的时候必须围住所有的牛（牛同样可以在边界上），边也要平行于x轴和y轴。两个围栏不允许重叠（边界也不能）。注意面积为零是合法的，例如一个围栏有着长度为零的宽或长度为零的长（一条线）。 输入输出格式输入格式： The first line of input contains NN. The next NN lines each contain two integers specifying the location of a cow. Cow locations are positive integers in the range 1 \ldots 1,000,000,0001…1,000,000,000. 输出格式： Write a single integer specifying amount of total area FJ can save by using two enclosures instead of one. 输入输出样例输入样例#1： 123456764 28 101 19 1214 72 3 输出样例#1： 1107 题解一道简单的排序题。 显然对于一些点用一个最小矩形覆盖就是 (x_{max}-x_{min})*(y_{max}-y_{min})所以一个矩形覆盖的面积如何计算就不用说了。 那么两个矩形最优情况是什么呢？ 一定是在那些点中间分开的两部分！这完全就是画图可知。。。 那么我们是可以O(n)枚举这些矩形组合情况的。 首先按x坐标排序。 然后预处理出 f_{min},f_{max},g_{min},g_{max}分别表示前k个点纵坐标最大最小值，后k个点纵坐标最大最小值。 那么每次是可以O(1)计算每种矩形组合的面积的，取最小值。 完了吗?当然没有，我们还可以横着分！。 再按y坐标排序，然后相同做法一直取最小值。 一开始居然把单调队列写错了，不该写那个没用的pop_front() Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define maxn 50005#define LL long longint fmax[maxn] , fmin[maxn] , gmax[maxn] , gmin[maxn] , n;LL S1 , S2 , ymax , ymin;struct Queue&#123; int p[maxn] ,l ,r; Queue()&#123; l = 1 , r = 0; std::memset(p,0,sizeof(p)); &#125; inline void push_back(int x)&#123; p[++r] = x; &#125; inline void pop_front()&#123; p[l++]=0; &#125; inline void pop_back()&#123; p[r--] = 0; &#125; inline int size()&#123; return r -l + 1; &#125; inline int front()&#123; return p[l]; &#125; inline int back()&#123; return p[r]; &#125; inline void clear()&#123; std::memset(p,0,sizeof(p)); l = 1 , r = 0; &#125;&#125;qmax , qmin;struct Node&#123; int x , y; bool operator &lt; (const Node&amp; p)const&#123; return x &lt; p.x; &#125;&#125;t[maxn];bool cmp(Node a , Node b)&#123; return a.y &lt; b.y;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;t[i].x,&amp;t[i].y); std::sort(t+1,t+n+1);// puts("Sorted by x");// for(int i = 1 ; i &lt;= n ; ++i)// printf("%d%c",t[i].y,(i==n)?10:32); qmax.push_back(1); qmin.push_back(1); fmax[1]=fmin[1]=t[1].y; for(int i = 2 ; i &lt;= n ; ++i)&#123; int now = t[i].y; while(qmax.size() &amp;&amp; t[qmax.back()].y &lt;= now) qmax.pop_back(); qmax.push_back(i); fmax[i]=t[qmax.front()].y; while(qmin.size() &amp;&amp; t[qmin.back()].y &gt;= now) qmin.pop_back(); qmin.push_back(i); fmin[i]=t[qmin.front()].y; &#125; qmax.clear(); qmin.clear(); qmax.push_back(n); qmin.push_back(n); gmin[n]=gmax[n]=t[n].y; for(int i = n - 1; i &gt;= 1 ; --i) &#123; int now = t[i].y; while(qmax.size() &amp;&amp; t[qmax.back()].y &lt;= now) qmax.pop_back(); qmax.push_back(i); gmax[i]=t[qmax.front()].y; while(qmin.size() &amp;&amp; t[qmin.back()].y &gt;= now) qmin.pop_back(); qmin.push_back(i); gmin[i]=t[qmin.front()].y; &#125;// puts("By sorted x , the vals are");// for(int i = 1 ; i &lt;= n ; ++i)// printf("%d %d %d %d\n",fmin[i],fmax[i],gmin[i],gmax[i]); S1 = 0x7ffffffffffffffLL , S2 = 0x7ffffffffffffffLL; int maxx = -0x7fffffff , minn = 0x7fffffff; for(int i = 1 ; i &lt;= n ; ++i) maxx = std::max(maxx , t[i].y) , minn = std::min(minn , t[i].y); S1 = 1ll * (t[n].x - t[1].x) * (maxx - minn); for(int i = 1 ; i &lt; n ; ++i) if(t[i].x != t[i+1].x) S2=std::min(S2,(LL)(1ll*(t[i].x-t[1].x)*(fmax[i]-fmin[i])+1ll*(t[n].x-t[i+1].x)*(gmax[i+1]-gmin[i+1]))); std::sort(t+1,t+n+1,cmp);// puts("By sorted y , the Vals are");// for(int i = 1 ; i &lt;= n ; ++i)// printf("%d%c",t[i].x,(i==n)?10:32); qmin.clear(); qmax.clear(); qmin.push_back(1); qmax.push_back(1); fmin[1] = fmax[1] = t[1].x; for(int i = 2 ; i &lt;= n ; ++i) &#123; while(qmax.size() &amp;&amp; t[qmax.back()].x &lt;= t[i].x) qmax.pop_back(); qmax.push_back(i); fmax[i]=t[qmax.front()].x; while(qmin.size() &amp;&amp; t[qmin.back()].x &gt;= t[i].x) qmin.pop_back(); qmin.push_back(i); fmin[i] = t[qmin.front()].x; &#125; qmax.clear(); qmin.clear(); qmax.push_back(1), qmin.push_back(1); gmin[n] = gmax[n] = t[n].x; for(int i=n-1;i&gt;=1;--i) &#123; while(qmax.size() &amp;&amp; t[qmax.back()].x &lt;= t[i].x) qmax.pop_back(); qmax.push_back(i); gmax[i]=t[qmax.front()].x; while(qmin.size() &amp;&amp; t[qmin.back()].x &gt;= t[i].x) qmin.pop_back(); qmin.push_back(i); gmin[i]=t[qmin.front()].x; &#125; //puts("By sorted y , the vals are"); //for(int i = 1 ; i &lt;= n ; ++i) // printf("%d %d %d %d\n",fmin[i],fmax[i],gmin[i],gmax[i]); for(int i = 1 ; i &lt; n ; ++i) if(t[i].y != t[i+1].y) S2=std::min(S2,1ll*(t[i].y-t[1].y)*(fmax[i]-fmin[i])+1ll*(t[n].y-t[i+1].y)*(gmax[i]-gmin[i])); printf("%lld",S1-S2); &#125; P2647 最大收益题目描述现在你面前有n个物品，编号分别为1，2，3，……，n。你可以在这当中任意选择任意多个物品。其中第i个物品有两个属性Wi和Ri，当你选择了第i个物品后，你就可以获得Wi的收益；但是，你选择该物品以后选择的所有物品的收益都会减少Ri。现在请你求出，该选择哪些物品，并且该以什么样的顺序选取这些物品，才能使得自己获得的收益最大。 注意，收益的减少是会叠加的。比如，你选择了第i个物品，那么你就会获得了Wi的收益；然后你又选择了第j个物品，你又获得了Wj-Ri收益；之后你又选择了第k个物品，你又获得了Wk-Ri-Rj的收益；那么你获得的收益总和为Wi+(Wj-Ri)+(Wk-Ri-Rj)。 输入输出格式输入格式： 第一行一个正整数n，表示物品的个数。 接下来第2行到第n+1行，每行两个正整数Wi和Ri，含义如题目所述。 输出格式： 输出仅一行，表示最大的收益。 输入输出样例12325 23 5 16 说明20%的数据满足：n&lt;=5，0&lt;=Wi,Ri&lt;=1000。 50%的数据满足：n&lt;=15，0&lt;=Wi,Ri&lt;=1000。 100%的数据满足：n&lt;=3000，0&lt;=Wi,Ri&lt;=200000。 样例解释：我们可以选择1号物品，获得了5点收益；之后我们再选择2号物品，获得3-2=1点收益。最后总的收益值为5+1=6。 题解是道贪心+dp。。。 有个看上去很套路的DP： 设前i件物品选j件的最优值是多少。 但是这样很明显是不正确的。 然后写出转移： f_{i,j} = max(f_{i-1,j},f_{i-1,j-1}+v_i-r_i*(j-1))对于确定的j，我们总是希望他的 r_i尽可能小，也就是说对于大的j， r_i要小 因此从大到小排序。 证明：考虑对题目进行一个等价的变换：即选择某个物品后，选择该物品前所有选择的物品的收益减少Ri。 假设存在顺序对，交换后必定不劣。满足决策单调性。 Code： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 3005int n , ans , f[maxn][maxn];inline int max(int x, int y,int z)&#123; int k = x &gt; y ? x :y; return k &gt; z ? k : z;&#125;struct Node&#123; int x , y; bool operator&lt;(const Node&amp; a)const&#123; return y &gt; a.y; &#125;&#125;p[maxn];int main()&#123; scanf("%d",&amp;n); for(int i =1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); std::sort(p+1,p+n+1); for(int i = 1; i &lt;= n ; ++i) f[i][i]=p[i].x; for(int i = 1; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= i ; ++j) f[i][j]=max(f[i-1][j],f[i-1][j-1]+p[i].x-p[i].y*(j-1),f[i][j-1]) , ans = std::max(ans , f[i][j]); printf("%d\n",ans);&#125; [JSOI2008]最大数题目描述现在请求你维护一个数列，要求提供以下两种操作： 1、 查询操作。 语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。 限制：LL不超过当前数列的长度。(L &gt; 0)(L&gt;0) 2、 插入操作。 语法：A n 功能：将nn加上tt，其中tt是最近一次查询操作的答案（如果还未执行过查询操作，则t=0t=0)，并将所得结果对一个固定的常数DD取模，将所得答案插入到数列的末尾。 限制：nn是整数（可能为负数）并且在长整范围内。 注意：初始时数列是空的，没有一个数。 输入输出格式输入格式： 第一行两个整数，MM和DD，其中MM表示操作的个数(M \le 200,000)(M≤200,000)，DD如上文中所述，满足(0&lt;D&lt;2,000,000,000)(0&lt;D&lt;2,000,000,000) 接下来的MM行，每行一个字符串，描述一个具体的操作。语法如上文所述。 输出格式： 对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。 输入输出样例输入样例#1： 1234565 100A 96Q 1A 97Q 1Q 2 输出样例#1： 123969396 说明[JSOI2008] 题解本题仅仅练手，没有任何难度。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 200005#define LL long long#define ls(x) (x&lt;&lt;1)#define rs(x) (x&lt;&lt;1|1)LL m , lastans , mod;struct SegmentTree&#123; LL maxx[maxn&lt;&lt;2] , pos; inline void pushup(int node)&#123; maxx[node] = std::max(maxx[ls(node)] , maxx[rs(node)]); &#125; inline void insert(int p , int l , int r , int node , LL v)&#123; if(l == r) &#123; maxx[node] = v; return; &#125; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) insert(p , l , mid , ls(node) , v); else insert(p , mid +1 , r , rs(node) , v); pushup(node); &#125; inline LL queryMax(int L , int R , int l , int r , int node) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return maxx[node]; int mid = l + r &gt;&gt; 1; LL ans = -0x7fffffffffffffffLL; if(L &lt;= mid) ans = std::max(ans , queryMax(L , R , l , mid , ls(node))); if(R &gt; mid) ans = std::max(ans , queryMax(L , R , mid + 1 , r , rs(node))); return ans; &#125; inline LL query(int l) &#123; return queryMax(pos-l+1,pos,1,m,1); &#125;&#125;sgt;int main()&#123; scanf("%lld%lld",&amp;m,&amp;mod); for(int i = 1 ; i &lt;= m ; ++i) &#123; char ch; std::cin &gt;&gt; ch; if(ch == 'Q')&#123; int L; scanf("%d",&amp;L); printf("%lld\n",lastans = sgt.query(L)); &#125; if(ch == 'A') &#123; LL t; scanf("%lld",&amp;t); t = (t + lastans) % mod; sgt.insert(++sgt.pos,1,m,1,t); &#125; &#125;&#125; 有点累了不写了，学学数学了。 今天海星，调个题都挺迅速，明天又到了大周呢！]]></content>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 6]]></title>
    <url>%2F2018%2F11%2F28%2F2018.11.28%2F</url>
    <content type="text"><![CDATA[在事情未成功之前，人们总说不可能。 「一本通 5.6 例 2」任务安排 2题目描述原题来自：JoyOI TYVJ 1098 有 NN 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。机器会把这 NN 个任务分成若干批，每一批包含连续的若干个任务。从时刻 00 开始，任务被分批加工，执行第i个任务所需的时间是 T_iTi。另外，在每批任务开始前，机器需要 SS 的启动时间，故执行一批任务所需的时间是启动时间 SS 加上每个任务所需时间之和。 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。也就是说，同一批任务将在同一时刻完成。每个任务的费用是它的完成时刻乘以一个费用系数 C_iCi。 请为机器规划一个分组方案，使得总费用最小。 输入格式第一行是 NN。第二行是 SS。 下面 NN 行每行有一对正整数，分别为 T_iTi 和 C_iCi，表示第 ii 个任务单独完成所需的时间是 T_iTi 及其费用系数 C_iCi。 输出格式一个数，最小的总费用。 样例样例输入1234567511 33 24 32 31 4 样例输出1153 样例说明分组方案为 \{1,2\},\{3\},\{4,5\}{1,2},{3},{4,5}，则完成时间为 \{5,5,10,14,14\}{5,5,10,14,14}，费用 C=\{15,10,30,42,56\}C={15,10,30,42,56}，总费用为 153153。 数据范围与提示对于全部数据， 1\le N\le 10^4,0\le S\le 50,1\le T_i,C_i\le 100题解首先根据费用提前计算的思想，可以设 f(i)表示前i项任务分成若干组时的最小值。 f(i) = min\{f(j) + T*(S_n-S_j) + t_i*(S_i-S_j)\}将其变形后变为 f_j = (T + t_i)*S_j + f_i-t_i*S_i-TS_n让后面的部分最小，可以把 (S_J,f_j)的值看成直线上的点，让后面的部分值最小就是截距最小等价于 f_i最小。显然维护下凸壳即可。假如一个点左边线段斜率比给定斜率小，右边比给定斜率大，这个点对于这条直线就是最“凸”的，也就是我们要找的点。 由于直线斜率单增，可以使用单调队列将小于给定斜率的点都弹出，取队头即为最优转移点。 时间复杂度 O(n)Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 300005#define LL long longLL f[maxn] , s[maxn],t[maxn];int n , T;struct queue&#123; int p[maxn] , l , r; queue()&#123; l = 1 , r = 0; std::memset(p,0,sizeof(p)); &#125; inline void push_back(int x)&#123; p[++r] = x; &#125; inline void pop_front()&#123; p[l] = 0 ; ++l; &#125; inline void pop_back()&#123; p[r] = 0 ; --r; &#125; inline int&amp; operator()(int x)&#123; return p[l+x-1]; &#125; inline int&amp; operator[](int x)&#123; return p[r-x+1]; &#125; inline bool empty()&#123; return !(l &lt;= r); &#125; inline int size()&#123; return r - l + 1; &#125; inline void debug()&#123; puts("Start debug"); printf("%d %d\n",p[l],p[r]); &#125;&#125;q;int main()&#123; scanf("%d%d",&amp;n,&amp;T); for(int i = 1 ; i &lt;= n ; ++i) &#123; int x ,y; scanf("%d%d",&amp;x,&amp;y); t[i] = t[i-1] + x; s[i] = s[i-1] + y; &#125; q.push_back(0); std::memset(f,0x7f,sizeof(f)); f[0] = 0; for(int i = 1 ; i &lt;= n ; ++i) &#123; while(q.size() &gt; 1 &amp;&amp; f[q(2)]-f[q(1)] &lt; (s[q(2)]-s[q(1)]) * (T + t[i])) q.pop_front(); f[i] = f[q(1)] - (T + t[i]) * s[q(1)] + s[i] * t[i] + T * s[n]; while(q.size() &gt; 1 &amp;&amp; (f[i]-f[q[1]])*(s[q[1]]-s[q[2]]) &lt;= (f[q[1]]-f[q[2]])*(s[i]-s[q[1]])) q.pop_back(); q.push_back(i); &#125; printf("%lld",f[n]);&#125; 今天做题有点少啊，效率又有待提高。 其实主要原因是上面那题我又调了一天，原因是把变量名打错了。。 GG]]></content>
      <tags>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 5]]></title>
    <url>%2F2018%2F11%2F27%2F2018.11.27%2F</url>
    <content type="text"><![CDATA[忍耐，也是一件美好的事，但前提是你有非常清晰的未来版图，你知道忍耐这一段后，会有什么等着你，你愿意为此暂时收起自己的羽毛。 「一本通 2.4 练习 1」玄武密码题目描述原题来自：JSOI 2012 在美丽的玄武湖畔，鸡鸣寺边，鸡笼山前，有一块富饶而秀美的土地，人们唤作进香河。相传一日，一缕紫气从天而至，只一瞬间便消失在了进香河中。老人们说，这是玄武神灵将天书藏匿在此。 很多年后，人们终于在进香河地区发现了带有玄武密码的文字。更加神奇的是，这份带有玄武密码的文字，与玄武湖南岸台城的结构有微妙的关联。于是，漫长的破译工作开始了。 经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 NN 的序列来描述，序列中的元素分别是 E，S，W，N，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 M 段文字。这里的四象，分别是东之青龙，西之白虎，南之朱雀，北之玄武，对东南西北四向相对应。 现在，考古工作者遇到了一个难题。对于每一段文字，其前缀在母串上的最大匹配长度是多少呢？ 输入格式第一行有两个整数，N 和 M，分别表示母串的长度和文字段的个数；第二行是一个长度为 N 的字符串，所有字符都满足是 E，S，W 和 N 中的一个；之后 M 行，每行有一个字符串，描述了一段带有玄武密码的文字。依然满足，所有字符都满足是 E，S，W 和 N 中的一个。 输出格式输出有 MM 行，对应 MM 段文字。每一行输出一个数，表示这一段文字的前缀与母串的最大匹配串长度。 样例样例输入123457 3SNNSSNSNNSSNNNWSEE 样例输出123420 数据范围与提示对于全部数据， 1\le N\le 10^7,1\le M\le 10^5，保证每一段文字的长度均小于等于 100。 题解还是比较简单的一道AC自动机 + DP（调了3个小时） 本来我想直接写个普通的不带Trie图优化的AC自动机然后直接在Trie树上DP，结果惊讶的发现写错了，还调不出来，甚至怀疑自己学了假的AC自动机。 既然这样就在保留一颗没有变成Trie图的Trie树用来DP就好了。 我们在Trie树上进行AC自动机匹配，由AC自动机原理可知所有访问过的编号大于1的点都是能够在原串上匹配到的字符串，我们把这些点都标记一下。 接下来应该让每个模式串结尾的Trie上节点都向上跳到最深被标记的节点，显然不能暴力跳。 那就从根节点向下递推就好了，设 f(k)表示节点k跳到的深度最大的标记点。对于被标记的点， f(k) = dep(k)没被标记的 f(k) = f(fa(k))但是要注意，模式串有重复！！各种调试最终找到了这个错误。 所以标记要用vector存。 时间复杂度显然是 O(n+m)Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define maxn 10000007int id[205] , idx = -1 , cur , ans[100005] , n , m;char s[maxn] , p[100005][105];struct Trie&#123; int tr[maxn][4] , tot ; std::vector&lt;int&gt; mark[maxn]; Trie()&#123; tot = 1; &#125; inline void insert(char* s , int num) &#123; int u = 1 , len = std::strlen(s); for(int i = 0 ; i &lt; len ; ++i) &#123; int c = id[s[i]]; if(!tr[u][c]) tr[u][c] = ++tot; u = tr[u][c]; &#125; mark[u].push_back(num); &#125; inline int* operator[](int x)&#123; return tr[x]; &#125;&#125;;struct AC_Automaton&#123; int next[maxn] , dep[maxn] , g[maxn] , sz[maxn] ; bool vis[maxn]; Trie tr , base; inline void insert(char* s , int num) &#123; tr.insert(s , num); &#125; inline void getFail() &#123; base = tr; std::queue&lt;int&gt; q; for(int i = 0 ; i &lt; 4 ; ++i) tr[0][i] = 1; q.push(1) , next[1] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int c = 0 ; c &lt; 4 ; ++c) &#123; if(!tr[u][c]) tr[u][c] = tr[next[u]][c]; else q.push(tr[u][c]) , next[tr[u][c]] = tr[next[u]][c]; &#125; &#125; &#125; inline int find(char* s) &#123; int u = 1 , len = std::strlen(s); for(int i = 0 ; i &lt; len ; ++i) &#123; int c = id[s[i]] , k = tr[u][c]; while(k &gt; 1) &#123; vis[k] = true; k = next[k]; &#125; u = tr[u][c]; &#125; &#125; void getSize(int x , int d) &#123; sz[x] = 1; dep[x] = d; for(int i = 0 ; i &lt; 4 ; ++i) if(base[x][i]) getSize(base[x][i] , d + 1) , sz[x] += sz[base[x][i]]; &#125; inline void pre() &#123; getSize(1 , 0); std::queue&lt;int&gt; q; for(int i = 1 ; i &lt;= base.tot ; ++i) if(sz[i] == 1) q.push(i); q.push(1); while(!q.empty()) &#123; int k = q.front(); q.pop(); if(vis[k]) g[k] = dep[k]; for(int i = 0 ; i &lt; 4 ; ++i) &#123; if(!base[k][i]) continue; if(!vis[base[k][i]]) g[base[k][i]] = g[k]; q.push(base[k][i]); &#125; &#125; &#125; void getPrintTrie(int x , int c) &#123; printf("%d %d\n",x,c); for(int i = 0 ; i &lt; 4 ; ++i) if(base[x][i]) getPrintTrie(base[x][i] , i); &#125; inline void print() &#123; puts("The trie:"); getPrintTrie(1 , 'B'); for(int i = 1 ; i &lt;= base.tot ; ++i) printf("%d ", next[i]); puts("Debug finished"); &#125;&#125;aton;int main()&#123; id['N'] = 0 , id['W'] = 1 , id['E'] = 2 , id['S'] = 3; scanf("%d%d",&amp;n,&amp;m); scanf("%s",s+1); for(int i = 1 ; i &lt;= m ; ++i) &#123; ++cur; scanf("%s",p[cur]+1); aton.insert(p[cur]+1,i); &#125; aton.getFail(); //aton.print(); aton.find(s+1); aton.pre(); for(int i = 1 ; i &lt;= aton.base.tot ; ++i) if(aton.base.mark[i].size()) for(int j = 0 ; j &lt; aton.base.mark[i].size() ; ++j) ans[aton.base.mark[i][j]] = aton.g[i]; for(int i = 1 ; i &lt;= m ; ++i) printf("%d\n",ans[i]);&#125; 终于把不带任何优化，完全按照原理匹配的AC自动机调出来了。。。仅仅是因为一个很sb的匹配的错误： AC： 123456789101112131415161718192021inline void find(char* s) &#123; int len = std::strlen(s + 1); int u = 1; for(int i = 1 ; i &lt;= len ; ++i)&#123; int c = s[i] - 97; while(!tr[u][c] &amp;&amp; u &gt; 1) u = next[u]; if(u &gt; 1) u = tr[u][c]; else if(u == 1 &amp;&amp; tr[u][c]) u = tr[u][c]; else u = 1; if(u &gt; 1) &#123; int k = u; while(k &gt; 1) &#123; ans[k] += Ma[k]; k = next[k]; &#125; &#125; &#125; &#125; WA： 123456789101112131415161718192021inline void find(char* s) &#123; int len = std::strlen(s + 1); int u = 1; for(int i = 1 ; i &lt;= len ; ++i)&#123; int c = s[i] - 97; while(!tr[u][c] &amp;&amp; u &gt; 1) u = next[u]; if(u &gt; 1) &#123; int k = u; while(k &gt; 1) &#123; ans[k] += Ma[k]; k = next[k]; &#125; &#125; if(u &gt; 1) u = tr[u][c]; else if(u == 1 &amp;&amp; tr[u][c]) u = tr[u][c]; else u = 1; &#125; &#125; 显然在u转移之后才能统计啊。。不然第一个字符永远没法匹配当然挂了。 以后把bug代码贴出来似乎是个不错的主意。 话说更令人惊奇的是，不带优化的AC自动机比Trie图快了整整两秒。。。怕不是逆优化。 完整的按原理的AC自动机Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#define maxn 1000005#define maxc 26int cur = 1 , n , ans[maxn];char s[maxn] , p[maxn];struct AC_Automaton&#123; int tr[maxn][maxc] , tot , next[maxn] , Ma[maxn] , f[maxn] , g[maxn]; bool vis[maxn]; AC_Automaton()&#123; tot = 1; &#125; inline void init() &#123; tot = 1; std::memset(tr,0,sizeof(tr)); std::memset(next,0,sizeof(next)); std::memset(Ma,0,sizeof(Ma)); std::memset(f,0,sizeof(f)); std::memset(g,0,sizeof(g)); &#125; inline void insert(char* s) &#123; int len = std::strlen(s) , u = 1; for(int i = 0 ; i &lt; len ; ++i)&#123; int c = s[i] - 97; if(!tr[u][c]) tr[u][c] = ++ tot; f[tr[u][c]] = u , g[tr[u][c]] = c , u = tr[u][c]; &#125; Ma[u] ++; &#125; inline void GetFail() &#123; std::queue&lt;int&gt; q; for(int i = 0 ; i &lt; 26 ; ++i) tr[0][i] = 1; q.push(1) , next[1] = 0; while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = 0 ; i &lt; 26 ; ++i)&#123; if(!tr[k][i]) continue; q.push(tr[k][i]); int u = next[k]; while(u &gt; 1 &amp;&amp; !tr[u][i]) u = next[u]; if(u &gt; 1) next[tr[k][i]] = tr[u][i]; else if(u == 1 &amp;&amp; tr[u][i]) next[tr[k][i]] = tr[u][i]; else next[tr[k][i]] = 1; &#125; &#125; &#125; inline void find(char* s) &#123; int len = std::strlen(s + 1); int u = 1; for(int i = 1 ; i &lt;= len ; ++i)&#123; int c = s[i] - 97; while(!tr[u][c] &amp;&amp; u &gt; 1) u = next[u]; if(u &gt; 1) u = tr[u][c]; else if(u == 1 &amp;&amp; tr[u][c]) u = tr[u][c]; else u = 1; if(u &gt; 1) &#123; int k = u; while(k &gt; 1) &#123; ans[k] += Ma[k]; k = next[k]; &#125; &#125; &#125; &#125; inline void print(int k) &#123; std::stack&lt;int&gt; st; while(k &gt; 1) &#123; st.push(g[k]); k = f[k]; &#125; while(!st.empty()) printf("%c",st.top()+97) , st.pop(); putchar(10); &#125; inline void DEBUG() &#123; puts("Start Debug"); for(int i = 2 ; i &lt;= tot ; ++i) &#123; puts("The string is"); print(i); puts("The next string is"); print(next[i]); &#125; puts("End Debug"); &#125; &#125;aton;int main()&#123; while(scanf("%d",&amp;n) != EOF) &#123; std::memset(ans,0,sizeof(ans)); aton.init(); cur = 1; if(n == 0) break; for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%s",p+cur); aton.insert(p+cur); cur += std::strlen(p+cur); &#125; aton.GetFail(); scanf("%s",s+1); aton.find(s); //aton.DEBUG(); int maxx = -0x7ffffff; std::queue&lt;int&gt; str; for(int i = 1 ; i &lt;= aton.tot ; ++i) if(aton.Ma[i]) &#123; if(maxx &lt; ans[i])&#123; while(!str.empty()) str.pop(); str.push(i); maxx = ans[i]; &#125; else if(maxx == ans[i]) str.push(i); &#125; printf("%d\n",maxx); while(!str.empty()) aton.print(str.front()) , str.pop(); &#125;&#125; 「一本通 2.4 练习 2」Censoring题目描述原题来自：USACO 2015 Feb. Gold 有一个长度不超过 10^5105 的字符串 SS。Farmer John 希望在 SS 中删掉 nn 个屏蔽词（一个屏蔽词可能出现多次），这些词记为 t_1\sim t_nt1∼tn。 FJ 在 S 中从头开始寻找屏蔽词，一旦找到一个屏蔽词，FJ 就删除它，然后又从头开始寻找（而不是接着往下找）。FJ 会重复这一过程，直到 S 中没有屏蔽词为止。注意删除一个单词后可能会导致 S 中出现另一个屏蔽词。这 n 个屏蔽词不会出现一个单词是另一个单词子串的情况，这意味着每个屏蔽词在 S 中出现的开始位置是互不相同的，请帮助 FJ 完成这些操作并输出最后的 S。 输入格式第一行包含一个字符串 S；第二行包含一个整数 n；接下来的 n 行，每行包含一个字符串，第 ii 行的字符串是 t_i。 输出格式一行，输出操作后的 SS。保证 SS 不会变成空串。 样例样例输入1234begintheescapexecutionatthebreakofdawn2escapeexecution 样例输出1beginthatthebreakofdawn 数据范围与提示对于全部数据， 1\le \sum |t_i|\le 10^5,1\le |S|\le 10^5保证所有字符串只出现小写字母。 题解感觉有点想法。 首先对模式串建立不带Trie图优化的AC自动机（以后再也不想写Trie图优化了）。。。 然后开始对母串匹配（母串一定要读一个字符串方便操作！qwq） 我们在匹配的时候记录母串当前点u匹配到的自动机上的点 g(u)，然后假如下一位匹配到了模式串我们用字符串函数将其删除，然后回跳指针至这个单词前一位，令匹配指针u指 向$g(u)$，继续完成匹配，和普通AC自动机匹配复杂度相同（每个点最多被访问和删除一次），为 O(n+\sum{m})结果写炸了，以后补代码（咕咕咕）吧。 斜率优化DP先看一道题 「一本通 5.6 例 1」任务安排 1题目描述原题来自：JoyOI TYVJ 1098 有 NN 个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。机器会把这 NN 个任务分成若干批，每一批包含连续的若干个任务。从时刻 00 开始，任务被分批加工，执行第i个任务所需的时间是 T_iTi。另外，在每批任务开始前，机器需要 SS 的启动时间，故执行一批任务所需的时间是启动时间 SS 加上每个任务所需时间之和。 一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。也就是说，同一批任务将在同一时刻完成。每个任务的费用是它的完成时刻乘以一个费用系数 C_iCi。 请为机器规划一个分组方案，使得总费用最小。 输入格式第一行是 N。第二行是 S。 下面 NN 行每行有一对正整数，分别为 T_i和 C_i，表示 ii 个任务单独完成所需的时间是 T_i及其费用系数 C_iCi。 输出格式一个数，最小的总费用。 样例样例输入1234567511 33 24 32 31 4 样例输出1153 样例说明分组方案为 \{1,2\},\{3\},\{4,5\}则完成时间为 \{5,5,10,14,14\}费用 C=\{15,10,30,42,56\}总费用为 153。 数据范围与提示对于全部数据 1\le N\le 5000,0\le S\le 50,1\le T_i,C_i\le 100题解很容易就想到一个 O(n^3)的做法 设 f(n,k)表示前n个任务分p段完成，枚举最后一段人数转移 f(n,p) = min\{f(k,p-1) + (p*S + S_{t_i}-S_{t_k})*S_{C_i}\}Code: 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 5005#define ll long longll f[maxn][maxn] , n , s[maxn] , t[maxn] , S;int main()&#123; scanf("%lld%lld",&amp;n,&amp;S); for(int i = 1 ; i &lt;= n ; ++i) &#123; int x , y; scanf("%d%d",&amp;y,&amp;x); s[i] = s[i-1] + x , t[i] = t[i-1] + y; &#125; std::memset(f,0x7f,sizeof(f)); f[0][0] = 0; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= i ; ++j) for(int k = 0 ; k &lt;= i ; ++k) f[i][j] = std::min(f[i][j] , f[k][j-1] + 1ll * (s[i] - s[k]) * (t[i] + j * S)); ll ans = 1ll*0x7fffffffff; for(int i = 1 ; i &lt;= n ; ++i) ans = std::min(ans , f[n][i]); printf("%lld",ans);&#125; 这时有这样一种思想非常重要，在以前的贪心算法中也曾应用（比如种树），就是费用提前计算的思想。 我们设f(k)表示前k项分成若干段的最小费用。 枚举最后的一段转移。 f(i) = min\{f(j) + T * (S_{c_n} - S_{c_j}) + t_i * (S_{c_i}-S_{c_j}) \}让我再体会一下这种神奇的思想。 时间复杂度 O(n^2)Code:123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 5005#define ll long longll f[maxn] , n , s[maxn] , t[maxn] , S;int main()&#123; scanf("%lld%lld",&amp;n,&amp;S); for(int i = 1 ; i &lt;= n ; ++i) &#123; int x , y; scanf("%d%d",&amp;y,&amp;x); s[i] = s[i-1] + x , t[i] = t[i-1] + y; &#125; std::memset(f,0x7f,sizeof(f)); f[0] = 0; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 0 ; j &lt;= i ; ++j) f[i] = std::min(f[i] , f[j] + S * (s[n] - s[j]) + t[i] * (s[i] - s[j])); printf("%lld",f[n]);&#125;]]></content>
      <tags>
        <tag>AC自动机 自动机dp dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RBZ Study Plan]]></title>
    <url>%2F2018%2F11%2F27%2FRBZ%20Study%20Plan%2F</url>
    <content type="text"><![CDATA[Welcome to visit! Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 4]]></title>
    <url>%2F2018%2F11%2F26%2F2018.11.26%2F</url>
    <content type="text"><![CDATA[你要堕落，神仙也救不了； 你要成长，绝处也能逢生。 AC自动机（简单版）题目背景这是一道简单的AC自动机模板题。 用于检测正确性以及算法常数。 为了防止卡OJ，在保证正确的基础上只有两组数据，请不要恶意提交。 管理员提示：本题数据内有重复的单词，且重复单词应该计算多次，请各位注意 题目描述给定n个模式串和1个文本串，求有多少个模式串在文本串里出现过。 输入输出格式输入格式： 第一行一个n，表示模式串个数； 下面n行每行一个模式串； 下面一行一个文本串。 输出格式： 一个数表示答案 输入输出样例输入样例#1： 12342aaaaa 输出样例#1： 12 说明subtask1[50pts]:∑length(模式串)&lt;=10^6,length(文本串)&lt;=10^6,n=1； subtask2[50pts]:∑length(模式串)&lt;=10^6,length(文本串)&lt;=10^6； 题解AC自动机最简单的实现 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define maxn 1050005#define maxc 28int cur = 1 , n;char p[maxn] , s[maxn];struct AC_Automaton&#123; int tr[maxn][maxc] , tot , next[maxn] , Ma[maxn] , f[maxn] , g[maxn]; bool vis[maxn]; AC_Automaton()&#123; tot = 1; &#125; inline void clear()&#123; std::memset(f,0,sizeof(f)); std::memset(g,0,sizeof(g)); std::memset(next,0,sizeof(next)); &#125; inline void insert(char* s) &#123; int len = std::strlen(s) , u = 1;// puts("The String:");// for(int i = 0 ; i &lt; len ; ++i)// putchar(s[i]);// puts("OK"); for(int i = 0 ; i &lt; len ; ++i)&#123; int c = s[i] - 97; if(!tr[u][c]) tr[u][c] = ++ tot; u = tr[u][c]; &#125; Ma[u] ++; &#125; inline void GetFail() &#123; std::queue&lt;int&gt; q; for(int i = 0 ; i &lt; 26 ; ++i) tr[0][i] = 1; q.push(1) , next[1] = 0; while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = 0 ; i &lt; 26 ; ++i)&#123; if(!tr[k][i]) tr[k][i] = tr[next[k]][i]; else&#123; q.push(tr[k][i]); next[tr[k][i]] = tr[next[k]][i]; &#125; &#125; &#125; &#125; inline int find(char* s) &#123; int len = std::strlen(s + 1); int u = 1 , ans = 0 , k; for(int i = 1 ; i &lt;= len ; ++i)&#123; k = tr[u][s[i]-97]; while(k &gt; 1)&#123; if(vis[k]) break; ans += Ma[k]; Ma[k] = 0; vis[k] = true; k = next[k]; &#125; u = tr[u][s[i]-97]; &#125; return ans; &#125; inline void print() &#123; for(int i = 1 ; i &lt;= tot ; ++i) printf("%d ",Ma[i]); &#125;&#125;aton;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i)&#123; scanf("%s",p+cur); aton.insert(p+cur); cur += std::strlen(p+cur); &#125; aton.GetFail(); scanf("%s",s+1); printf("%d\n",aton.find(s));&#125; AC自动机（加强版）题目描述有NN个由小写字母组成的模式串以及一个文本串TT。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串TT中出现的次数最多。 输入输出格式输入格式： 输入含多组数据。 每组数据的第一行为一个正整数NN，表示共有NN个模式串， 1 \leq N \leq 150接下去NN行，每行一个长度小于等于70的模式串。下一行是一个长度小于等于10^6106的文本串TT。 输入结束标志为N=0。 输出格式： 对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。 输入输出样例输入样例#1： 123456789101112132abababababababac6betaalphahahadeltadedetatadedeltalphahahahototatalpha0 输出样例#1： 123454aba2alphahaha 题解本来想先写一个暴力，然后再写各种优化（比如记忆化甚至自动机dp） 结果发现暴力AC了，虽然有点慢。 根据题意，一个单词显然要被计算多次，所以不能访问过就不算了。 注意记录节点的父亲以及连向它的边，方便输出。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#define maxn 1000005#define maxc 26int cur = 1 , n , ans[maxn];char s[maxn] , p[maxn];struct AC_Automaton&#123; int tr[maxn][maxc] , tot , next[maxn] , Ma[maxn] , f[maxn] , g[maxn]; bool vis[maxn]; AC_Automaton()&#123; tot = 1; &#125; inline void init() &#123; tot = 1; std::memset(tr,0,sizeof(tr)); std::memset(next,0,sizeof(next)); std::memset(Ma,0,sizeof(Ma)); std::memset(f,0,sizeof(f)); std::memset(g,0,sizeof(g)); &#125; inline void insert(char* s) &#123; int len = std::strlen(s) , u = 1; for(int i = 0 ; i &lt; len ; ++i)&#123; int c = s[i] - 97; if(!tr[u][c]) tr[u][c] = ++ tot; f[tr[u][c]] = u , g[tr[u][c]] = c , u = tr[u][c]; &#125; Ma[u] ++; &#125; inline void GetFail() &#123; std::queue&lt;int&gt; q; for(int i = 0 ; i &lt; 26 ; ++i) tr[0][i] = 1; q.push(1) , next[1] = 0; while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = 0 ; i &lt; 26 ; ++i)&#123; if(!tr[k][i]) tr[k][i] = tr[next[k]][i]; else&#123; q.push(tr[k][i]); next[tr[k][i]] = tr[next[k]][i]; &#125; &#125; &#125; &#125; inline int find(char* s) &#123; int len = std::strlen(s + 1); int u = 1 , k; for(int i = 1 ; i &lt;= len ; ++i)&#123; k = tr[u][s[i]-97]; while(k &gt; 1)&#123; // if(vis[k]) break; ans[k] += Ma[k]; //vis[k] = true; k = next[k]; &#125; u = tr[u][s[i]-97]; &#125; return ans[k]; &#125; inline void print(int k) &#123; std::stack&lt;int&gt; st; while(k &gt; 1) &#123; st.push(g[k]); k = f[k]; &#125; while(!st.empty()) printf("%c",st.top()+97) , st.pop(); &#125; &#125;aton;int main()&#123; while(scanf("%d",&amp;n) != EOF) &#123; std::memset(ans,0,sizeof(ans)); aton.init(); cur = 1; if(n == 0) break; for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%s",p+cur); aton.insert(p+cur); cur += std::strlen(p+cur); &#125; aton.GetFail(); scanf("%s",s+1); aton.find(s); int maxx = -0x7ffffff; std::queue&lt;int&gt; str; for(int i = 1 ; i &lt;= aton.tot ; ++i) if(aton.Ma[i]) &#123; if(maxx &lt; ans[i])&#123; while(!str.empty()) str.pop(); str.push(i); maxx = ans[i]; &#125; else if(maxx == ans[i]) str.push(i); &#125; printf("%d\n",maxx); while(!str.empty()) aton.print(str.front()) , putchar(10) , str.pop(); &#125;&#125; 「一本通 2.4 例 1」Keywords Search题目描述原题来自：HDU 2222 给定 nn 个长度不超过 5050 的由小写英文字母组成的单词准备查询，以及一篇长为 mm 的文章，问：文中出现了多少个待查询的单词。多组数据。 输入格式第一行一个整数 TT，表示数据组数；对于每组数据，第一行一个整数 nn，接下去 nn 行表示 nn 个单词，最后一行输入一个字符串，表示文章。 输出格式对于每组数据，输出一个数，表示文中出现了多少个待查询的单词。 样例样例输入1234567815shehesayshrheryasherhs 样例输出13 数据范围与提示对于全部数据， 1\le n\le 10^4,1\le m\le 10^6题解AC自动机的板子。 结果我还各种错。感觉虽然完全理解AC自动机的复杂度，正确性和工作原理，但是Trie图优化还是经常写错哎。。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define maxn 1000005#define maxc 26char s[maxn];int n;struct AC_Automaton&#123; int tr[maxn][maxc] , next[maxn] , tot , la[maxn]; bool vis[maxn]; AC_Automaton()&#123; tot = 1; &#125; inline void insert(char* s) &#123; int len = std::strlen(s) , u = 1; for(int i = 0 ; i &lt; len ; ++i) &#123; if(!tr[u][s[i]-97]) tr[u][s[i]-97] = ++tot; u = tr[u][s[i]-97]; &#125; la[u] ++ ; &#125; inline void clear() &#123; std::memset(tr,0,sizeof(tr)); std::memset(la , 0 , sizeof(la)); std::memset(next,0,sizeof(next)); std::memset(vis,false,sizeof(vis)); tot = 1; &#125; inline void GetFail() &#123; std::queue&lt;int&gt; q; for(int i = 0 ; i &lt; 26 ; ++i) tr[0][i] = 1; q.push(1) , next[1] = 0; while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = 0 ; i &lt; 26 ; ++i) &#123; if(!tr[k][i]) tr[k][i] = tr[next[k]][i]; else &#123; q.push(tr[k][i]); int v = next[k]; next[tr[k][i]] = tr[v][i]; &#125; &#125; &#125; &#125; inline int find(char* s) &#123; int u = 1 , ans = 0 , len = std::strlen(s); for(int i = 0 ; i &lt; len ; ++i) &#123; int c = s[i] - 97; int k = tr[u][c]; while(k &gt; 1) &#123; if(vis[k]) break; ans += la[k]; vis[k] = true; la[k] = 0; k = next[k]; &#125; u = tr[u][c]; &#125; return ans; &#125;&#125;aton;int main()&#123; int t; scanf("%d",&amp;t); while(~(--t)) &#123; scanf("%d",&amp;n); aton.clear(); int cur = 1; for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%s",s+cur); aton.insert(s+cur); cur += std::strlen(s+cur); &#125; aton.GetFail(); scanf("%s",s+1); printf("%d\n",aton.find(s+1)); &#125;&#125;]]></content>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 3]]></title>
    <url>%2F2018%2F11%2F25%2F2018.11.25%2F</url>
    <content type="text"><![CDATA[Only hate the road when you’re missing home. 「一本通 3.2 练习 4」新年好题目描述原题来自：CQOI 2005 重庆城里有 nn 个车站，mm 条双向公路连接其中的某些车站。每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。在一条路径上花费的时间等于路径上所有公路需要的时间之和。 佳佳的家在车站 11，他有五个亲戚，分别住在车站 a,b,c,d,ea,b,c,d,e。过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。怎样走，才需要最少的时间？ 输入格式第一行：n,mn,m 为车站数目和公路的数目。 第二行：a,b,c,d,ea,b,c,d,e 为五个亲戚所在车站编号。 以下 mm 行，每行三个整数 x,y,tx,y,t，为公路连接的两个车站编号和时间。 输出格式输出仅一行，包含一个整数 TT，为最少的总时间。 样例样例输入123456786 62 3 4 5 61 2 82 3 33 4 44 5 55 6 21 6 7 样例输出121 数据范围与提示对于全部数据， 1\le n \le 50000,1\le m \le 10^5,1\lt a,b,c,d,e\le n,1 \le x,y \le n,1 \le t \le 100题解一道最短路的基础题。 显然需要知道这6个点之间两两最短路，需要6遍Dijkstra。 然后状态压缩DP：不能光记录联通点集的最短距离，需要加上最后到达的一个点，否则很容易找出反例：有时候需要走重边，必须是最后到达的点才能直接走一条边。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define maxn 50005int head[maxn] , cnt , dis[7][7] , id[maxn] , idx , n , m , d[maxn] , f[7][1&lt;&lt;7] , ans = 10000000;bool vis[maxn];std::vector&lt;int&gt; v;struct edge&#123; int next, to , dis;&#125;e[maxn&lt;&lt;2];struct Node&#123; int v , k; bool operator &lt; (const Node&amp; x)const&#123; return v &gt; x.v; &#125;&#125;;inline void add(int x , int y , int ds)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = ds; head[x] = cnt;&#125;inline void SPDIJ(int s)&#123; std::priority_queue&lt;Node&gt; q; std::memset(d,0x7f,sizeof(d)); std::memset(vis,false,sizeof(vis)); d[s] = 0; q.push((Node)&#123;d[s] , s&#125;); while(!q.empty()) &#123; int k = q.top().k; q.pop(); if(vis[k]) continue; vis[k] = true; for(int i = head[k] ; i ; i = e[i].next)&#123; int v = e[i].to , dv = e[i].dis; if(d[k] + dv &lt; d[v])&#123; d[v] = d[k] + dv; q.push((Node)&#123;d[v] , v&#125;); &#125; &#125; &#125; for(int i = 0 ; i &lt; v.size() ; ++i) if(v[i] != s) dis[id[s]][id[v[i]]] = dis[id[v[i]]][id[s]] = d[v[i]];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); v.push_back(1); for(int i = 1 ; i &lt;= 5 ; ++i)&#123; int x; scanf("%d",&amp;x); v.push_back(x); &#125; for(int i = 0 ; i &lt; v.size() ; ++i) id[v[i]] = idx++; for(int i = 1 ; i &lt;= m ; ++i)&#123; int x , y , d; scanf("%d%d%d",&amp;x,&amp;y,&amp;d); add(x,y,d) , add(y,x,d); &#125; for(int i = 0 ; i &lt; v.size() ; ++i) SPDIJ(v[i]); std::memset(f,0x7f,sizeof(f)); int S = (1 &lt;&lt; 6) - 1; f[0][1] = 0; // must from the 0 point for(int i = 1 ; i &lt;= S ; ++i) for(int j = 0 ; j &lt;= 5 ; ++j) for(int k = 0 ; k &lt;= 5 ; ++k) if(i &amp; (1 &lt;&lt; j)) f[k][i | (1 &lt;&lt; k)] = std::min(f[k][i | (1 &lt;&lt; k)] , f[j][i] + dis[j][k]); for(int i = 0 ; i &lt;= 5 ; ++i) ans = std::min(ans , f[i][S]); printf("%d",ans);&#125; [HAOI2012]道路题目描述C国有n座城市，城市之间通过m条[b]单向[/b]道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。 输入输出格式输入格式： 第一行包含两个正整数n、m 接下来m行每行包含三个正整数u、v、w，表示有一条从u到v长度为w的道路 输出格式： 输出应有m行，第i行包含一个数，代表经过第i条道路的最短路的数目对[b]1000000007取模[/b]后的结果 输入输出样例输入样例#1： 123454 41 2 52 3 53 4 51 4 8 输出样例#1： 12342321 说明数据规模 30%的数据满足：n≤15、m≤30 60%的数据满足：n≤300、m≤1000 100%的数据满足：n≤1500、m≤5000、w≤10000 题解这道题真的挺难的。。需要你自己构造算法。 首先能想到一条重要的性质。 对于S—&gt;T的最短路上，最短路上任意一点都是到S的最短路（也是单源最短路树的基础） 一条边（u，v）的答案就是所有S—&gt;T中，S到u最短路的个数与v到T最短路并且经过S到u的最短路个数的乘积。 但是单源最短路树是不够的，因为它只是一条最短路。 也许我们可以受到一点启发。 假如我们把所有以S为源点的最短路都加入到一张图中，如果保证边权为正（题目很恶心的没有说清楚） 那么能否得出这张图没有环呢？显然可以，因为如果有正环就和定义矛盾了（环上任意一点和相邻点从两个方向得到的关系都矛盾） 那么这个DAG满足什么性质呢？显然对于反图，到点v的都是v出边的最短路上的点。 这样整道题的做法就不难想了。 首先对于每个点，我们需要知道它到其它点的最短路数目，可以通过最短路计数解决。记为 F_i然后再用一些办法构造出这个最短路DAG，拓扑排序。记为 G_i对于每条边（u，v），答案就是 F_u*G_v那么如何构造这个图呢？ 最短路的时候是可以建出来的。每当我们成功松弛一次，我们就把这个点入边清空，把这条边加进去，假如相同就直接把这条边加进去。 这里有一个小trick，我们在跑dijkstra建DAG的时候一开始会建出错误的边，因此，我们在改变点V的dis值时需要删除这个点的所有出边，此时直接清掉邻接表的表头就好了。 Code下午写QWQ，上午想这题3小时结果AC自动机都没看完，效率有点低下。 先放Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 5005#define ll long long#define mod 1000000007struct edge&#123; int next , to , dis;&#125;;bool val[maxn &lt;&lt; 3];struct Graph&#123; int head[maxn] , ct , rd[maxn] , eref[maxn &lt;&lt; 4]; edge e[maxn&lt;&lt;4]; inline void add(int x , int y, int d , int num) &#123; e[++ct].next = head[x]; e[ct].to = y; e[ct].dis = d; head[x] = ct; rd[y] ++ ; eref[ct] = num; &#125; inline void Del(int x)&#123; for(int i = head[x] ; i ; i = e[i].next) --rd[e[i].to] , val[eref[i]] = false; head[x] = 0; &#125; inline edge operator[](int x)&#123; return e[x]; &#125; inline int operator()(int x)&#123; return head[x]; &#125; inline void clear() &#123; ct = 0; std::memset(head,0,sizeof(head)); std::memset(rd,0,sizeof(rd)); &#125; inline bool valid(int x)&#123; return val[eref[x]]; &#125;&#125;g , r , p;int n , m , d[maxn];bool vis[maxn];struct ed&#123; int fr ,to , dis;&#125;er[maxn&lt;&lt;4];struct Node&#123; int v , k; bool operator &lt; (const Node&amp; x)const&#123; return v &gt; x.v; &#125;&#125;;ll f[maxn] , t[maxn] , ans[maxn];inline void Create(int s)&#123; std::memset(d,0x7f,sizeof(d)); std::memset(vis,false,sizeof(vis)); d[s] = 0; std::priority_queue&lt;Node&gt; q; q.push((Node)&#123;d[s] , s&#125;); f[s] = 1; while(!q.empty()) &#123; int k = q.top().k; q.pop(); if(vis[k]) continue; vis[k] = true; for(int i = g(k) ; i ; i = g[i].next)&#123; int v = g[i].to , dv = g[i].dis; if(d[k] + dv &lt; d[v])&#123; r.Del(v); r.add(v , k , dv , g.eref[i]); d[v] = d[k] + dv; q.push((Node)&#123;d[v] , v&#125;); f[v] = f[k]; &#125; else if(d[k] + dv == d[v]) (f[v] += f[k]) %= mod , r.add(v , k , dv , g.eref[i]); &#125; &#125; for(int i = 1 ; i &lt;= m ; ++i)&#123; if(d[er[i].fr] + er[i].dis == d[er[i].to]) val[i] = true; &#125;&#125;inline void DP()&#123; std::queue&lt;int&gt; q; for(int i = 1 ; i &lt;= n ; ++i)&#123; for(int j = r(i) ; j ; j = r[j].next)&#123; if(r.valid(j) &amp;&amp; !t[i]) ++t[i]; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(!r.rd[i]) q.push(i); while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = r(k) ; i ; i = r[i].next)&#123; if(!r.valid(i)) continue; int v = r[i].to; (t[v] += t[k]) %= mod; --r.rd[v]; if(!r.rd[v]) q.push(v); &#125; &#125; &#125;inline void Solve(int S)&#123; std::memset(val,false,sizeof(val)); std::memset(f,0,sizeof(f)); std::memset(t,0,sizeof(t)); r.clear(); Create(S); DP(); for(int i = 1 ; i &lt;= m ; ++i) if(val[i])&#123; int u = er[i].fr , v = er[i].to; (ans[i] += f[u] * t[v] % mod) %= mod; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int num = 0; for(int i = 1 ; i &lt;= m ; ++i)&#123; int x , y , d; scanf("%d%d%d",&amp;x,&amp;y,&amp;d); g.add(x,y,d,i) , er[++num].fr = x , er[num].to = y, er[num].dis = d; &#125; for(int i = 1 ; i &lt;= n ; ++i)&#123; Solve(i); &#125; for(int i = 1; i &lt;= m ; ++i) printf("%lld\n",ans[i]);&#125; 6个小时后终于AC了本题，某些血的教训必须说一说。。。 首先，假如这道题比较复杂，功能模块比较多，那么不妨写完一个模块就调试一下其正确性，这非常重要 一定要保持头脑冷静，注意各种细节，比如数组没有清空，一些写的完全不对的地方等等。。 不要弃疗，要越战越勇。也许离正解就差一个细节。 各种错误比如： 1g.add(x,y,d,i) , er[++num].fr = x , er[num].to, er[num].dis; 与上文对比效果极佳。 这道题是道不错的图论好题。 开始刷AC自动机 先讲讲AC自动机的原理。 AC自动机是一种有限状态自动机，可以在O(n + m*l)的时间里完成匹配。 与KMP不同的是AC自动机所匹配的最大相同前后缀可以来自其他模式串而不必只是它自己，这意味着母串匹配的复杂度和KMP是相同的。 原理大概就是这样。。 今天挺颓（多亏了那道让我写了6小时的题），AC自动机的题连同Hash的题下周全完成就OK。 写了写模板代码，虽然懂了原理 ， 对于优化还是有点不懂。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define maxn 1000005#define maxc 26int id[maxn] , idx , cur = 1;char s[maxn];struct AC_Automaton&#123; int tr[maxn][maxc] , tot , next[maxn]; bool Ma[maxn]; inline void insert(char* s) &#123; int len = std::strlen(s + 1) , u = 1; for(int i = 1 ; i &lt;= len ; ++i)&#123; int c = s[i] - 97; if(!tr[u][c]) tr[u][c] = ++ tot; u = tr[u][c]; &#125; Ma[u] ++; &#125; inline void GetFail() &#123; std::queue&lt;int&gt; q; for(int i = 0 ; i &lt; 26 ; ++i) tr[0][i] = 1; q.push(1) , next[1] = 0; while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = 0 ; i &lt; 26 ; ++i)&#123; if(!tr[k][i]) tr[k][i] = tr[next[k]][i]; else&#123; q.push(tr[k][i]); next[tr[k][i]] = tr[next[k]][i]; &#125; &#125; &#125; &#125; inline int find(char* s) &#123; int len = std::strlen(s + 1); int u = 1 , ans = 0; for(int i = 1 ; i &lt;= len ; ++i)&#123; u = tr[u][s[i]-97]; ++ans; &#125; return ans; &#125;&#125;]]></content>
      <tags>
        <tag>最短路 图论 AC自动机 单源最短路树 单源最短路图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 2]]></title>
    <url>%2F2018%2F11%2F24%2F2018.11.24%2F</url>
    <content type="text"><![CDATA[你的负担将变成礼物，你受的苦将照亮你的路。 「一本通 2.2 例 1」剪花布条题目描述原题来自：HDU 2087 一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？ 输入格式输入数据为多组数据，读取到 # 字符时结束。每组数据仅有一行，为由空格分开的花布条和小饰条。花布条和小饰条都是用可见 ASCII 字符表示的，不会超过 10001000 个字符。 注意：这个 # 应为单个字符。若某字符串开头有 #，不意味着读入结束！ 输出格式对于每组数据，输出一行一个整数，表示能从花纹布中剪出的最多小饰条个数。 样例样例输入123abcde a3aaaaaa aa# 样例输出1203 数据范围与提示对于全部数据，字符串长度 \leq 1000≤1000。 题解挺简单的KMP的题。 至于保证不重叠也很简单，匹配成功一个的时候让匹配值=0即可，至于为什么保留前面一个忽略和当前冲突的就不用说了，很简单的贪心思想。 Code： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 10005char s[maxn] , p[maxn];int next[maxn] , ans;int main()&#123; while(true) &#123; scanf("%s",s+1); int sl = std::strlen(s+1); if(sl == 1 &amp;&amp; s[1] == '#') break; ans = 0; scanf("%s",p+1); int now = 0 , pl = std::strlen(p+1); for(int i = 1 ; i &lt; pl ; ++i)&#123; while(now &gt; 0 &amp;&amp; p[i + 1] != p[now + 1]) now = next[now]; if(p[i + 1] == p[now + 1]) ++now; next[i + 1] = now; &#125; now = 0; for(int i = 0 ; i &lt; sl ; ++i)&#123; while(now &gt; 0 &amp;&amp; s[i + 1] != p[now + 1]) now = next[now]; if(s[i + 1] == p[now + 1]) ++now; if(now == pl)&#123; ++ans; now = 0; &#125; &#125; printf("%d\n",ans); &#125;&#125; 一本通 2.1 练习 1」Power Strings题目描述原题来自：POJ 2406 给定若干个长度 \le 10^6≤106 的字符串，询问每个字符串最多是由多少个相同的子字符串重复连接而成的。如：ababab 则最多有 33 个 ab 连接而成。 输入格式输入若干行，每行有一个字符串。特别的，字符串可能为 . 即一个半角句号，此时输入结束。 样例样例输入1234abcdaaaaababab. 样例输出123143 数据范围与提示字符串长度 n\le 10^6题解有点难度的KMP题。对于一个由长度大于1的循环节k次循环组成的字符串，最大相同前后缀必定是k-1个循环节组成的。设循环节长度为L 必要性显然，也就是说最大相同前后缀长度不小于k-1个循环字符串。 考虑假设最大前缀多x位。显然x &lt;= next(L)。 然而这意味着每一个字符向后移动x位依然相同，所以最小循环节是x，与最初假设矛盾。 因此答案是 n / (n - next(n))注意检验 Code： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 1000005char s[maxn] , p[maxn];int next[maxn] , n;int main()&#123; while(scanf("%s",s+1)) &#123; if(s[1] == '.' &amp;&amp; std::strlen(s+1) == 1) break; int now = 0 , n = std::strlen(s + 1); for(int i = 1 ; i &lt; n ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i + 1] != s[now + 1]) now = next[now]; if(s[i + 1] == s[now + 1]) ++now; next[i + 1] = now; &#125; int pl = 0; for(int i = n - next[n] + 1 ; i &lt;= n ; ++i) p[++pl] = s[i]; if(!pl) &#123; puts("1") ; continue; &#125; now = 0; bool flag = true; for(int i = 1 ; i &lt;= n ; ++i) &#123; ++now; if(s[i] != p[now]) flag = false; if(i % pl == 0) now = 0; &#125; if(flag) printf("%d\n",n / (n - next[n])); else printf("1\n"); &#125;&#125; 「一本通 2.2 练习 1」Radio Transmission题目描述原题来自：BalticOI 2009 给你一个字符串，它是由某个字符串不断自我连接形成的。但是这个字符串是不确定的，现在只想知道它的最短长度是多少。 输入格式第一行给出字符串的长度 LL，第二行给出一个字符串，全由小写字母组成。 输出格式输出最短的长度。 样例样例输入 1128cabcabca 样例输出 113 样例说明对于样例，我们可以利用 abc 不断自我连接得到 abcabcabc，读入的 cabcabca 是它的子串。 数据范围与提示对于全部数据， 1\le L\le 10^6题解和上面的一样，从上题证明中我们能够发现最长相同前后缀长度为L，字符串长度为n 那么我们可以把字符串后L位视为前L位平移n-L位，这样的话就相当于循环节是n-L.(除去特殊情况) 本题同理，就像分块一样，字符串只有可能有两个不完整的循环节，位于头尾。 但是中间最少有一个完整的循环节，这样前面不完整和后面不完整可以与中间组合，然后n-next(n) 就是正好一个完整的串。 不怎么会证，画图证明 Code： 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define maxn 1000005char s[maxn];int n , next[maxn];int main()&#123; scanf("%d",&amp;n); scanf("%s",s+1); int now = 0; for(int i = 1 ; i &lt; n ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i + 1] != s[now + 1]) now = next[now]; if(s[i + 1] == s[now + 1]) ++now; next[i + 1] = now; &#125; printf("%d", n - next[n]);&#125; 「一本通 2.2 练习 4」Censoring题目描述原题来自：USACO 2015 Feb. Silver 给出两个字符串 S 和 T，每次从前往后找到 S 的一个子串 A=T 并将其删除，空缺位依次向前补齐，重复上述操作多次，直到 SS 串中不含 TT 串。输出最终的 S 串。 输入格式第一行包含一个字符串 S，第二行包含一个字符串 T。 输出格式输出处理后的 SS 串。 样例样例输入12whatthemomooofunmoo 样例输出1whatthefun 数据范围与提示对于全部数据， 1\le |T|\le |S|\le 10^6，保证字符串中只出现小写字母。 题解一道比较有意思的题。 我们只需要开一开脑洞，将母串每个位置成功匹配的数量记录下来，然后删除后跳回删除串的前一个位置，从 fail_i继续开始匹配就行了。 时间复杂度分析依然要用到摊还分析的策略：由于回跳的前提是删除了母串中长度为m的模式串，那么跳后剩下的距离和普通KMP是一样的，所以时间复杂度不变 O(n)Code： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 1000005char p[maxn];std::string s;int next[maxn] , fail[maxn];bool k[maxn];int main()&#123; std::cin &gt;&gt; s; scanf("%s",p+1); int now = 0; int sl = s.length() , pl = std::strlen(p + 1); for(int i = 1 ; i &lt; pl ; ++i) &#123; while(now &gt; 0 &amp;&amp; p[now + 1] != p[i + 1]) now = next[now]; if(p[now + 1] == p[i + 1]) ++now; next[i + 1] = now; &#125; now = 0; for(int i = 0 ; i &lt; s.length() ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i] != p[now + 1]) now = next[now]; if(s[i] == p[now + 1]) ++now; fail[i] = now; if(now == pl) &#123; int fr = i - pl + 1; s.erase(fr , pl); i = fr - 1; now = fail[i]; &#125; &#125; std::cout &lt;&lt; s;&#125; 「一本通 2.2 练习 3」似乎在梦中见过的样子原题来自：2014 年湖北省队互测 Week2 「Madoka，不要相信 QB！」伴随着 Homura 的失望地喊叫，Madoka 与 QB 签订了契约。 这是 Modoka 的一个噩梦，也同时是上个轮回中所发生的事。为了使这一次 Madoka 不再与 QB 签订契约，Homura 决定在刚到学校的第一天就解决 QB。然而，QB 也是有许多替身的（但在第八话中的剧情显示它也有可能是无限重生的），不过，意志坚定的 Homura 是不会放弃的——她决定消灭所有可能是 QB 的东西。现在，她已感受到附近的状态，并且把它转化为一个长度为 nn 的字符串交给了学 OI 的你。 现在你从她的话中知道，所有形似于 A+B+AA+B+A 的字串都是 QB 或它的替身，且 |A|\ge k,|B|\ge 1∣A∣≥k,∣B∣≥1 （位置不同其他性质相同的子串算不同子串，位置相同但拆分不同的子串算同一子串），然后你必须尽快告诉 Homura 这个答案——QB 以及它的替身的数量。 注：对于一个字符串 SS，|S|∣S∣ 表示 SS 的长度。 输入格式第一行一个字符串 SS，第二行一个数 kk。 输出格式仅一行一个数 \text{ans}ans，表示 QB 以及它的替身的数量。 样例样例输入 112aaaaa1 样例输出 116 样例输入 212abcabcabc2 样例输出 218 数据范围与提示对于全部数据，1\le |S|\le 1.5\times 10^4,1\le k\le 1001≤∣S∣≤1.5×104,1≤k≤100，且字符集为所有小写字母。 题解果然胡策题质量不高。。一道标算复杂度爆炸的题。。。最坏 O(n^3)居然过了。。 Code： 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 15005#define maxk 105char s[maxn] , p[maxn];int k , next[maxn] , ans;int main()&#123; scanf("%s",s+1); scanf("%d",&amp;k); int n = std::strlen(s + 1); for(int j = 1 ; j &lt;= n ; ++j) &#123; std::memset(next,0,sizeof(next)); int len = 0; for(int i = j; i &lt;= n ; ++i) p[++len] = s[i]; for(int i = 1 , now = 0 ; i &lt; len ; ++i) &#123; while(now &gt; 0 &amp;&amp; p[i + 1] != p[now + 1]) now = next[now]; if(p[i + 1] == p[now + 1]) ++now; next[i + 1] = now; for(int t = next[i + 1] ; t &gt;= k ; t = next[t]) if((t &lt;&lt; 1) &lt;= i)&#123; ++ans; break; &#125; &#125; &#125; printf("%d",ans);&#125; 「一本通 2.2 练习 2」OKR-Periods of Words原题来自：POI 2006 串是有限个小写字符的序列，特别的，一个空序列也可以是一个串。一个串 PP 是串 AA 的前缀，当且仅当存在串 BB，使得 A = PBA=PB。如果 P \not =AP̸=A 并且 PP 不是一个空串，那么我们说 PP 是 AA 的一个 proper 前缀。 定义 QQ 是 AA 的周期，当且仅当 QQ 是 AA 的一个 proper 前缀并且 AA 是 QQQQ 的前缀（不一定要是 proper 前缀）。比如串 abab 和 ababab 都是串 abababa 的周期。串 AA 的最大周期就是它最长的一个周期或者是一个空串（当 AA 没有周期的时候），比如说，ababab 的最大周期是 abab。串 abc 的最大周期是空串。 给出一个串，求出它所有前缀的最大周期长度之和。 输入格式第一行一个整数 kk，表示串的长度。 接下来一行表示给出的串。 输出格式输出一个整数表示它所有前缀的最大周期长度之和。 样例样例输入128babababa 样例输出124 数据范围与提示对于全部数据，1\lt k\lt 10^61&lt;k&lt;106。 题解想的挺对，不过不知道一开始有个傻逼细节写错了。。。 简述题意就是对于每个1~i，我们都要求出一个最大前缀（不能一模一样），使得这个前缀倍长后当前的1~i是其前缀（可以一样）。 还是用到KMP中next数组的一个性质来求循环节，上面说过是n-next(n),但是我们希望它最大，于是多跳几次next只要它大于0，并且最后必须保证 2(n-next(n)) >= i就可以加到答案里。 注意倍增优化。 时间复杂度： O(nlogn)Code： 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 1000005char s[maxn];int next[21][maxn] , n ;long long ans;int main()&#123; scanf("%d",&amp;n); scanf("%s",s+1); for(int i = 1 , now = 0 ; i &lt; n ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i + 1] != s[now + 1]) now = next[0][now]; if(s[i + 1] == s[now + 1]) ++now; next[0][i + 1] = now; for(int j = 1 ; j &lt;= 20 ; ++j) next[j][i + 1] = next[j-1][next[j-1][i + 1]]; int cur = next[0][i + 1]; for(int j = 20 ; ~j ; --j) if(next[j][cur]) cur = next[j][cur]; if(next[0][cur]) cur = next[0][cur]; if(!cur) continue; if(((i + 1 - cur) &lt;&lt; 1) &gt;= i + 1) ans += i + 1 - cur; &#125; printf("%lld",ans); &#125; 这样一来一本通上的6道题目就全做完了，全部独立AC，还算不错。 鼓捣一下blog]]></content>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post 1]]></title>
    <url>%2F2018%2F11%2F23%2F2018.11.23%2F</url>
    <content type="text"><![CDATA[生如夏花之绚烂，死如秋叶之静美。 [NOI2014]动物园题目描述近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。 某天，园长给动物们讲解KMP算法。 园长：“对于一个字符串SS，它的长度为LL。我们可以在O(L)O(L)的时间内，求出一个名为next的数组。有谁预习了next数组的含义吗？” 熊猫：“对于字符串SS的前ii个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作next[i]next[i]。” 园长：“非常好！那你能举个例子吗？” 熊猫：“例SS为abcababc，则next[5]=2next[5]=2。因为SS的前55个字符为abcab，ab既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出next[1] = next[2] = next[3] = 0next[1]=next[2]=next[3]=0，next[4] = next[6] = 1next[4]=next[6]=1，next[7] = 2next[7]=2，next[8] = 3next[8]=3。” 园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在O(L)O(L)的时间内求出next数组。 下课前，园长提出了一个问题：“KMP算法只能求出next数组。我现在希望求出一个更强大num数组一一对于字符串SS的前ii个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]num[i]。例如SS为aaaaa，则num[4] = 2num[4]=2。这是因为SS的前44个字符为aaaa，其中a和aa都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而aaa虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，num[1] = 0,num[2] = num[3] = 1,num[5] = 2num[1]=0,num[2]=num[3]=1,num[5]=2。” 最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出numnum数组呢？ 特别地，为了避免大量的输出，你不需要输出num[i]num[i]分别是多少，你只需要输出所有(num[i]+1num[i]+1)的乘积，对1,000,000,0071,000,000,007取模的结果即可。 输入输出格式输入格式： 第11行仅包含一个正整数nn ，表示测试数据的组数。随后nn行，每行描述一组测试数据。每组测试数据仅含有一个字符串SS，SS的定义详见题目描述。数据保证SS 中仅含小写字母。输入文件中不会包含多余的空行，行末不会存在多余的空格。 输出格式： 包含 nn 行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对 1,000,000,0071,000,000,007 取模的结果。输出文件中不应包含多余的空行。 输入输出样例输入样例#1： 12343aaaaaababcababc 输出样例#1： 12336132 说明 测试点编号 约定 1 N ≤ 5, L ≤ 50N≤5,L≤50 2 N ≤ 5, L ≤ 200N≤5,L≤200 3 N ≤ 5, L ≤ 200N≤5,L≤200 4 N ≤ 5, L ≤ 10,000N≤5,L≤10,000 5 N ≤ 5, L ≤ 10,000N≤5,L≤10,000 6 N ≤ 5, L ≤ 100,000N≤5,L≤100,000 7 N ≤ 5, L ≤ 200,000N≤5,L≤200,000 8 N ≤ 5, L ≤ 500,000N≤5,L≤500,000 9 N ≤ 5, L ≤ 1,000,000N≤5,L≤1,000,000 10 N ≤ 5, L ≤ 1,000,000N≤5,L≤1,000,000 题解让我们先考虑一个复杂度比较高的做法。 显然对于当前的位置i，假如我知道了最大相同前后缀，还需要看看是否重叠，如果重叠就继续跳next。 这样我们就有了一个大概 O(N^2)的做法，可以得到50分 Code： 12 然后我们发现显而易见地可以倍增跳next，注意常数 时间复杂度 O(Tnlogn)期望得分：80 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 1000005char s[maxn];int n , next[maxn][21] , tot[maxn] , lg[maxn];const long long mod = (long long)1e9+7;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= 1000000 ; ++i) lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); while(n--) &#123; std::memset(tot,0,sizeof(tot));// std::memset(next,0,sizeof(next)); scanf("%s",s+1); int len = std::strlen(s+1); int now = 0; next[1][0] = 0; for(int i = 1 ; i &lt; len ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i + 1] != s[now + 1]) now = next[now][0]; if(s[i + 1] == s[now + 1]) ++now; next[i + 1][0] = now; &#125; for(int j = 1 ; j &lt;= lg[len] ; ++j) for(int i = 1 ; i &lt;= len ; ++i) next[i][j] = next[next[i][j-1]][j-1]; now = 0; for(int i = 1 ; i &lt; len ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i + 1] != s[now + 1]) now = next[now][0]; if(s[i + 1] == s[now + 1]) ++now;// while(now &gt; ((i + 1) &gt;&gt; 1)) now = next[now][0]; for(int j = lg[i] ; ~j ; --j) if(next[now][j] &gt; ((i + 1) &gt;&gt; 1)) now = next[now][j]; if(now &gt; ((i + 1) &gt;&gt; 1)) now = next[now][0]; int calc = now; for(int j = lg[i] ; ~j &amp;&amp; calc ; --j) if(next[calc][j]) calc = next[calc][j] , tot[i + 1] += (1 &lt;&lt; j); if(calc) ++tot[i + 1]; &#125;// for(int i = 1 ; i &lt;= len ; ++i)// printf("%d ",tot[i]);// putchar(10); long long ans = 1; for(int i = 1 ; i &lt;= len ; ++i) (ans *= tot[i] + 1) %= mod; printf("%lld\n",ans); &#125;&#125; 将两维换一下（内存访问加快），即可AC（这题正解说话全跟放屁一样也是厉害） Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// luogu-judger-enable-o2// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 1000005char s[maxn];int n , next[21][maxn] , tot[maxn] , lg[maxn];const int mod = (int)1e9+7;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= 1000000 ; ++i) lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); while(n--) &#123; std::memset(tot,0,sizeof(tot)); scanf("%s",s+1); int len = std::strlen(s+1); int now = 0; next[0][1] = 0; for(int i = 1 ; i &lt; len ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i + 1] != s[now + 1]) now = next[0][now]; if(s[i + 1] == s[now + 1]) ++now; next[0][i + 1] = now; &#125; for(int j = 1 ; j &lt;= lg[len] ; ++j) for(int i = 1 ; i &lt;= len ; ++i) next[j][i] = next[j-1][next[j-1][i]]; now = 0; for(int i = 1 ; i &lt; len ; ++i) &#123; while(now &gt; 0 &amp;&amp; s[i + 1] != s[now + 1]) now = next[0][now]; if(s[i + 1] == s[now + 1]) ++now; for(int j = lg[i] ; ~j ; --j) if(next[j][now] &gt; ((i + 1) &gt;&gt; 1)) now = next[j][now]; if(now &gt; ((i + 1) &gt;&gt; 1)) now = next[0][now]; int calc = now; for(int j = lg[i] ; ~j &amp;&amp; calc ; --j) if(next[j][calc]) calc = next[j][calc] , tot[i + 1] += (1 &lt;&lt; j); if(calc) ++tot[i + 1]; &#125; long long ans = 1; for(int i = 1 ; i &lt;= len ; ++i) (ans *= tot[i] + 1) %= mod; printf("%lld\n",ans); &#125;&#125; 突然对luogu产生了厌倦之感，是时候刷BZOJ了。 感谢luogu 8个月的陪伴，再见。]]></content>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.44]]></title>
    <url>%2F2018%2F11%2F17%2Fno-44%2F</url>
    <content type="text"><![CDATA[[TJOI2017]异或和题目描述在加里敦中学的小明最近爱上了数学竞赛，很多数学竞赛的题都是与序列的连续和相关的。所以对于一个序列，求出它们所有的连续和来说，小明觉得十分的简单。但今天小明遇到了一个序列和的难题，这个题目不仅要求你快速的求出所有的连续和，还要快速的求出这些连续和的异或值。小明很快的就求出了所有的连续和，但是小明要考考你，在不告诉连续和的情况下，让你快速求是序列所有连续和的异或值。 输入输出格式输入格式： 第一行输入一个n,表示这序列的数序列 第二行输入n个数字a1,a2…an代表这个序列 0&lt;=a1,a2,…an，0&lt;=a1+a2…+an&lt;=10^6 输出格式： 输出这个序列所有的连续和的异或值 输入输出样例输入样例#1： 1231 2 3 输出样例#1： 10 说明【样例解释】 序列1 2 3有6个连续和，它们分别是1 2 3 3 5 6，则1 xor 2 xor 3 xor 3 xor 5 xor 6 = 0 【数据范围】 对于20%的数据，1&lt;=n&lt;=100 对于100%的数据， 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[BUG!]]></title>
    <url>%2F2018%2F11%2F17%2Fbugs%2F</url>
    <content type="text"><![CDATA[看上去并没有错误，然而事实上这里的中点变量叫mid ， m 是询问个数， 因此就用了2小时的时间换取这个宝贵的教训。千万不要因为一些变量用的熟就忽视检查，以及变量最好比较有意义和独特，显然mid是更好的选择。 一眼过去秒切，一看数据倍增都懒得写，结果硬是wa两个点，原因？LCA特判链！ 前来更新。 关于货车运输：它AC了。 题面题解在2018.9.10post中有，我们来说说各种奇葩bug（晚上可能吃错药了） 1.并查集合并必须合并根节点！ 并查集每个节点必须合并根节点，不然由于每个节点只能指一个父亲，合并后有些点就没有fa了！。 比如合并2,9。我们直接把2指向9合并的话，可怜的1,3怎么办呢？？ 2.不熟悉的变量名各种错 显然写代码还是边写边想，不要出现把错误的数组元素返回之类的错误 考前重要note：不要凭感觉取模！！！ 只要不涉及除法，那么最后计算答案的所有变量都要不停地取模！不要怕常数，不要估计，不要懒得写！！！ 比如这题： 在近似菊花图或菊花图下，子节点和不一定爆但平方和一定爆了！！为了这个调了n小时换取教训qwq。 2018.9.20一上午因为常量设小了而调了一上午一道非常简单的环形计数dp。。 主要还是O2的功劳，我一直以为9,10两个点数据范围一样第九个wa了应该是某个细节没处理好？结果开了O2第十个点不知怎么玄学就过了。。。 以后常量设的时候+5就对了，NOIp没有毒瘤卡空间的题。 写树链剖分的时候，思路清晰，代码清晰，理解透彻，然而就是莫名RE两次，原因竟然是？： 我的bug多积累下就成书了 对于Floyd这东西，0x7f可是相当要命的。 显然要更新一个上面相反的 假如少一个f就是30分，加这个就是满分，就这样。 注意欧拉筛范围，如果分解质因数需要知道剩下具体是哪个质数，是需要筛到n的！ 在树上倍增最大值最小值等信息往往同时需要倍增LCA，并且在查询的时候也要和LCA一起，所以千万记住先查询查询值在往上跳公共祖先！ 极大极小值一定要开够！严格次小生成树这样的随手卡你极大值。 考试的时候成功就写了一题，原因是把外层多组数据组数循环变量写到了里面，然后10分钟的题 = 1小时+ 然后就愉快的垫底了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstring&gt;std::stack&lt;char&gt; st;int n;int main()&#123; freopen("strs.in","r",stdin); freopen("strs.out","w",stdout); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) &#123; std::string s; int flag = 0; while(!st.empty()) st.pop(); std::cin&gt;&gt;s; for(int j = 0 ; j &lt; s.length() ; ++j) &#123; if(s[j] == '&lt;' || s[j] == '&#123;'|| s[j] == '[' || s[j] == '(') &#123; if(st.empty()) &#123;st.push(s[j]) ; continue;&#125; if(st.top() == '&lt;' &amp;&amp; s[j] == '&lt;') &#123;st.push(s[j]) ; continue;&#125; if(st.top() == '(' &amp;&amp; (s[j] != '[' &amp;&amp; s[j] != '&#123;')) &#123;st.push(s[j]) ; continue;&#125; if(st.top() == '[' &amp;&amp; s[j] != '&#123;') &#123;st.push(s[j]) ; continue;&#125; if(st.top() == '&#123;') &#123;st.push(s[j]) ; continue;&#125; flag = 1; break; &#125; else &#123; if(st.empty())&#123;flag = 1 ;break;&#125; if(s[j] == '&gt;' &amp;&amp; st.top() == '&lt;') &#123;st.pop() ; continue;&#125; if(s[j] == ')' &amp;&amp; st.top() == '(') &#123;st.pop() ; continue;&#125; if(s[j] == '&#125;' &amp;&amp; st.top() == '&#123;') &#123;st.pop(); continue;&#125; if(s[j] == ']' &amp;&amp; st.top() == '[') &#123;st.pop(); continue;&#125; // if(!st.empty()) std::cout&lt;&lt;st.top()&lt;&lt;std::endl; &#125; flag = 1 ; break; &#125; if(flag) printf("NO\n"); else printf("YES\n"); &#125;&#125;]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开端]]></title>
    <url>%2F2018%2F11%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[本blog搭建于第一次NOIp之后，可能会记录包括OI在内的很多事情。 无论如何，一路向前。 今天用了半天时间传我以前比较有用的Note，这样就不用成天带着优盘的Note了。。 不过这样就没时间复习文化课了 无论如何这个月把物理化学该补的补好就行，毕竟NOIp凉了。OI的事暂时先放放，毕竟以后怎么走都不一定呢。]]></content>
      <tags>
        <tag>nothing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.32]]></title>
    <url>%2F2018%2F11%2F17%2Fno-32%2F</url>
    <content type="text"><![CDATA[题目描述Oh those picky N (1 &lt;= N &lt;= 50,000) cows! They are so picky that each one will only be milked over some precise time interval A..B (1 &lt;= A &lt;= B &lt;= 1,000,000), which includes both times A and B. Obviously, FJ must create a reservation system to determine which stall each cow can be assigned for her milking time. Of course, no cow will share such a private moment with other cows. Help FJ by determining:The minimum number of stalls required in the barn so that each cow can have her private milking periodAn assignment of cows to these stalls over timeMany answers are correct for each test dataset; a program will grade your answer. 约翰的N(l&lt;N&lt; 50000)头奶牛实在是太难伺候了，她们甚至有自己独特的产奶时段.当 然对于某一头奶牛，她每天的产奶时段是固定的，为时间段A到B包括时间段A和时间段B.显然，约翰必须开发一个调控系统来决定每头奶牛应该被安排到哪个牛棚去挤 奶，因为奶牛们显然不希望在挤奶时被其它奶牛看见. 约翰希望你帮他计算一下：如果要满足奶牛们的要求，并且每天每头奶牛都要被挤过奶，至少需要多少牛棚 •每头牛应该在哪个牛棚被挤奶。如果有多种答案，你只需任意一种即可。 输入输出格式输入格式： Line 1: A single integer, N Lines 2..N+1: Line i+1 describes cow i’s milking interval with two space-separated integers. 输出格式： Line 1: The minimum number of stalls the barn must have. Lines 2..N+1: Line i+1 describes the stall to which cow i will be assigned for her milking period. 输入输出样例输入样例#1： 12345651 102 43 65 84 7 输出样例#1： 123456412324 说明Explanation of the sample: Here’s a graphical schedule for this output: Time 1 2 3 4 5 6 7 8 9 10 Stall 1 c1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stall 2 .. c2&gt;&gt;&gt;&gt;&gt;&gt; c4&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. .. Stall 3 .. .. c3&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. .. .. .. Stall 4 .. .. .. c5&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .. .. ..Other outputs using the same number of stalls are possible. 题解一道很简单的贪心，D1T1难度多一点。 显然只要按照左端点排序，按顺序选即可，如果当前左端点和右端点冲突，就用下一个。 我分析了一下，这样做其实 O(n^2)不过依旧通过了。 Code： 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 50005struct Node&#123; int l , r , k; bool operator &lt; (const Node&amp; x)const&#123;// if(l == x.l) return r &lt; x.r; return l &lt; x.l; &#125;&#125;p[maxn];int n;int inc[maxn];int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].l,&amp;p[i].r),p[i].k = i; std::sort(p+1,p+n+1); int ans = 0 , tot = 0; while(tot &lt; n) &#123; ++ans; int R = 0; for(int i = 1 ; i &lt;= n ; ++i)&#123; if(p[i].l &gt; R &amp;&amp; (!inc[p[i].k])) ++tot , inc[p[i].k] = ans , R = std::max(R , p[i].r); &#125; &#125; printf("%d\n",ans); for(int i = 1 ; i &lt;= n ; ++i) printf("%d\n",inc[i]);&#125; 其实我们可以用堆维护每个牛棚最右边的端点，每次去找最小的右端点看看能不能加入，显然这个优化非常明显，对于每头牛的复杂度为 O(logn)最后时间复杂度为 O(nlogn)Code: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define pii std::pair&lt;int,int&gt;#define mp(x,y) std::make_pair((x),(y))#define maxn 50005struct Node&#123; int l , r , k; bool operator &lt; (const Node&amp; x)const&#123;// if(l == x.l) return r &lt; x.r; return l &lt; x.l; &#125;&#125;p[maxn];int n;int inc[maxn];std::priority_queue&lt;pii , std::vector&lt;pii&gt; , std::greater&lt;pii&gt; &gt; q;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].l,&amp;p[i].r),p[i].k = i; std::sort(p+1,p+n+1); int ans = 1; q.push(mp(p[1].r,1)) , inc[p[1].k] = ans; for(int i = 2 ; i &lt;= n ; ++i)&#123; int k = q.top().first , num = q.top().second; if(k &gt;= p[i].l) ++ans , q.push(mp(p[i].r,ans)) , inc[p[i].k] = ans; else&#123; q.pop(); k = std::max(k , p[i].r); q.push(mp(k,num)); inc[p[i].k] = num; &#125; &#125; printf("%d\n",ans); for(int i = 1 ; i &lt;= n ; ++i) printf("%d\n",inc[i]);&#125; [USACO08FEB]酒店Hotel题目描述The cows are journeying north to Thunder Bay in Canada to gain cultural enrichment and enjoy a vacation on the sunny shores of Lake Superior. Bessie, ever the competent travel agent, has named the Bullmoose Hotel on famed Cumberland Street as their vacation residence. This immense hotel has N (1 ≤ N ≤ 50,000) rooms all located on the same side of an extremely long hallway (all the better to see the lake, of course). The cows and other visitors arrive in groups of size Di (1 ≤ Di ≤ N) and approach the front desk to check in. Each group i requests a set of Di contiguous rooms from Canmuu, the moose staffing the counter. He assigns them some set of consecutive room numbers r..r+Di-1 if they are available or, if no contiguous set of rooms is available, politely suggests alternate lodging. Canmuu always chooses the value of r to be the smallest possible. Visitors also depart the hotel from groups of contiguous rooms. Checkout i has the parameters Xi and Di which specify the vacating of rooms Xi ..Xi +Di-1 (1 ≤ Xi ≤ N-Di+1). Some (or all) of those rooms might be empty before the checkout. Your job is to assist Canmuu by processing M (1 ≤ M &lt; 50,000) checkin/checkout requests. The hotel is initially unoccupied. 参考样例，第一行输入n，m ，n代表有n个房间，编号为1—-n，开始都为空房，m表示以下有m行操作，以下 每行先输入一个数 i ，表示一种操作： 若i为1，表示查询房间，再输入一个数x，表示在1—n 房间中找到长度为x的连续空房，输出连续x个房间中左端的房间号，尽量让这个房间号最小，若找不到长度为x的连续空房，输出0。 若i为2，表示退房，再输入两个数 x，y 代表 房间号 x—-x+y-1 退房，即让房间为空。 输入输出格式输入格式： * Line 1: Two space-separated integers: N and M * Lines 2..M+1: Line i+1 contains request expressed as one of two possible formats: (a) Two space separated integers representing a check-in request: 1 and Di (b) Three space-separated integers representing a check-out: 2, Xi, and Di 输出格式： * Lines 1…..: For each check-in request, output a single line with a single integer r, the first room in the contiguous sequence of rooms to be occupied. If the request cannot be satisfied, output 0. 输入输出样例输入样例#1： 123456710 61 31 31 31 32 5 51 6 输出样例#1： 1234514705 题解主要是要会线段树维护最大子段，我因为一个地方想错而调了2小时。 又是一个两小时警告！线段树pushup更新当前区间最大子段是左儿子右儿子最大子段和中间新的一段取max，不是当前区间从左边最大，从右边最大，然后中间最大取max错误： 1234567inline void pushup(int Node , int ln , int rn)&#123; if(lmax[ls(Node)] != ln) lmax[Node] = lmax[ls(Node)]; else lmax[Node] = ln + lmax[rs(Node)]; if(rmax[rs(Node)] != rn) rmax[Node] = rmax[rs(Node)]; else rmax[Node] = rn + rmax[ls(Node)]; sum[Node] = max(lmax[ls(Node)] , rmax[ls(Node)] + lmax[rs(Node)] , rmax[rs(Node)]);//cautions for two hours ! are sums!!&#125; 正确： 1234567inline void pushup(int Node , int ln , int rn)&#123; if(lmax[ls(Node)] != ln) lmax[Node] = lmax[ls(Node)]; else lmax[Node] = ln + lmax[rs(Node)]; if(rmax[rs(Node)] != rn) rmax[Node] = rmax[rs(Node)]; else rmax[Node] = rn + rmax[ls(Node)]; sum[Node] = max(sum[ls(Node)] , rmax[ls(Node)] + lmax[rs(Node)] , sum[rs(Node)]);//cautions for two hours ! are sums!!&#125; 知道这个这道题还是不难的 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define maxn 100005int n , m , op , x , y;struct SegmentTree&#123; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) int lmax[maxn&lt;&lt;2] , rmax[maxn&lt;&lt;2] , sum[maxn&lt;&lt;2] , tag[maxn&lt;&lt;2]; inline int max(int x , int y , int z)&#123; int k = x &gt; y? x : y; return k &gt; z ? k : z; &#125; void build(int l , int r , int Node) &#123; sum[Node] = lmax[Node] = rmax[Node] = r - l + 1; if(l == r) return ; int mid = l + r &gt;&gt; 1; build(l , mid , ls(Node)); build(mid + 1 , r , rs(Node)); &#125; inline void pushup(int Node , int ln , int rn)&#123; if(lmax[ls(Node)] != ln) lmax[Node] = lmax[ls(Node)]; else lmax[Node] = ln + lmax[rs(Node)]; if(rmax[rs(Node)] != rn) rmax[Node] = rmax[rs(Node)]; else rmax[Node] = rn + rmax[ls(Node)]; sum[Node] = max(sum[ls(Node)] , rmax[ls(Node)] + lmax[rs(Node)] , sum[rs(Node)]);//cautions for two hours ! are sums!! &#125; inline void pushdown(int Node , int ln , int rn) &#123; if(tag[Node]) tag[ls(Node)] = tag[rs(Node)] = tag[Node]; if(tag[Node] == 1)&#123;//mean the interval has been clear sum[ls(Node)] = sum[rs(Node)] = lmax[ls(Node)] = rmax[ls(Node)] = lmax[rs(Node)] = rmax[rs(Node)] = 0; &#125; else if(tag[Node] == 2)&#123; sum[ls(Node)] = lmax[ls(Node)] = rmax[ls(Node)] = ln; sum[rs(Node)] = lmax[rs(Node)] = rmax[rs(Node)] = rn; &#125; tag[Node] = 0; &#125; void update(int L , int R , int l , int r , int Node , int v) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; if(v == 1)&#123; sum[Node] = lmax[Node] = rmax[Node] = 0; &#125; else if(v == 2)&#123; sum[Node] = lmax[Node] = rmax[Node] = r - l + 1; &#125; tag[Node] = v; return; &#125; int mid = l + r &gt;&gt; 1; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) update(L , R , l , mid , ls(Node) , v); if(R &gt; mid) update(L , R , mid + 1, r , rs(Node) , v); pushup(Node , mid - l + 1 , r - mid); &#125; int queryPos(int l , int r , int Node , int len) &#123; if(l == r) return l; int mid = l + r &gt;&gt; 1; pushdown(Node , mid - l + 1 , r - mid); if(sum[ls(Node)] &gt;= len) return queryPos(l , mid , ls(Node) , len); if(rmax[ls(Node)] + lmax[rs(Node)] &gt;= len) return mid - rmax[ls(Node)] + 1; return queryPos(mid + 1 , r , rs(Node) , len); &#125;&#125;tr;int main()&#123; scanf("%d%d",&amp;n,&amp;m); tr.build(1,n,1); for(int i = 1 ; i &lt;= m ; ++i)&#123; scanf("%d",&amp;op); if(op == 1)&#123; scanf("%d",&amp;x); if(tr.sum[1] &gt;= x)&#123; int k = tr.queryPos(1,n,1,x); printf("%d\n",k); tr.update(k , k + x - 1 , 1 , n , 1 , 1); &#125; else puts("0"); &#125; if(op == 2)&#123; scanf("%d%d",&amp;x,&amp;y); tr.update(x , x + y - 1 , 1 , n , 1 , 2); &#125; &#125;&#125; [USACO13JAN]座位Seating题目描述To earn some extra money, the cows have opened a restaurant in their barn specializing in milkshakes. The restaurant has N seats (1 &lt;= N &lt;= 500,000) in a row. Initially, they are all empty. Throughout the day, there are M different events that happen in sequence at the restaurant (1 &lt;= M &lt;= 300,000). The two types of events that can happen are: A party of size p arrives (1 &lt;= p &lt;= N). Bessie wants to seat the party in a contiguous block of p empty seats. If this is possible, she does so in the lowest position possible in the list of seats. If it is impossible, the party is turned away. A range [a,b] is given (1 &lt;= a &lt;= b &lt;= N), and everybody in that range of seats leaves. Please help Bessie count the total number of parties that are turned away over the course of the day. 有一排n个座位，m次操作。A操作：将a名客人安置到最左的连续a个空位中，没有则不操作。L操作：[a,b]的客人离开。 求A操作的失败次数。 输入输出格式输入格式： * Line 1: Two space-separated integers, N and M. * Lines 2..M+1: Each line describes a single event. It is either a line of the form “A p” (meaning a party of size p arrives) or “L a b” (meaning that all cows in the range [a, b] leave). 输出格式： * Line 1: The number of parties that are turned away. 输入输出样例输入样例#1： 1234510 4 A 6 L 2 4 A 5 A 2 输出样例#1： 11 说明There are 10 seats, and 4 events. First, a party of 6 cows arrives. Then all cows in seats 2..4 depart. Next, a party of 5 arrives, followed by a party of 2. Party #3 is turned away. All other parties are seated. 题解 感觉写题速度太慢，考场上药丸，所以下午准备练下写题速度（3.5小时写5题中间不休息试试） 和上题一样，主要是想到最大子段和如何用线段树维护以及怎样确定最靠左的长度大于等于给定值的位置（分治的思想，能靠左就靠左，否则走右边，但是最大子段和由于左右之间有联系所以还要看看左区间和右区间中间合起来能不能行，画图讨论就能发现询中的选项一严格不劣于选项二）。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005int n , m , op , x , y , ans;struct SegmentTree&#123; #define s(x) sum[x] #define g(x) tag[x] #define lx(x) lmax[x] #define rx(x) rmax[x] #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) int sum[maxn&lt;&lt;2] , lmax[maxn&lt;&lt;2] , rmax[maxn&lt;&lt;2] , tag[maxn&lt;&lt;2]; inline int max(int x , int y, int z)&#123; int k = x &gt; y ? x : y; return k &gt; z ? k : z; &#125; void build(int l , int r , int p) &#123; s(p) = lx(p) = rx(p) = r - l + 1; if(l == r) return; int mid = l + r &gt;&gt; 1; build(l , mid , ls(p)); build(mid + 1 , r , rs(p)); &#125; inline void pushup(int p , int ln , int rn) &#123; if(lx(ls(p)) == ln) lx(p) = ln + lx(rs(p)); else lx(p) = lx(ls(p)); if(rx(rs(p)) == rn) rx(p) = rn + rx(ls(p)); else rx(p) = rx(rs(p)); s(p) = max(s(ls(p)) , s(rs(p)) , rx(ls(p)) + lx(rs(p))); &#125; inline void pushdown(int p , int ln , int rn) &#123; if(g(p) == 1)&#123;//clear lx(ls(p)) = lx(rs(p)) = s(ls(p)) = s(rs(p)) = rx(rs(p)) = rx(ls(p)) = 0; g(ls(p)) = g(rs(p)) = g(p); g(p) = 0; &#125; else if(g(p) == 2)&#123; lx(ls(p)) = s(ls(p)) = rx(ls(p)) = ln; lx(rs(p)) = s(rs(p)) = rx(rs(p)) = rn; g(ls(p)) = g(rs(p)) = g(p); g(p) = 0; &#125; &#125; void update(int L , int R , int l , int r , int p , int v) &#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; if(v == 1)&#123; s(p) = lx(p) = rx(p) = 0; &#125; else&#123; s(p) = lx(p) = rx(p) = r - l + 1; &#125; g(p) = v; return; &#125; int mid = l + r &gt;&gt; 1; pushdown(p , mid - l + 1 , r - mid); if(L &lt;= mid) update(L , R , l , mid , ls(p) , v); if(R &gt; mid) update(L , R , mid + 1 , r , rs(p) , v); pushup(p , mid - l + 1 , r - mid); &#125; int queryPos(int l , int r , int p , int len) &#123; if(l == r) return l; int mid = l + r &gt;&gt; 1; pushdown(p , mid - l + 1 , r - mid); if(s(ls(p)) &gt;= len) return queryPos(l , mid , ls(p) , len); if(lx(rs(p)) + rx(ls(p)) &gt;= len) return mid - rx(ls(p)) + 1; return queryPos(mid + 1 , r , rs(p) , len) ; &#125;&#125;tr;int main()&#123; scanf("%d%d",&amp;n,&amp;m); tr.build(1,n,1); for(int i = 1 ; i &lt;= m ; ++i) &#123; char op; std::cin&gt;&gt;op; if(op == 'A')&#123; int x; scanf("%d",&amp;x); if(tr.sum[1] &lt; x) &#123; ++ans; &#125; else&#123; int k = tr.queryPos(1,n,1,x);// printf("%d\n",k); tr.update(k , k + x - 1 , 1 , n , 1 , 1); &#125; &#125; else&#123; int x , y; scanf("%d%d",&amp;x,&amp;y); tr.update(x , y , 1 , n , 1 , 2); &#125; &#125; printf("%d",ans);&#125; [USACO08JAN]电话线Telephone Lines题目描述Farmer John wants to set up a telephone line at his farm. Unfortunately, the phone company is uncooperative, so he needs to pay for some of the cables required to connect his farm to the phone system. There are N (1 ≤ N ≤ 1,000) forlorn telephone poles conveniently numbered 1..N that are scattered around Farmer John’s property; no cables connect any them. A total of P (1 ≤ P ≤ 10,000) pairs of poles can be connected by a cable; the rest are too far apart. The i-th cable can connect the two distinct poles Ai and Bi, with length Li (1 ≤ Li ≤ 1,000,000) units if used. The input data set never names any {Ai, Bi} pair more than once. Pole 1 is already connected to the phone system, and pole N is at the farm. Poles 1 and N need to be connected by a path of cables; the rest of the poles might be used or might not be used. As it turns out, the phone company is willing to provide Farmer John with K (0 ≤ K &lt; N) lengths of cable for free. Beyond that he will have to pay a price equal to the length of the longest remaining cable he requires (each pair of poles is connected with a separate cable), or 0 if he does not need any additional cables. Determine the minimum amount that Farmer John must pay. 多年以后，笨笨长大了，成为了电话线布置师。由于地震使得某市的电话线全部损坏，笨笨是负责接到震中市的负责人。该市周围分布着N(1&lt;=N&lt;=1000)根据1……n顺序编号的废弃的电话线杆，任意两根线杆之间没有电话线连接，一共有p(1&lt;=p&lt;=10000)对电话杆可以拉电话线。其他的由于地震使得无法连接。 第i对电线杆的两个端点分别是ai,bi，它们的距离为li(1&lt;=li&lt;=1000000)。数据中每对(ai,bi)只出现一次。编号为1的电话杆已经接入了全国的电话网络，整个市的电话线全都连到了编号N的电话线杆上。也就是说，笨笨的任务仅仅是找一条将1号和N号电线杆连起来的路径，其余的电话杆并不一定要连入电话网络。 电信公司决定支援灾区免费为此市连接k对由笨笨指定的电话线杆，对于此外的那些电话线，需要为它们付费，总费用决定于其中最长的电话线的长度(每根电话线仅连接一对电话线杆)。如果需要连接的电话线杆不超过k对，那么支出为0. 请你计算一下，将电话线引导震中市最少需要在电话线上花多少钱？ 输入输出格式输入格式： 输入文件的第一行包含三个数字n,p,k; 第二行到第p+1行，每行分别都为三个整数ai,bi,li。 输出格式： 一个整数，表示该项工程的最小支出，如果不可能完成则输出-1. 输入输出样例输入样例#1： 123456785 7 11 2 53 1 42 4 83 2 35 2 93 4 74 5 6 输出样例#1： 14 题解二分答案 + SPFA松弛dp 其实想到二分答案就好，dp显然的 虽然在写这道题时依然出了很多低级错误，但还是自己调出来了了。 考场期望得分：100 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define maxn 1005#define INF 0x7f7f7f7fint head[maxn] , n , m , f[maxn][maxn], x , y , dis , knum , cnt;bool vis[maxn];struct edge&#123; int next , to , dis;&#125;e[maxn*50];inline void add(int x , int y , int dis)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;inline bool SPFA(int now)&#123;// printf("ans now : %d\n",now); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 0 ; j &lt;= n ; ++j) f[i][j] = INF; std::memset(vis,false,sizeof(vis)); std::queue&lt;int&gt; q; f[1][0] = 0; q.push(1) , vis[1] = true; while(!q.empty()) &#123; int k = q.front(); vis[k] = false; q.pop(); for(int i = head[k] ; i ; i = e[i].next)&#123; int v = e[i].to , d = e[i].dis; if(d &gt; now)&#123; for(int j = 0 ; j &lt;= knum ; ++j) if(f[k][j] + d &lt; f[v][j+1])&#123;// printf("f[%d][%d] = %d + %d &lt; f[%d][%d] = %d\n",k,j,f[k][j],d,v,j+1,f[v][j+1]); f[v][j+1] = f[k][j] + d; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; else&#123; for(int j = 0 ; j &lt;= knum ; ++j) if(f[k][j] + d &lt; f[v][j])&#123;// printf("f[%d][%d] = %d + %d &lt; f[%d][%d] = %d\n",k,j,f[k][j],d,v,j,f[v][j]); f[v][j] = f[k][j] + d; if(!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; &#125;// for(int i = 0 ; i &lt;= knum ; ++i)// printf("f[n][%d] = %d\n",i,f[n][i]); for(int i = 0 ; i &lt;= knum ; ++i) if(f[n][i] &lt; INF) return true; return false;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;knum); for(int i = 1 ; i &lt;= m ; ++i)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;dis); add(x,y,dis) , add(y,x,dis); &#125; int l = 0 , r = 100000000 , ans = INF; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(SPFA(mid)) ans = mid , r = mid - 1; else l = mid + 1; &#125; if(ans == INF)&#123; printf("-1"); return 0; &#125; printf("%d",ans);&#125; [USACO07NOV]牛继电器Cow Relays题目描述For their physical fitness program, N (2 ≤ N ≤ 1,000,000) cows have decided to run a relay race using the T (2 ≤ T ≤ 100) cow trails throughout the pasture. Each trail connects two different intersections (1 ≤ I1i ≤ 1,000; 1 ≤ I2i ≤ 1,000), each of which is the termination for at least two trails. The cows know the lengthi of each trail (1 ≤ lengthi ≤ 1,000), the two intersections the trail connects, and they know that no two intersections are directly connected by two different trails. The trails form a structure known mathematically as a graph. To run the relay, the N cows position themselves at various intersections (some intersections might have more than one cow). They must position themselves properly so that they can hand off the baton cow-by-cow and end up at the proper finishing place. Write a program to help position the cows. Find the shortest path that connects the starting intersection (S) and the ending intersection (E) and traverses exactly N cow trails. 给出一张无向连通图，求S到E经过k条边的最短路。 输入输出格式输入格式： * Line 1: Four space-separated integers: N, T, S, and E * Lines 2..T+1: Line i+1 describes trail i with three space-separated integers: lengthi , I1i , and I2i 输出格式： * Line 1: A single integer that is the shortest distance from intersection S to intersection E that traverses exactly N cow trails. 输入输出样例输入样例#1： 12345672 6 6 411 4 64 4 88 4 96 6 82 6 93 8 9 输出样例#1： 110 题解一开始还打算写SPFA松弛dp，但是看了看范围感觉不对，然后n还特别小。 于是就去学习了矩阵在图上的运用。具体参见一位集训队队员的论文。 这是弗洛伊德算法，再结合上面的分析我们胡乱填上矩阵发现这个是满足结合律的，手算一下发现可以，于是就快速幂 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 205int id[maxn*10] , n , m , k , x , y , dis , s , t;struct Matrix&#123; int mat[maxn][maxn]; Matrix()&#123; std::memset(mat,0x3f,sizeof(mat)); &#125; inline int* operator[](const int x)&#123; return mat[x]; &#125;&#125;g; Matrix operator * (Matrix&amp; x , Matrix&amp; y)&#123; Matrix c; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= n ; ++j) for(int k = 1 ; k &lt;= n ; ++k) c[i][j] = std::min(c[i][j] , x[i][k] + y[k][j]); return c;&#125;Matrix pow(Matrix&amp; x , int k)&#123; Matrix ans = x; --k; while(k)&#123; if(k&amp;1) ans = ans * x; x = x * x; k &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; scanf("%d%d%d%d",&amp;k,&amp;m,&amp;s,&amp;t); for(int i = 1 ; i &lt;= m ; ++i)&#123; scanf("%d%d%d",&amp;dis,&amp;x,&amp;y); x = id[x] ? id[x] : id[x] = ++n; y = id[y] ? id[y] : id[y] = ++n; g[x][y] = g[y][x] = std::min(g[x][y] , dis); &#125; Matrix ans = pow(g , k); printf("%d",ans[id[s]][id[t]]);&#125; [APIO2009]抢掠计划题目描述Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。 Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆 祝他的胜利。 使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希 望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可 以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机 里面就不会再有钱了。 例如，假设该城中有 6 个路口，道路的连接情况如下图所示： 市中心在路口 1，由一个入口符号→来标识，那些有酒吧的路口用双圈来表 示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢 劫的现金总数为 47，实施的抢劫路线是：1-2-4-1-2-3-5。 输入输出格式输入格式： 第一行包含两个整数 N、M。N 表示路口的个数，M 表示道路条数。接下来 M 行，每行两个整数，这两个整数都在 1 到 N 之间，第 i+1 行的两个整数表示第 i 条道路的起点和终点的路口编号。接下来 N 行，每行一个整数，按顺序表示每 个路口处的 ATM 机中的钱数。接下来一行包含两个整数 S、P，S 表示市中心的 编号，也就是出发的路口。P 表示酒吧数目。接下来的一行中有 P 个整数，表示 P 个有酒吧的路口的编号。 输出格式： 输出一个整数，表示 Banditji 从市中心开始到某个酒吧结束所能抢劫的最多 的现金总数。 输入输出样例输入样例#1： 123456789101112131415166 7 1 2 2 3 3 5 2 4 4 1 2 6 6 5 10 12 8 16 1 5 1 4 4 3 5 6 输出样例#1： 147 说明50%的输入保证 N, M&lt;=3000。所有的输入保证 N, M&lt;=500000。每个 ATM 机中可取的钱数为一个非负整数且不超过 4000。 输入数据保证你可以从市中心 沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。 题解一道sb Tarjan+SPFA松弛dp/拓扑dp我写挂好几次。。。 也就D1T2难度。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define maxn 1000005int head[maxn] , f[maxn] , n , m , vis[maxn] , valid[maxn], s , idx , p , tot , dfn[maxn] , val[maxn] , g[maxn] , low[maxn] , scc[maxn] , d[maxn] , ans , cnt;bool ins[maxn] , spfa[maxn] , conn[maxn];std::stack&lt;int&gt; st;std::map&lt;int,int&gt; rep[maxn];struct edge&#123; int next , to;&#125;e[maxn*2];struct E&#123; int fr , to;&#125;er[maxn*2];inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; ++d[y]; head[x] = cnt;&#125;inline void DP()&#123; std::queue&lt;int&gt; q; spfa[scc[s]] = true; for(int i = 1 ; i &lt;= tot ; ++i) g[i] = f[i]; q.push(scc[s]); while(!q.empty()) &#123; int k = q.front(); q.pop(); spfa[k] = false; for(int i = head[k] ; i ; i = e[i].next)&#123; int v = e[i].to;// conn[v] = true; if(f[v] &lt;= f[k] + g[v])&#123; f[v] = f[k] + g[v]; if(!spfa[v])&#123; spfa[v] = true; q.push(v); &#125; &#125; &#125; &#125;// for(int i = 1 ; i &lt;= tot ; ++i)// std::cout &lt;&lt; conn[i] &lt;&lt; ' ' &lt;&lt; valid[i] &lt;&lt; std::endl; for(int i = 1 ; i &lt;= tot ; ++i) if(valid[i]) ans = std::max(ans , f[i]);&#125;void Tarjan(int x)&#123; dfn[x] = low[x] = ++idx; st.push(x); ins[x] = true; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(!dfn[v])&#123; Tarjan(v); low[x] = std::min(low[x] , low[v]); &#125; else if(ins[v])&#123; low[x] = std::min(low[x] , dfn[v]); &#125; &#125; if(dfn[x] == low[x])&#123; ++tot; while(st.top() != x)&#123; int v = st.top(); st.pop(); f[tot] += val[v]; scc[v] = tot; ins[v] = false; valid[tot] |= vis[v]; // not vis[x] !!! no more sb mistakes!!!// printf("%d %d\n",valid[tot] , vis[x]); &#125; f[tot] += val[x]; scc[x] = tot; ins[x] = false; valid[tot] |= vis[x]; st.pop(); &#125;&#125;int main()&#123;// freopen("APIO.in","r",stdin);// freopen("APIO.out","w",stdout); scanf("%d%d",&amp;n,&amp;m); int nums = 0; int x , y; for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , er[++nums].fr = x , er[nums].to = y; for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;val[i]); scanf("%d%d",&amp;s,&amp;p); for(int i = 1 ; i &lt;= p ; ++i)&#123; int x; scanf("%d",&amp;x); vis[x] = 1; &#125; Tarjan(s);// for(int i = 1 ; i &lt;= n ; ++i)// if(vis[i])// printf("%d %d %d\n",i,scc[i] , valid[scc[i]]); std::memset(head,0,sizeof(head)); std::memset(e,0,sizeof(e)); std::memset(d,0,sizeof(d)); cnt = 0; for(int i = 1 ; i &lt;= nums ; ++i)&#123; int u = er[i].fr , v = er[i].to; if(scc[u] != scc[v] &amp;&amp; (scc[u] != 0 &amp;&amp; scc[v] != 0))&#123; add(scc[u],scc[v]); &#125; &#125; DP(); printf("%d",ans);&#125; [USACO10FEB]慢下来Slowing down题目描述Every day each of Farmer John’s N (1 &lt;= N &lt;= 100,000) cows conveniently numbered 1..N move from the barn to her private pasture. The pastures are organized as a tree, with the barn being on pasture 1. Exactly N-1 cow unidirectional paths connect the pastures; directly connected pastures have exactly one path. Path i connects pastures A_i and B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N). Cow i has a private pasture P_i (1 &lt;= P_i &lt;= N). The barn’s small door lets only one cow exit at a time; and the patient cows wait until their predecessor arrives at her private pasture. First cow 1 exits and moves to pasture P_1. Then cow 2 exits and goes to pasture P_2, and so on. While cow i walks to P_i she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow i walks slower than usual to prevent annoying her friend. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Consider the following pasture network, where the number betweenparentheses indicates the pastures' owner. 1 (3) / \ (1) 4 3 (5) / \ (2) 2 5 (4)First, cow 1 walks to her pasture: 1 (3) / \ [1] 4* 3 (5) / \ (2) 2 5 (4)When cow 2 moves to her pasture, she first passes into the barn'spasture, pasture 1. Then she sneaks around cow 1 in pasture 4 beforearriving at her own pasture. 1 (3) / \ [1] 4* 3 (5) / \ [2] 2* 5 (4)Cow 3 doesn't get far at all -- she lounges in the barn's pasture, #1. 1* [3] / \ [1] 4* 3 (5) / \ [2] 2* 5 (4)Cow 4 must slow for pasture 1 and 4 on her way to pasture 5: 1* [3] / \ [1] 4* 3 (5) / \ [2] 2* 5* [4]Cow 5 slows for cow 3 in pasture 1 and then enters her own private pasture: 1* [3] / \ [1] 4* 3*[5] / \ [2] 2* 5* [4] FJ would like to know how many times each cow has to slow down. 每天Farmer John的N头奶牛(1 &lt;= N &lt;= 100000，编号1…N)从粮仓走向他的自己的牧场。牧场构成了一棵树，粮仓在1号牧场。恰好有N-1条道路直接连接着牧场，使得牧场之间都恰好有一条路径相连。第i条路连接着A_i，B_i，(1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N)。 奶牛们每人有一个私人牧场P_i (1 &lt;= P_i &lt;= N)。粮仓的门每次只能让一只奶牛离开。耐心的奶牛们会等到他们的前面的朋友们到达了自己的私人牧场后才离开。首先奶牛1离开，前往P_1；然后是奶牛2，以此类推。 当奶牛i走向牧场P_i时候，他可能会经过正在吃草的同伴旁。当路过已经有奶牛的牧场时，奶牛i会放慢自己的速度，防止打扰他的朋友。 FJ想要知道奶牛们总共要放慢多少次速度。 输入输出格式输入格式： * Line 1: Line 1 contains a single integer: N * Lines 2..N: Line i+1 contains two space-separated integers: A_i and B_i * Lines N+1..N+N: line N+i contains a single integer: P_i 输出格式： * Lines 1..N: Line i contains the number of times cow i has to slow down. 输入输出样例输入样例#1： 123456789105 1 4 5 4 1 3 2 4 4 2 1 5 3 输出样例#1： 12340 1 0 2 题解一开始想整个巧妙的方法，最后发现HPD维护下就行了。NOIp不会考这么简单的吧。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int head[maxn] , cnt , n , val[maxn] ;struct edge&#123; int next , to;&#125;e[maxn*2];struct HPD&#123; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) int id[maxn] , hs[maxn] , sz[maxn] , dep[maxn] , top[maxn] , v[maxn] , f[maxn] , sum[maxn&lt;&lt;2] , add[maxn&lt;&lt;2] , idx; void dfs1(int x , int fx) &#123; f[x] = fx; dep[x] = dep[fx] + 1; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx) continue; dfs1(v , x); sz[x] += sz[v]; if(sz[v] &gt; sz[hs[x]]) hs[x] = v; &#125; &#125; void dfs2(int x , int topV) &#123; top[x] = topV; id[x] = ++idx; v[id[x]] = val[x]; if(!hs[x]) return; dfs2(hs[x] , topV); for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == f[x] || v == hs[x]) continue; dfs2(v , v); &#125; &#125; inline void pushup(int p)&#123; sum[p] = sum[ls(p)] + sum[rs(p)]; &#125; inline void pushdown(int p , int ln , int rn)&#123; if(add[p])&#123; add[ls(p)] += add[p] , add[rs(p)] += add[p]; sum[ls(p)] += ln * add[p] , sum[rs(p)] += rn * add[p]; add[p] = 0; &#125; &#125; void update(int pos , int l , int r , int p , int v) &#123; if(l == r)&#123; sum[p] += v; return; &#125; int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) update(pos , l , mid , ls(p) , v); else update(pos , mid + 1, r , rs(p) , v); pushup(p); &#125; int query(int L , int R , int l , int r , int p) &#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; return sum[p]; &#125; int mid = l + r &gt;&gt; 1 , ans = 0; if(L &lt;= mid) ans += query(L , R , l , mid , ls(p)); if(R &gt; mid) ans += query(L , R , mid + 1, r , rs(p)); return ans; &#125; int qLink(int x , int y) &#123; int ans = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); ans += query(id[top[x]] , id[x] , 1 , n , 1); x = f[top[x]]; &#125; if(dep[x] &lt; dep[y]) std::swap(x,y); ans += query(id[y] , id[x] , 1 , n , 1); return ans; &#125; inline void print() &#123; puts("ID"); for(int i = 1 ; i &lt;= n ; ++i) printf("%d ",id[i]); puts("SZ"); for(int i = 1 ; i &lt;= n ; ++i) printf("%d ",sz[i]); puts("top"); for(int i = 1 ; i &lt;= n ; ++i) printf("%d ",top[i]); &#125;&#125;tr;inline void add(int x , int y)&#123; e[++cnt].next = head[x] ; e[cnt].to = y; head[x] = cnt;&#125;int main()&#123; scanf("%d",&amp;n); int x , y; for(int i = 1 ; i &lt;= n-1 ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , add(y,x); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;val[i]); tr.dfs1(1,1); tr.dfs2(1,1); for(int i = 1 ; i &lt;= n ; ++i)&#123; printf("%d\n",tr.qLink(1,val[i])); tr.update(tr.id[val[i]] , 1 , n , 1 , 1); &#125;&#125; 注意变量名不要太相似，容易写错，比如p什么的，以后还是用node吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.22]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-22%2F</url>
    <content type="text"><![CDATA[[HNOI/AHOI2018]道路题目描述W 国的交通呈一棵树的形状。W 国一共有n - 1n−1个城市和nn个乡村，其中城市从11到n - 1n−1 编号，乡村从11到nn编号，且11号城市是首都。道路都是单向的，本题中我们只考虑从乡村通往首都的道路网络。对于每一个城市，恰有一条公路和一条铁路通向这座城市。对于城市i， 通向该城市的道路（公路或铁路）的起点，要么是一个乡村，要么是一个编号比ii大的城市。 没有道路通向任何乡村。除了首都以外，从任何城市或乡村出发只有一条道路；首都没有往 外的道路。从任何乡村出发，沿着唯一往外的道路走，总可以到达首都。 W 国的国王小 W 获得了一笔资金，他决定用这笔资金来改善交通。由于资金有限，小 W 只能翻修n - 1n−1条道路。小 W 决定对每个城市翻修恰好一条通向它的道路，即从公路和铁 路中选择一条并进行翻修。小 W 希望从乡村通向城市可以尽可能地便利，于是根据人口调 查的数据，小 W 对每个乡村制定了三个参数，编号为ii的乡村的三个参数是a_iai，b_ibi和c_ici。假设 从编号为ii的乡村走到首都一共需要经过xx条未翻修的公路与yy条未翻修的铁路，那么该乡村 的不便利值为 c_i \cdot (a_i + x) \cdot (b_i + y)ci⋅(ai+x)⋅(bi+y)在给定的翻修方案下，每个乡村的不便利值相加的和为该翻修方案的不便利值。 翻修n - 1n−1条道路有很多方案，其中不便利值最小的方案称为最优翻修方案，小 W 自然 希望找到最优翻修方案，请你帮助他求出这个最优翻修方案的不便利值。 输入输出格式输入格式： 第一行为正整数nn。 接下来n - 1n−1行，每行描述一个城市。其中第ii行包含两个数s_i,t_isi,ti。s_isi表示通向第ii座城市 的公路的起点，t_iti表示通向第i座城市的铁路的起点。如果s_i &gt; 0si&gt;0，那么存在一条从第s_isi座城 市通往第ii座城市的公路，否则存在一条从第-s_i−si个乡村通往第i座城市的公路；t_iti类似地，如 果t_i &gt; 0ti&gt;0，那么存在一条从第t_iti座城市通往第i座城市的铁路，否则存在一条从第-t_i−ti个乡村通 往第ii座城市的铁路。 接下来nn行，每行描述一个乡村。其中第i行包含三个数a_i,b_i,c_iai,bi,ci，其意义如题面所示。 输出格式： 输出一行一个整数，表示最优翻修方案的不便利值。 输入输出样例输入样例#1： 1234567891011126 2 3 4 5 -1 -2 -3 -4 -5 -6 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 输出样例#1： 154 输入样例#2： 1234567891011121314151617189 2 -2 3 -3 4 -4 5 -5 6 -6 7 -7 8 -8 -1 -9 1 60 1 1 60 1 1 60 1 1 60 1 1 60 1 1 60 1 1 60 1 1 60 1 1 60 1 输出样例#2： 1548 输入样例#3： 12345678910111213141516171819202122232412 2 4 5 3 -7 10 11 9 -1 6 8 7 -6 -10 -9 -4-12 -5 -2 -3 -8 -11 53 26 491 24 58 190 17 37 356 15 51 997 30 19 398 3 45 27 52 55 838 16 18 931 58 24 212 43 25 198 54 15 172 34 5 524 输出样例#3： 复制 15744902 说明【样例解释 1】 如图所示，我们分别用蓝色、黄色节点表示城市、乡村；用绿色、红色箭头分别表示 公路、铁路；用加粗箭头表示翻修的道路。 一种不便利值等于54的方法是：翻修通往城市2和城市5的铁路，以及通往其他城市的 公路。用→和⇒表示公路和铁路，用∗→和∗⇒表示翻修的公路和铁路，那么： 编号为1的乡村到达首都的路线为：-1 ∗→ 3 ⇒ 1，经过0条未翻修公路和1条未翻修铁 路，代价为3 × (1 + 0) × (2 + 1) = 9；编号为2的乡村到达首都的路线为：-2 ⇒ 3 ⇒ 1，经过0条未翻修公路和2条未翻修铁 路，代价为2 × (1 + 0) × (3 + 2) = 10；编号为3的乡村到达首都的路线为：-3 ∗→ 4 → 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为3 × (2 + 1) × (1 + 0) = 9；编号为4的乡村到达首都的路线为：-4 ⇒ 4 → 2 ∗→ 1，经过1条未翻修公路和1条未翻 修铁路，代价为1 × (2 + 1) × (3 + 1) = 12；编号为5的乡村到达首都的路线为：-5 → 5 ∗⇒ 2 ∗→ 1，经过1条未翻修公路和0条未 翻修铁路，代价为2 × (3 + 1) × (1 + 0) = 8；编号为6的乡村到达首都的路线为：-6 ∗⇒ 5 ∗⇒ 2 ∗→ 1，经过0条未翻修公路和0条未翻修铁路，代价为1 × (3 + 0) × (2 + 0) = 6； 总的不便利值为9 + 10 + 9 + 12 + 8 + 6 = 54。可以证明这是本数据的最优解。 【样例解释 2】 在这个样例中，显然应该翻修所有公路。 【数据范围】 一共20组数据，编号为1 ∼ 20。 对于编号\le 4≤4的数据，n \le 20n≤20；对于编号为5 ∼ 8的数据，a_i,b_i,c_i \le 5ai,bi,ci≤5，n \le 50n≤50；对于编号为9 ∼ 12的数据，n \le 2000n≤2000；对于所有的数据， n \le 20000，1 \le a_i,b_i \le 601≤ai ,bi≤60，1 \le c_i \le 10^9，s_i,t_i是[-n,-1] \cup (i,n - 1]内的整数，任意乡村可以通过不超过40条道路到达首都。 题解首先应该看到最后说不超过40条到首都， 提示我们要将这个东西作为状态。 设 f(i,j,k)表示i到根需要经过j条没翻修铁路，k条没翻修公路， 然后题目又说通往城市的道路要么修左边要么修右边，这就是很明显的转移了。 对于乡村我们直接计算返回，对于城市看看删左边和右边哪个更优，记忆化搜索即可。 Code： 12 一共简短的20行，然而交上去一看居然RE？512MB内存开不了3000w long long？ 换种下标（玄学）就可以过了。 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 20005#define LL long long#define INF 0x7fffffffstruct Node&#123; LL a , b , c;&#125;g[maxn];LL n , f[maxn][42][42] , ans;int ls[maxn] , rs[maxn];LL dfs(int x, int k , int p)&#123; if(x &gt;= n) return g[x-n+1].c * (g[x-n+1].a + k) * (g[x-n+1].b + p); if(f[x][k][p] != f[0][0][0]) return f[x][k][p]; return f[x][k][p] = std::min(dfs(ls[x] , k + 1 , p) + dfs(rs[x] , k , p) , dfs(rs[x] , k , p + 1) + dfs(ls[x] , k, p) );&#125;int main()&#123; scanf("%lld",&amp;n); std::memset(f,0x5f,sizeof(f)); int x , y , z; for(int i = 1 ; i &lt;= n - 1 ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); if(x &lt; 0) x = n - x - 1; if(y &lt; 0) y = n - y - 1; ls[i] = x , rs[i] = y; &#125; for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld%lld%lld",&amp;g[i].a,&amp;g[i].b,&amp;g[i].c); ans = dfs(1 , 0 , 0); printf("%lld",ans);&#125; 有时候树形dp不一定以子树来转移哦。]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.21]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-21%2F</url>
    <content type="text"><![CDATA[「一本通 5.2 练习 2」旅游规划题目描述W 市的交通规划出现了重大问题，市政府下定决心在全市各大交通路口安排疏导员来疏导密集的车流。但由于人员不足，W 市市长决定只在最需要安排人员的路口安排人员。 具体来说，W 市的交通网络十分简单，由 n 个交叉路口和 n−1 条街道构成，交叉路口路口编号依次为 0,1,⋯ ,n−10,1,\cdots ,n-10,1,⋯,n−1 。任意一条街道连接两个交叉路口，且任意两个交叉路口间都存在一条路径互相连接。 经过长期调查，结果显示，如果一个交叉路口位于 W 市交通网最长路径上，那么这个路口必定拥挤不堪。所谓最长路径，定义为某条路径 p=(v1,v2,v3,⋯ ,vk)p=(v_1,v_2,v_3,\cdots,v_k)p=(v1,v2,v3,⋯,vk)，路径经过的路口各不相同，且城市中不存在长度大于 kkk 的路径，因此最长路径可能不唯一。因此 Ｗ 市市长想知道哪些路口位于城市交通网的最长路径上。 输入格式第一行一个整数 n； 之后 n−1 行每行两个整数 u,v，表示 u 和 v 的路口间存在着一条街道。 输出格式输出包括若干行，每行包括一个整数——某个位于最长路径上的路口编号。为了确保解唯一，请将所有最长路径上的路口编号按编号顺序由小到大依次输出。 样例样例输入12345678910100 10 20 40 60 71 32 54 86 9 样例输出123456789012345689 数据范围与提示对于全部数据， 1\le n\le 2\times 10^5题解一句话题意，求一棵树上所有直径上的所有点。 我们先想想如何判断一个点是否是直径上的点。 考虑它在一棵树上延伸的最长链和次长链，假设这两个加起来等于直径，那它就是直径上的点。 假如它小于直径上，我们是否能证明他不在直径上呢？ 显然反证法，假设它在一条直径上，直径两端点必定有一个是他的最长链端点，否则这就不是直径了。 假设另一个端点不是直径端点，设它次长链端点为V，显然V和最长链端点构成新的直径，与假设矛盾。 也就是说一个点在直径上，它的最长链和次长链端点就是直径两个端点。因此我们只需要知道每个点能伸展的最长链和次长链即可。 假设我们以任意点为根，树上一个点的最长链和次长链必定是子树内最长链，子树内次长链，子树外最长链（子树外次长链无论如何能被子树内最长链代替，没有用）中的二者。 这就是一个典型的换根dp，或者说up and down 假设以s为根，先up出以s为根的有根树每个点子树内的最长链和次长链。 up完后，我们可以顺便求出直径长度（直径必定是某个点子树内的最长链和次长链之和，假如不是，那这条直径上的点就造成了矛盾）。 这时候我们假如枚举根来继续这样求，时间复杂度 O(n^2)超时的原因是我们没有考虑根转移后状态的联系。 我们以最顶端为根，已经完成了up的过程。 这时候我们想向子节点转移。 显然以子节点为根最长链和次长链只有上述说的三种情况。但是要注意这个原根的最长链可能就是由这个节点转移过来的因此我们在up最长链的时候记录最长链由哪个子节点转移过来的。down的时候假设当前子节点是原根最长链的转移者，就用根的次长链来更新，实现常数换根转移。 总复杂度 O（n）Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define INF 0x7fffffff#define maxn 200005int f[maxn] , g[maxn] , p[maxn] , q[maxn] , tot , cnt , head[maxn] , n , u , v , maxx , dw[maxn] , ver[maxn] , dist;struct edge&#123; int next , to , dis;&#125;e[maxn*2];inline void add(int x ,int y , int d)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;void up(int x , int fx)&#123; f[x] = 0 , g[x] = 0; for(int i = head[x] ; i ; i = e[i].next) &#123; if(e[i].to == fx) continue; up(e[i].to , x); if(f[e[i].to] + e[i].dis &gt; f[x]) &#123; g[x] = f[x]; f[x] = f[e[i].to] + e[i].dis; p[x] = e[i].to; &#125; else if(f[e[i].to] + e[i].dis &gt; g[x]) g[x] = f[e[i].to] + e[i].dis; &#125;&#125;void down(int x , int fx , int dis)&#123; // printf("%d %d : \n",x,fx); if(p[fx] != x) &#123; // printf("bef : %d %d %d\n",f[x] , g[x] , f[fx] + dis); if(f[fx] + dis &gt; f[x]) &#123; g[x] = f[x]; f[x] = f[fx] + dis; p[x] = fx; &#125; else if(f[fx] + dis &gt; g[x]) g[x] = f[fx] + dis; // printf("las : %d %d %d\n",f[x] , g[x] , f[fx] + dis); &#125; else &#123; // printf("bef : %d %d %d\n",f[x] , g[x] , g[fx] + dis); if(g[fx] + dis &gt; f[x]) &#123; g[x] = f[x]; f[x] = g[fx] + dis; p[x] = fx; &#125; else if(g[fx] + dis &gt; g[x]) g[x] = g[fx] + dis; // printf("las : %d %d %d\n",f[x] , g[x] , g[fx] + dis); &#125; // if(f[x] + g[x] == dist) ver[++tot] = x; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) down(e[i].to , x, e[i].dis);&#125;int main()&#123; scanf("%d",&amp;n); int x , y , d; for(int i = 1 ; i &lt;= n-1 ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x+1,y+1,1) , add(y+1,x+1,1); up(1,0); for(int i = 1 ; i &lt;= n ; ++i) dist = std::max(dist , f[i] + g[i]); down(1,0,0); // std::sort(ver+1,ver+tot+1); // for(int i = 1 ; i &lt;= tot ; ++i) // printf("%d\n",ver[i]-1); for(int i = 1 ; i &lt;= n ; ++i) if(f[i] + g[i] == dist) printf("%d\n",i-1);&#125; Ps:写的时候又犯了睿智错误，把变量和数组名写错了。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef->NO.6]]></title>
    <url>%2F2018%2F11%2F17%2FBEF%206%2F</url>
    <content type="text"><![CDATA[NOIp 2015 运输计划题目背景公元 20442044 年,人类进入了宇宙纪元。 题目描述公元20442044 年，人类进入了宇宙纪元。 L 国有 nn 个星球，还有 n-1n−1 条双向航道，每条航道建立在两个星球之间，这 n-1n−1 条航道连通了 LL 国的所有星球。 小 P 掌管一家物流公司， 该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 u_i号星球沿最快的宇航路径飞行到 v_ivi 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 j，任意飞船驶过它所花费的时间为 t_jtj，并且任意两艘飞船之间不会产生任何干扰。 为了鼓励科技创新， L 国国王同意小 P 的物流公司参与 L国的航道建设，即允许小P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。 在虫洞的建设完成前小 P 的物流公司就预接了 m 个运输计划。在虫洞建设完成后，这 m 个运输计划会同时开始，所有飞船一起出发。当这 m 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。 如果小 PP 可以自由选择将哪一条航道改造成虫洞， 试求出小 PP 的物流公司完成阶段性工作所需要的最短时间是多少？ 输入输出格式输入格式： 第一行包括两个正整数 n, m表示 L 国中星球的数量及小 P 公司预接的运输计划的数量，星球从 11 到 nn 编号。 接下来 n-1行描述航道的建设情况，其中第 ii 行包含三个整数 a_i, b_iai,bi 和 t_iti，表示第 ii 条双向航道修建在 a_iai与 b_ibi 两个星球之间，任意飞船驶过它所花费的时间为 t_iti。数据保证 1 \leq a_i,b_i \leq n1≤ai,bi≤n 且 0 \leq t_i \leq 10000≤ti≤1000。接下来 m行描述运输计划的情况，其中第 j 行包含两个正整数 u_j 和 v_j表示第 j 个运输计划是从 u_j号星球飞往 v_j号星球。数据保证 1 \leq u_i,v_i \leq n1≤ui,vi≤n输出格式： 一个整数，表示小 PP 的物流公司完成阶段性工作所需要的最短时间。 输入输出样例输入样例#1： 复制 1234567896 3 1 2 3 1 6 4 3 1 7 4 3 6 3 5 5 3 6 2 5 4 5 输出样例#1： 复制 111 说明所有测试数据的范围和特点如下表所示 请注意常数因子带来的程序效率上的影响。 题意给定一棵树，给定m条链，要求选择树上一条边使边权为零，m条链中的最大值最小。 题解答案显然满足可行性单调，因此二分答案。 对于每个答案我们怎么快速检验呢？显然那些最大值小于当前答案的就不用管了，对于那些最大值大于当前答案的，我们必须找到被所有最大值大于当前答案的链覆盖的边，这些边中最大的去减掉链中最大的要是合法即可满足当前答案，如何求上述问题呢？ 树上差分：树上差分总结：可以O(1)修改树上路径每条边边权或点权（对每条边相同的修改值），O(n)求出两点间的边权和或点权和。假设修改值为1，即可解决点或边的覆盖链数目。 因此每次二分答案+树上差分判断即可以 O(nlog(Tmax))的复杂度通过本题。 Note:写这道题时二分还出了问题，假设最后检测的是l == r（也就是mid），那么检测可以就是l，不行就是l+1，和其他的二分还是有区别的。 Code : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define maxn 300000#define max(a,b) (a) &gt; (b) ? (a) : (b)#define min(a,b) (a) &lt; (b) ? (a) : (b)inline bool check();int n , m , f[maxn+5][21] , head[maxn+5] , cnt , depth[maxn+5] , s[maxn+5] , lg[maxn+4] , c[maxn+5] , len[maxn+5] , curmax , ans;struct edge&#123; int next , to , dis;&#125;e[maxn*2+5];struct Pair&#123; int u , v , f , w;&#125;p[maxn+5];inline void pre();void dfs(int x , int fa , int d);inline int LCA(int x , int y);inline void add(int from , int to , int dis);bool solve(int x);//the edge to x is bugholevoid getLegal(int x , int fa);inline bool cmp(Pair a , Pair b)&#123;return a.w &lt; b.w;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int xx , yy , dd; for(int i = 1 ; i &lt;= n-1 ; ++i) &#123; scanf("%d%d%d",&amp;xx,&amp;yy,&amp;dd); add(xx,yy,dd); add(yy,xx,dd); &#125; dfs(1,0,0); pre(); // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d ",len[i]); for(int i = 1 ; i &lt;= m ; ++i) &#123; scanf("%d%d",&amp;p[i].u,&amp;p[i].v); p[i].f = LCA(p[i].u,p[i].v); p[i].w = s[p[i].u] + s[p[i].v] - 2 * s[p[i].f]; // printf("%d %d %d %d\n",p[i].u,p[i].v,p[i].f,p[i].w); &#125; std::sort(p+1,p+m+1,cmp); // for(int i = 1 ; i &lt;= m ; ++i) // printf("%d\n",p[i].w); int l = 0 ,r = maxn*1000; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; // printf("l = %d r = %d mid = %d\n",l,r,mid); if(solve(mid)) r = mid - 1 ; else l = mid + 1; &#125; printf("%d",max(l,0));&#125;void dfs(int x , int fa , int d)&#123; depth[x] = depth[fa] + 1; f[x][0] = fa; s[x] = s[fa] + d; len[x] = d; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fa) dfs(e[i].to,x,e[i].dis);&#125;inline int LCA(int x , int y)&#123; if(depth[x] &lt; depth[y]) std:: swap(x,y); while(depth[x] &gt; depth[y]) x = f[x][lg[depth[x]-depth[y]]-1]; if(x == y) return x; for(int i = lg[depth[x]]; i &gt;= 0 ; i--) if(f[x][i] != f[y][i]) x = f[x][i] , y = f[y][i]; return f[x][0]; &#125;inline void pre()&#123; for(int j = 1 ; j &lt;= 20 ; ++j) for(int i = 1 ; i &lt;= n ; ++i) f[i][j] = f[f[i][j-1]][j-1]; for(int i = 1 ; i &lt;= n ; ++i) lg[i] = lg[i-1]+(1&lt;&lt;lg[i-1]==i);&#125;inline void add(int from , int to , int dis)&#123; e[++cnt].next = head[from]; e[cnt].to = to; e[cnt].dis = dis; head[from] = cnt;&#125;bool solve(int x)&#123; // printf("the time of = %d\n",x); for(int i = 1 ; i &lt;= n ; ++i)// the differ array to find the common edge c[i] = 0 ; curmax = -99999999; int maxx = -99999999; int l = 0 , r = m; // while(l &lt;= r) // &#123; // int mid = l + r &gt;&gt; 1; // if(p[mid].w &lt;= x) l = mid + 1; // else r = mid - 1; // &#125; // printf("%d %d\n",l,r); for(int i = 1 ; i &lt;= n ; ++i) if(p[i].w &gt; x) &#123; l = i; break; &#125; if(!l) return true; for(int i = l ; i &lt;= m ; ++i) ++c[p[i].u] , ++c[p[i].v] , c[p[i].f] -= 2 , maxx = max(maxx,p[i].w);//tree differ of edge getLegal(1,0); // if(tot == 0) return false; // printf("the num of illigal = %d ",m-l+1); // for(int i = 1; i &lt;= n ; ++i) // printf("c[%d]=%d ",i,c[i]); for(int i = 1 ; i &lt;= n ; ++i) if(c[i] == m-l+1) curmax = max(curmax,len[i]); // printf("curmax = %d , maxx = %d ",curmax,maxx); // putchar(10) , putchar(10); if(maxx - curmax &lt;= x) return true; else return false;&#125;void getLegal(int x , int fa)&#123; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fa) getLegal(e[i].to,x) , c[x] += c[e[i].to];&#125; 边权差分（仅仅是LCA节点最后少减一个1） [JLOI2014]松鼠的新家题目描述松鼠的新家是一棵树，前几天刚刚装修了新家，新家有n个房间，并且有n-1根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在”树“上。 松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去a1，再去a2，……，最后到an，去参观新家。可是这样会导致维尼重复走很多房间，懒惰的维尼不停地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。 维尼是个馋家伙，立马就答应了。现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。 因为松鼠参观指南上的最后一个房间an是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。 输入输出格式输入格式： 第一行一个整数n，表示房间个数第二行n个整数，依次描述a1-an 接下来n-1行，每行两个整数x，y，表示标号x和y的两个房间之间有树枝相连。 输出格式： 一共n行，第i行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。 输入输出样例输入样例#1： 12345651 4 5 3 21 22 42 34 5 输出样例#1： 1234512121 说明2&lt;= n &lt;=300000 注意细节就好. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define maxn 300000int n , t[maxn+5] , head[maxn+5] , cnt , c[maxn+5] , f[maxn+5][21] , depth[maxn+5] , lg[maxn+5];struct edge&#123; int next , to;&#125;e[maxn*2+5];struct link&#123; int u , v , f;&#125;l[maxn+5];inline int LCA(int x , int y);inline void pre();void dfs(int x , int fa);inline void add(int from, int to);void dif();void getDif(int x , int fa);inline void swap(int&amp; x , int&amp; y);int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;t[i]); for(int i = 1 ; i &lt;= n ; ++i) lg[i] = lg[i-1] + (1&lt;&lt;lg[i-1] == i); int x , y ; for(int i = 1 ; i &lt;= n-1 ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , add(y,x); dfs(1,0); pre(); for(int i = 2 ; i &lt;= n ; ++i) l[i-1].u = t[i-1] , l[i-1].v = t[i] , l[i-1].f = LCA(l[i-1].u,l[i-1].v); // for(int i = 1 ; i &lt;= n-1 ; ++i) // printf("l[%d].u = %d l[%d].v = %d l[%d].f = %d\n",i,l[i].u,i,l[i].v,i,l[i].f); dif(); for(int i = 1 ; i &lt;= n ; ++i) printf("%d\n",c[i]);&#125;inline void add(int from, int to)&#123; e[++cnt].next = head[from]; e[cnt].to = to; head[from] = cnt;&#125;void dfs(int x , int fa)&#123; depth[x] = depth[fa] + 1; f[x][0] = fa; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fa) dfs(e[i].to,x);&#125;inline void pre()&#123; for(int j = 1 ; j &lt;= 20 ; ++j) for(int i = 1 ; i &lt;= n ; ++i) f[i][j] = f[f[i][j-1]][j-1];&#125;void dif()&#123; for(int i = 1 ; i &lt;= n-1 ; ++i) ++c[l[i].u] , ++c[l[i].v] , --c[l[i].f] , --c[f[l[i].f][0]]; // ++c[l[n-1].u] , ++c[f[l[n-1].v][0]] , --c[LCA(l[n-1].u,f[l[n-1].v][0])]; getDif(1,0); for(int i = 2 ; i &lt;= n ; ++i) --c[t[i]];&#125;void getDif(int x, int fa)&#123; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fa) getDif(e[i].to , x) , c[x] += c[e[i].to];&#125;inline int LCA(int x, int y)&#123; if(depth[x] &lt; depth[y]) swap(x,y); while(depth[x] &gt; depth[y]) x = f[x][lg[depth[x]-depth[y]]-1]; if(x == y) return x; for(int i = lg[depth[x]] ; i &gt;= 0 ; --i) if(f[x][i] != f[y][i]) x = f[x][i] , y = f[y][i]; return f[x][0];&#125;inline void swap(int&amp; x, int&amp; y)&#123; int t; t = x , x = y , y = t;&#125;]]></content>
      <tags>
        <tag>二分答案 树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.34]]></title>
    <url>%2F2018%2F11%2F17%2FNO-34%2F</url>
    <content type="text"><![CDATA[今天虽然放假，不过考虑到NOIp还有6天，还是在家好好学学OI吧。（NOIp怎么也得拿个省一吧） P1073 最优贸易题目描述CC国有nn个大城市和mm 条道路，每条道路连接这 nn个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 mm 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 11条。 CC国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。 商人阿龙来到 CC 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 CC 国 n 个城市的标号从 1~ n1 n，阿龙决定从 11号城市出发，并最终在 nn 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 nn 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 CC 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。 假设 CC国有 55个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。 假设 1~n1 n 号城市的水晶球价格分别为 4,3,5,6,14,3,5,6,1。 阿龙可以选择如下一条线路：11-&gt;22-&gt;33-&gt;55，并在 22号城市以33 的价格买入水晶球，在 33号城市以55的价格卖出水晶球，赚取的旅费数为 2。 阿龙也可以选择如下一条线路11-&gt;44-&gt;55-&gt;44-&gt;55，并在第11次到达55 号城市时以 11的价格买入水晶球，在第 22 次到达44 号城市时以66 的价格卖出水晶球，赚取的旅费数为55。 现在给出 nn个城市的水晶球价格，mm 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入输出格式输入格式： 第一行包含 22 个正整数nn和 mm，中间用一个空格隔开，分别表示城市的数目和道路的数目。 第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。 接下来 mm 行，每行有33个正整数x,y,zx,y,z，每两个整数之间用一个空格隔开。如果 z=1z=1，表示这条道路是城市xx到城市yy之间的单向道路；如果z=2z=2，表示这条道路为城市 xx和城市yy之间的双向道路。 输出格式： 一 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 00。 输入输出样例输入样例#1： 12345675 5 4 3 5 6 1 1 2 1 1 4 1 2 3 2 3 5 1 4 5 2 输出样例#1： 15 说明【数据范围】 输入数据保证 11 号城市可以到达nn号城市。 对于 10%的数据，1≤n≤61≤n≤6。 对于 30%的数据，1≤n≤1001≤n≤100。 对于 50%的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。 对于 100%的数据，1≤n≤1000001≤n≤100000，1≤m≤5000001≤m≤500000，1≤x1≤x，y≤ny≤n，1≤z≤21≤z≤2，1≤1≤各城市 水晶球价格≤100≤100。 NOIP 2009 提高组 第三题 题解一道挺不错的题，现在D1T2难度正合适。 主要是用最短路中松弛的思想来找到dp顺序并优化dp。 最初在考场上没看到要到点n结果爆零实际上很接近正解。 话说这道题还有分层图的做法不如一会看看，今天上午准备学一下分层图。 设 f(n)表示最大差值，然后记录能到达当前点的最小值，和当前点做差的值与前面得到的差值的最大值取最大即可。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define INF 0x7ffffff#define maxn 100005std::vector&lt;int&gt; g[maxn];int f[maxn] , n , m , val[maxn] , minn[maxn];bool vis[maxn];void SPFA(int x)&#123; std::queue&lt;int&gt; q; q.push(x); vis[x] = true; while(!q.empty())&#123; int k = q.front(); vis[k] = false; q.pop(); for(int i = 0 ; i &lt; (int)g[k].size() ; ++i)&#123; int v = g[k][i]; minn[v] = std::min(minn[v] , minn[k]); if(val[v] - minn[k] &gt; f[v])&#123; f[v] = val[v] - minn[k]; if(!vis[v]) q.push(v); &#125; if(f[k] &gt; f[v])&#123; f[v] = f[k] ; if(!vis[v]) q.push(v); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y , t; for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;val[i]); for(int i = 1 ; i &lt;= m ; ++i)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;t); g[x].push_back(y); if(t == 2)&#123; g[y].push_back(x); &#125; &#125; std::memset(f,-0x7f,sizeof(f)); for(int i = 1 ; i &lt;= n ; ++i) minn[i] = val[i]; SPFA(1); if(f[n] &lt; 0) f[n] = 0; printf("%d",f[n]);&#125; P4568 [JLOI2011]飞行路线题目描述Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为00到n-1n−1，一共有mm种航线，每种航线连接两个城市，并且航线有一定的价格。 Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多kk种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？ 输入输出格式输入格式： 数据的第一行有三个整数，n,m,kn,m,k，分别表示城市数，航线数和免费乘坐次数。第二行有两个整数，s,ts,t，分别表示他们出行的起点城市编号和终点城市编号。接下来有m行，每行三个整数，a,b,ca,b,c，表示存在一种航线，能从城市aa到达城市bb，或从城市bb到达城市aa，价格为cc。 输出格式： 只有一行，包含一个整数，为最少花费。 输入输出样例输入样例#1： 123456785 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100 输出样例#1： 18 说明对于100%的数据, 2 \le n \le 10000,1 \le m \le 50000,0 \le k \le 100 \le s,t]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.38]]></title>
    <url>%2F2018%2F11%2F17%2FNO-38%2F</url>
    <content type="text"><![CDATA[P3959 宝藏题目描述参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 nn 个深埋在地下的宝藏屋， 也给出了这 nn 个宝藏屋之间可供开发的mm 条道路和它们的长度。 小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远， 也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路 则相对容易很多。 小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某 个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。 在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路 所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏 屋之间的道路无需再开发。 新开发一条道路的代价是： \mathrm{L} \times \mathrm{K}L代表这条道路的长度，K代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的 宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。 请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代 价最小，并输出这个最小值。 输入输出格式输入格式： 第一行两个用空格分离的正整数 n,mn,m，代表宝藏屋的个数和道路数。 接下来 mm 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏 屋的编号（编号为 1-n1−n），和这条道路的长度 vv。 输出格式： 一个正整数，表示最小的总代价。 输入输出样例输入样例#1： 1234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 1 输出样例#1： 14 输入样例#2： 1234564 5 1 2 1 1 3 3 1 4 1 2 3 4 3 4 2 输出样例#2： 15 说明 【样例解释1】 小明选定让赞助商打通了11 号宝藏屋。小明开发了道路 1 \to 21→2，挖掘了 22 号宝 藏。开发了道路 1 \to 41→4，挖掘了 44 号宝藏。还开发了道路 4 \to 34→3，挖掘了33号宝 藏。工程总代价为：1 \times 1 + 1 \times 1 + 1 \times 2 = 41×1+1×1+1×2=4 【样例解释2】 小明选定让赞助商打通了11 号宝藏屋。小明开发了道路 1 \to 21→2，挖掘了 22 号宝 藏。开发了道路 1 \to 31→3，挖掘了 33 号宝藏。还开发了道路 1 \to 41→4，挖掘了44号宝 藏。工程总代价为：1 \times 1 + 3 \times 1 + 1 \times 1 = 51×1+3×1+1×1=5 1 \le n \le 12，0 \le m \le 1000，v \le 500000题解这道题其实不难，而且很有启发意义。 之所以最小生成树是错误的，主要原因在于深度对费用的干扰导致贪心的错误。 既然这样我们就把深度作为状态压缩的一维进行dp 而转移我们发现枚举量很大，在枚举深度的前提下枚举当前打通的点集枚举补集的子集，然后再判断当前点集和补集子集能否一步联通。 我们预处理任意两不相交点集联通代价 O(n^23^n)注意两点集不能一次联通应设为无穷量。 dp转移 f(i,S_i | S_j ) = min(f(i-1,S_i)+ COST(S_i,S_j))注意枚举补集。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 12#define INF 0x2fffffff//must from zeroint pre[1&lt;&lt;maxn][1&lt;&lt;maxn] , dis[maxn][maxn] , n , m , f[maxn+1][1&lt;&lt;maxn];inline int Cost(int S1 , int S2)&#123; int ans = 0; for(int i = 0 ; i &lt; n ; ++i)&#123; int v = 1 &lt;&lt; i; if(S2 &amp; v)&#123; int cur = INF; for(int j = 0 ; j &lt; n ; ++j) if(S1 &amp; (1 &lt;&lt; j)) cur = std::min(cur , dis[i][j]); if(cur == INF) return INF; ans += cur; &#125; &#125; return ans;&#125;void write(int x)&#123; if(!x) return; write(x &gt;&gt; 1); putchar((x&amp;1)+48);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 0 ; i &lt; n ; ++i) for(int j = 0 ; j &lt; n ; ++j) dis[i][j] = INF; for(int i = 1 ; i &lt;= m ; ++i)&#123; int x , y , d; scanf("%d%d%d",&amp;x,&amp;y,&amp;d); --x , --y; dis[x][y] = dis[y][x] = std::min(dis[x][y] , d); &#125; int S = 1 &lt;&lt; n; for(int i = 0 ; i &lt; S ; ++i)&#123;//prepare the one step minimum value int G = S - 1 ^ i; for(int j = G ; j ; j = j - 1 &amp; G)&#123; pre[i][j] = Cost(i,j); &#125; &#125; for(int i = 0 ; i &lt;= n ; ++i) for(int j = 0 ; j &lt; S ; ++j) f[i][j] = INF; for(int i = 0 ; i &lt; n ; ++i) f[0][1&lt;&lt;i] = 0; for(int h = 0 ; h &lt; n ; ++h)&#123; for(int i = 0 ; i &lt; S ; ++i)&#123; int G = S - 1 ^ i; for(int j = G ; j ; j = j - 1 &amp; G) if(f[h][i] &lt; INF &amp;&amp; pre[i][j] &lt; INF)&#123; f[h+1][i | j] = std::min(f[h+1][i | j] , f[h][i] + (h + 1) * pre[i][j]); &#125; &#125; &#125; int ans = 0x7ffffff; for(int i = 0 ; i &lt;= n ; ++i) ans = std::min(ans , f[i][S-1]); printf("%d",ans);&#125; 注意只有一个点的情况，考试丢5分也很亏啊。。 P1080 国王游戏题目描述恰逢 HH国国庆，国王邀请nn 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 nn 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入输出格式输入格式： 第一行包含一个整数nn，表示大臣的人数。 第二行包含两个整数 aa和 bb，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来 nn行，每行包含两个整数aa 和 bb，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式： 一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 输入输出样例输入样例#1： 123453 1 1 2 3 7 4 4 6 输出样例#1： 12 说明【输入输出样例说明】 按11、22、33 这样排列队伍，获得奖赏最多的大臣所获得金币数为 22； 按 11、33、22 这样排列队伍，获得奖赏最多的大臣所获得金币数为22； 按 22、11、33 这样排列队伍，获得奖赏最多的大臣所获得金币数为 22； 按22、33、11这样排列队伍，获得奖赏最多的大臣所获得金币数为99； 按 33、11、22这样排列队伍，获得奖赏最多的大臣所获得金币数为 22； 按33、22、11 这样排列队伍，获得奖赏最多的大臣所获得金币数为 99。 因此，奖赏最多的大臣最少获得 22个金币，答案输出 22。 【数据范围】 对于 20%的数据，有 1≤ n≤ 10,0 &lt; a,b &lt; 81≤n≤10,0&lt;a,b&lt;8； 对于 40%的数据，有1≤ n≤20,0 &lt; a,b &lt; 81≤n≤20,0&lt;a,b&lt;8； 对于 60%的数据，有 1≤ n≤1001≤n≤100； 对于 60%的数据，保证答案不超过 10^9109； 对于 100%的数据，有 1 ≤ n ≤1,000,0 &lt; a,b &lt; 100001≤n≤1,000,0&lt;a,b&lt;10000。 NOIP 2012 提高组 第一天 第二题 题解一道很不错的贪心题。 应用微扰法证明贪心正确性。（前后代价做商应该不难看出） 顺便练了练恶心的高精度，学了下高精除低精。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 1005#define ll long longll n;struct Node&#123; ll x , y; bool operator &lt; (const Node&amp; g)const &#123; return x * y &lt; g.x * g.y; &#125;&#125;p[maxn]; struct BIGNUM&#123; ll num[maxn*10] , len; BIGNUM()&#123; num[1] = 1; len = 1; &#125; void mul(const ll&amp; x) &#123; for(int i = 1 ; i &lt;= len ; ++i)&#123; num[i] *= x; &#125; for(int i = 1 ; i &lt;= len ; ++i)&#123; if(num[i] &gt; 9)&#123; if(i + 1 &gt; len)&#123; ++len; &#125; num[i+1] += num[i] / 10; num[i] %= 10; &#125; &#125; &#125; void max(BIGNUM&amp; x , BIGNUM&amp; y) &#123; if(x.len &lt; y.len)&#123; x = y; return; &#125; else if(x.len &gt; y.len) return; else&#123; for(int i = x.len ; i ; --i)&#123; if(x.num[i] &gt; y.num[i]) return; else if(x.num[i] &lt; y.num[i])&#123; x = y; return; &#125; &#125; &#125; &#125; void div(const BIGNUM&amp; g , ll x) &#123; ll cur = 0; for(int i = len ; i ; --i)&#123; num[i] = (cur * 10 + g.num[i]) / x; cur = (cur * 10 + g.num[i]) % x; &#125; while(!num[len]) --len; &#125; void print() &#123; for(int i = len ; i &gt;= 1 ; --i) printf("%d",num[i]); &#125;&#125;cur , ans , g; int main()&#123;// freopen("King.in","r",stdin); scanf("%lld",&amp;n); for(int i = 0 ; i &lt;= n ; ++i) scanf("%lld%lld",&amp;p[i].x,&amp;p[i].y); std::sort(p + 1 , p + n + 1); cur.mul(p[0].x); for(int i = 1 ; i &lt;= n ; ++i)&#123; g = cur; g.div(cur , p[i].y); ans.max(ans , g); cur.mul(p[i].x); &#125; ans.print();&#125; 一共就做了这两题。上午考了次试，感觉题都还行。 Pictionary题意：给你n个独立的点，一共有m天，第i天会将gcd(a,b)=m-i+1的点连接起来，q个询问，求x,y在哪一天被连接起来。 n &lt;= 100000 题解为什么就我想不到正解啊啊啊啊啊。 我就会30分。。 30分做法：考虑两点之间的传递，用类似Floyd的方法更新，成功成为全场最低分（第二题折半搜索其实是正解，只不过我当时没想到按高度统计这一非常简单的方法。。加个n又不是过不了） 满分做法： 其实还是有建图的思想。以后看到这种连续的gcd，lcm之类的就可以想到倍数关系啦！！ 考虑从m开始，向它的倍数连边权为它的边，假设这个点和它连向的点已经联通了，那就不要连了，因为这两点之间的最小边一定不小于当前你连的这条边。 所以这道题在明白倍数关系后就是一个最大生成树+HPD维护两点间最小边，这个最小边由于最大生成树的性质一定最大，本题做完了。 代码有问题，先上下以供参考 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define INF 100000005#define maxn 100005#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)int n , q , x , y , m , head[maxn] , cnt , tot , uf[maxn] , val[maxn] , ref[maxn*20];struct edge&#123; int next , to , dis;&#125;e[maxn*10];struct HPD&#123; #define pushup(x) maxx[x] = std::max(maxx[ls(x)] , maxx[rs(x)]) int id[maxn] , sz[maxn] , top[maxn] , dep[maxn] , hs[maxn] , maxx[maxn&lt;&lt;2] , f[maxn] , v[maxn] , idx; void dfs1(int x , int fx) &#123; f[x] = fx; sz[x] = 1; dep[x] = dep[fx] + 1; for(int i = head[x] ; i ; i = e[i].next)&#123; if(e[i].to != fx)&#123; dfs1(e[i].to , x); sz[x] += sz[e[i].to]; if(sz[hs[x]] &lt; sz[e[i].to]) hs[x] = e[i].to; &#125; &#125; &#125; void dfs2(int x , int topv) &#123; top[x] = topv; id[x] = ++idx; v[id[x]] = val[x]; if(!hs[x]) return ; dfs2(hs[x] , topv); for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == f[x] || v == hs[x]) continue; dfs2(v , v); &#125; &#125; void build(int l , int r , int node) &#123; if(l == r)&#123; maxx[node] = v[l]; return ; &#125; int mid = l + r &gt;&gt; 1; build(l , mid , ls(node)); build(mid + 1 , r , rs(node)); pushup(node); &#125; int query(int L , int R , int l , int r , int node) &#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; return maxx[node]; &#125; int mid = l + r &gt;&gt; 1 , ans = -INF; if(L &lt;= mid) ans = std::max(ans , query(L , R , l , mid , ls(node))); if(R &gt; mid) ans = std::max(ans , query(L , R , mid + 1, r , rs(node))); return ans; &#125; int queryMax(int x , int y) &#123; int ans = -INF; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); ans = std::max(ans , query(id[top[x]] , id[x] , 1 , n , 1)); x = f[top[x]]; &#125; if(dep[x] &lt; dep[y]) std::swap(x,y); ans = std::max(ans , query(id[y] , id[x] , 1 , n , 1)); return ans; &#125;&#125;tr;inline void add(int x , int y , int d)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;int find(int x)&#123; if(uf[x] != x) return uf[x] = find(uf[x]); return uf[x];&#125;void dfs(int x , int fx , int d)&#123; val[x] = d; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx) continue; dfs(v , x , e[i].dis); &#125;&#125;int main()&#123;// freopen("Pictionary.in","r",stdin);// freopen("Pictionary.out","w",stdout); scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i = 1 ; i &lt;= n ; ++i) uf[i] = i; for(int i = m ; i ; --i) for(int j = 2 * i ; j &lt;= n ; j += i) if(find(i) != find(j))&#123; uf[find(i)] = find(j) , add(i , j , i) , add(j , i , i); &#125; dfs(1,1,0); tr.dfs1(1,1); tr.dfs2(1,1); tr.build(1,n,1); for(int i = 1 ; i &lt;= q ; ++i)&#123; int x , y; scanf("%d%d",&amp;x,&amp;y); printf("%d\n", m - tr.queryMax(x,y) + 1); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef->NO.11]]></title>
    <url>%2F2018%2F11%2F17%2FNO.11%2F</url>
    <content type="text"><![CDATA[NOWCODER TG4 B 区间题目描述 给出一个序列 a1, …, an。 定义一个区间 [l,r] 是好的，当且仅当这个区间中存在一个 i，使得 ai 恰好等于 al, al+1, …, ar-1, ar 的最大公因数。 求最长的好的区间的长度。 输入描述:123第一行 n，表示序列的长度；第二行 n 个数 a1,a2,...,an。 输出描述:1输出一行一个数，表示最长的好的区间的长度。 示例1 输入复制 1254 6 9 3 6 输出复制 14 说明1选择区间 [2,5]，i=4。 备注:1234567891011对于测试点 1、2，n≤ 100；对于测试点 3、4，n≤ 2,000；对于测试点 5、6，n ≤ 200,000, ai≤ 100，且数据随机；对于测试点 7、8、9，n ≤ 200,000；对于测试点 10，没有特殊限制。对于所有数据，n≤ 4x 10^6, 1≤ ai≤ 1018。 题解这道题难度还行，大概TG D1T2难度？ 我们考虑题目所要求的那个区间，这个区间的最大公约数必定等于这个区间的最小值，并且其他数都是这个最小值的整数倍。我们对每个值找出它左边整数倍的最远点，右边也是。问题就解决了。 Code : 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ll long long#define maxn 4000005ll Ar[maxn] , n , ans , l[maxn] , r[maxn];int main()&#123; scanf("%lld",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;Ar[i]); l[1] = 1 , r[n] = n; for(int i = 2 ; i &lt;= n ; ++i) &#123; int cur = i - 1; while(cur &gt;= 1 &amp;&amp; Ar[cur] % Ar[i] == 0) cur = l[cur] - 1; l[i] = cur + 1; &#125; for(int i = n - 1 ; i &gt;= 1 ; --i) &#123; int cur = i + 1; while(cur &lt;= n &amp;&amp; Ar[cur] % Ar[i] == 0) cur = r[cur] + 1; r[i] = cur - 1; &#125; for(int i = 1 ; i &lt;= n ; ++i) ans = std::max(ans , r[i] - l[i] + 1); printf("%lld",ans);&#125; Luogu P4917 天守阁的地板题目描述为了使万宝槌能发挥出全部魔力,小碗会将买来的地板铺满一个任意边长的正方形(地板有图案,因此不允许旋转,当然,地板不允许重叠)来达到最大共鸣 现在,她能够买到规格为a*ba∗b的地板,为了省钱,她会购买尽可能数量少的地板 现在,她想知道对于每一对a,b(1≤a,b≤n)a,b(1≤a,b≤n),她最少需要购买的地板数量 由于输出可能很大,所以你只需要输出所有答案的乘积即可,为了避免高精度,小碗很良心的让你将答案对19260817取模 输入输出格式输入格式： 第一行一个整数T,表示数据组数下面T行,每行一个整数n 输出格式： 共TT行,每行一个整数,表示取模后的答案 输入输出样例输入样例#1： 123454123100 输出样例#1： 123414129618996121 题解这真是一道好题。 简述题意，对于任意小于n的x*y矩形，将它密铺成正方形所用的最小数量为v，求所有v的和。 显然变成一个正方形，边长得相等，设最小q个在x的方向，t个在y的方向，所用个数为t * q \frac{x}{y} = \frac{t}{q}显然当x,y约分至互质的情况时t * q最小 因此我们所求的就是 \prod_{i=1}^{n}\prod_{j=1}^{n}\frac{ij}{gcd(i,j)^2}由题目数据可知，我们要么On求出1~n的所有答案O1查询，要么对于每次查询是一个线性复杂度以下的算法。 首先看分子的处理 \prod_{i=1}^{n}\prod_{j=1}^{n}ij \prod_{i=1}^{n}i(\prod_{j=1}^{n}j)这就是 (n!)^{2}那么我们该考虑分母的积该如何算了 , 算出来后乘上逆元即可。 \prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j)^2我们可以最后平方 (\prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j))^2我们可以用常用的数论技巧来优化 \prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j) \prod_{k=1}^{n}k^{\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==k]}对于 \sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==k] \sum_{i=1}^{n/k}\sum_{j=1}^{n/k}[gcd(i,j)==1]这就是 2\sum_{i=1}^{n/k}\varphi(i)-1因此每次询问的答案的分母就是 \prod_{k=1}^{n}k^{2\sum\limits_{i=1}^{n/k}\varphi(i)-1}最后的答案是 \frac{(n!)^{2}}{(\prod_{k=1}^{n}k^{2\sum\limits_{i=1}^{n/k}\varphi(i)-1})^2}显然欧拉函数作为积性函数可以线性筛，并且只需要一次即可，然后从指数幂的特点来看再用前缀和来优化欧拉函数求和，这样复杂度是 O(n+Tnlogn)这样做期望得分60 我们可以对分子的k做一个简单的根号优化 有一个著名的结论，对于 (n/d)的取值不超过 2\sqrt{n}个，这个就不证明了挺麻烦的，进阶指南上有。 那么我们可以对于k的指数幂一样的项一起处理，这样时间复杂度就是 O(n+2T\sqrt{n}logn)Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define mod 19260817#define ll long long#define maxn 1000005ll n , T , phi[maxn] , prime[maxn/8] , fac[maxn] , cnt;bool inprime[maxn];inline void euler(ll n)&#123; phi[1] = 1; for(ll i = 2 ; i &lt;= n ; ++i) &#123; if(!inprime[i]) phi[i] = i - 1 , prime[++cnt] = i; for(int j = 1 ; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n ; ++j) &#123; inprime[i*prime[j]] = true; if(!(i%prime[j])) phi[i*prime[j]] = prime[j] * phi[i]; else phi[i*prime[j]] = phi[i] * phi[prime[j]]; if(!(i%prime[j])) break; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) phi[i] += phi[i-1] ;&#125;ll exgcd(ll a , ll b , ll&amp; x , ll&amp; y)&#123; if(!b) &#123; x = 1 , y = 0; return a; &#125; ll g = exgcd(b , a % b , y , x); y -= a/b * x; return g;&#125;ll inv(ll k)&#123; if(!k || k == 1) return 1; ll x , y; ll g = exgcd(k,mod,x,y); x = (x % mod + mod) % mod; return x;&#125;inline void pre(ll n)&#123; fac[0] = fac[1] = 1; for(int i = 2 ; i &lt;= n ; ++i) fac[i] = fac[i-1] * i % mod;&#125;inline ll pow(ll x , ll y)&#123; ll ans = 1 , base = x; while(y) &#123; if(y&amp;1) ans = ans * base % mod; base = base % mod * base % mod; y /= 2; &#125; return ans;&#125;void solve(ll n)&#123; ll ans = pow(fac[n] , 2 * n); ll frac = 1; ll gx = 0; for(int i = 1 ; i &lt;= n ; i = gx + 1) &#123; gx = n/(n/i); // puts("OK"); ll pw = 2 * phi[n/i] - 1; ll base = (fac[gx] % mod * inv(fac[i-1])) % mod ; frac = frac * pow(base , pw) % mod; &#125; printf("%lld\n",ans * inv(frac) % mod * inv(frac) % mod);&#125;int main()&#123; scanf("%lld",&amp;T); euler(1000000); pre(1000000);//the fac while(T--) &#123; scanf("%lld",&amp;n); solve(n); &#125;&#125; 三元上升子序列题目描述Erwin最近对一种叫”thair”的东西巨感兴趣。。。 在含有n个整数的序列a1,a2……an中， 三个数被称作”thair”当且仅当i&lt;j&lt;k且ai&lt;aj&lt;ak 求一个序列中”thair”的个数。 输入输出格式输入格式： 开始一个正整数n, 以后n个数a1~an。 输出格式： “thair”的个数 输入输出样例输入样例#1： 1242 1 3 4 输出样例#1： 12 输入样例#2： 1251 2 2 3 4 输出样例#2： 17 说明对样例2的说明: 7个”thair”分别是 1 2 3 1 2 4 1 2 3 1 2 4 1 3 4 2 3 4 2 3 4 约定 30%的数据n&lt;=100 60%的数据n&lt;=2000 100%的数据n&lt;=30000 大数据随机生成 0&lt;=a[i]&lt;=maxlongint 题解显然枚举中间元素，记录左边比他小的和右边比他大的数量。 Ans = \sum_{i=1}^{n} L(i) * R(i)树状数组轻松 nlognCode: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 30005#define ll long longll n , tot , p[maxn] , ans , BIT[maxn] , l[maxn] , r[maxn];struct Node&#123; ll v , k;&#125;Ar[maxn] ;inline bool cmp(Node x , Node y)&#123;return x.v &lt; y.v;&#125;ll C(ll n , ll k)&#123; if(k &gt; n) return 0; ll ans = 1; for(int i = n - k + 1 ; i &lt;= n ; ++i) ans *= i; for(int i = 1 ; i &lt;= k ; ++i) ans /= i; return ans;&#125;inline ll lowbit(ll x)&#123; return x &amp; -x;&#125;inline void update(ll x , ll v)&#123; if(!x) return; for(ll i = x ; i &lt;= n ; i += lowbit(i)) BIT[i] += v;&#125;inline ll query(ll x)&#123; ll ans = 0; for(int i = x ; i ; i -= lowbit(i)) ans += BIT[i]; return ans;&#125;int main()&#123; scanf("%lld",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;Ar[i].v) , Ar[i].k = i; std::sort(Ar+1,Ar+n+1,cmp); for(int i = 1 ; i &lt;= n ; ++i) if(Ar[i].v == Ar[i-1].v) p[Ar[i].k] = tot; else p[Ar[i].k] = ++tot; for(int i = 1 ; i &lt;= n ; ++i) &#123; int k = query(p[i] - 1); l[i] = k; update(p[i] , 1); &#125; // for(int i = 1 ; i &lt;= n ; ++i) // printf("l[%d] = %lld\n",i,l[i]); std::memset(BIT,0,sizeof(BIT)); for(int i = n ; i &gt;= 1 ; --i) &#123; int k = n - i - query(p[i]); r[i] = k; update(p[i] , 1); &#125; // for(int i = 1 ; i &lt;= n ; ++i) // printf("r[%d] = %lld\n",i,r[i]); for(int i = 1 ; i &lt;= n ; ++i) ans += l[i] * r[i]; printf("%lld",ans);&#125; T3 Marisa采蘑菇题目背景Marisa是一个爱魔法的女孩子,而火力高而华丽的八卦炉正是她常用的武器,然而,随着时代的进步,Marisa想要升级八卦炉的火力,所以她决定去魔法森林采蘑菇来获得做实验的材料 题目描述Marisa来到了森林之中,看到了一排nn个五颜六色的蘑菇,编号从1-n1−n,这些蘑菇的颜色分别为col[1],col[2]…col[n]col[1],col[2]…col[n]由于她很挑剔,所以她只会采那些”魔法蘑菇” 一个蘑菇被叫做”魔法蘑菇”,当且仅当它在给定的某段区间内,并且在这段给定区间内与它颜色相同的蘑菇(包括它本身)的个数 与在这个给定区间外这种颜色的蘑菇的个数之差小于等于常数kk 现在Marisa会做出mm个询问,每次询问你[l,r][l,r]中有多少种不同颜色的”魔法蘑菇” 输入输出格式输入格式： 第一行三个整数n,m,kn,m,k第二行nn个正整数,表示蘑菇的颜色col[i]col[i]之后mm行,每行两个正整数l,rl,r,表示Marisa询问的区间的左端点和右端点,数据保证0&lt;l≤r≤n0&lt;l≤r≤n 输出格式： 共mm行,每行一个整数xx,表示询问区间中不同颜色的”魔法蘑菇”的数量 输入输出样例输入样例#1： 123456 3 22 3 2 4 1 21 22 41 6 输出样例#1： 123233 说明样例说明:对于区间[1,2][1,2]:col[1]=2col[1]=2,22这种颜色的蘑菇在区间[1,2][1,2]内出现了11次,在区间外出现了22次,相差为abs(1-2)=1&lt;2abs(1−2)=1&lt;2col[2]=3col[2]=3,33这种颜色的蘑菇在区间[1,2][1,2]内出现了11次,在区间外出现了00次,相差为abs(1-0)=1&lt;2abs(1−0)=1&lt;2所以[1,2][1,2]中有两个颜色不同的魔法蘑菇 数据范围: 注一:本题有三个subtasksubtask,分别为第1-41−4测试点(2020分),第5-105−10测试点(3030分),第1111测试点(5050分) 注二:由于数据可能很大,建议使用读入优化 注三:图片中的a[i]即为col[i] 题解这道题难度评级要是NOIp D2T3那我NOIp一定不写那题。 这的确是我做过的所有题里统计最巧妙（不可做）的一道题 这个题听成爷说可以莫队打爆力，那看来还是学学数据结构比较好。 首先可以求出每个数(颜色)的出现次数tot[i]tot[i],那么对每个数,如果它在这个区间内出现次数和在区间外的出现次数之差小于等于kk,那么我们可以解出这个数在区间内出现次数的范围为 [\lceil \frac{tot[i]-k}{2} \rceil,\lfloor \frac{tot[i]+k}{2} \rfloor]所以将询问排序,当左端点右移的时候在相应的位置加上−1,1就可以了 写的时候注意细节问题 一部分一部分的说 123456789for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;a[i]); if(!p[a[i]].size())up[i]=1; p[a[i]].push_back(i); next[pre[a[i]]]=i; tim[i]=tim[pre[a[i]]]+1; pre[a[i]]=i;&#125; 这是预处理出每个颜色的点，每个点的同颜色前驱，同颜色后驱，同颜色计数数量以及每个颜色第一个出现的点。 1234567for(int i=1;i&lt;=n;++i)&#123; if(!up[i])continue;//only once siz[a[i]]=p[a[i]].size(); if(siz[a[i]]&lt;=k)update(i,1); else update(p[a[i]][(siz[a[i]]-k-1)/2],1),update(p[a[i]][(siz[a[i]]+k)/2],-1);&#125; 这就是对于每个颜色的起点，我们把颜色的合法区间+1，表示这个颜色可行。 1234567891011121314151617181920212223242526int L=1;for(int i=1;i&lt;=m;++i)&#123; if(q[i].l==L)q[i].ans=query(q[i].r); else &#123; while(L&lt;q[i].l) &#123; if(siz[a[L]]&lt;=k) &#123; update(L,-1); if(next[L])update(next[L],1); L++; continue; &#125; if(tim[L]-1+(siz[a[L]]-k-1)/2&lt;siz[a[L]])update(p[a[L]][tim[L]-1+(siz[a[L]]-k-1)/2],-1); if(tim[L]-1+(siz[a[L]]+k)/2&lt;siz[a[L]])update(p[a[L]][tim[L]-1+(siz[a[L]]+k)/2],1); if(tim[L]+(siz[a[L]]-k-1)/2&lt;siz[a[L]]) update(p[a[L]][tim[L]+(siz[a[L]]-k-1)/2],1); if(tim[L]+(siz[a[L]]+k)/2&lt;siz[a[L]]) update(p[a[L]][tim[L]+(siz[a[L]]+k)/2],-1); L++; &#125; q[i].ans=query(q[i].r); &#125;&#125; 按照左端点排序以后，我们可以将左端点以前的点的影响都去掉，也就是说让同颜色的点的下一个来构成这个合法区间，4条更新只是细节。 这时候我们相当于对于每个颜色我们都把可行区间在树状数组找了出来，然后对区间左端点排序以后，我们就可以去掉每个区间左端点之前的对答案的贡献。 这样，我们只对每个点做过8次更新，时间复杂度 O(nlogn)就可以通过本题。]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.30]]></title>
    <url>%2F2018%2F11%2F17%2Fno-30%2F</url>
    <content type="text"><![CDATA[P1182 数列分段Section II题目描述对于给定的一个长度为N的正整数数列A-iA−i，现要将其分成M(M≤N)M(M≤N)段，并要求每段连续，且每段和的最大值最小。 关于最大值最小： 例如一数列4 2 4 5 142451要分成33段 将其如下分段： [4 2][4 5][1][42][45][1] 第一段和为66，第22段和为99，第33段和为11，和最大值为99。 将其如下分段： [4][2 4][5 1][4][24][51] 第一段和为44，第22段和为66，第33段和为66，和最大值为66。 并且无论如何分段，最大值不会小于66。 所以可以得到要将数列4 2 4 5 142451要分成33段，每段和的最大值最小为66。 输入输出格式输入格式： 第11行包含两个正整数N，M。 第22行包含NN个空格隔开的非负整数A_iAi，含义如题目所述。 输出格式： 一个正整数，即每段和最大值最小为多少。 输入输出样例输入样例#1： 125 34 2 4 5 1 输出样例#1： 16 说明对于20\%20%的数据，有N≤10N≤10； 对于40\%40%的数据，有N≤1000N≤1000； 对于100\%100%的数据，有N≤100000,M≤N, A_iN≤100000,M≤N,Ai之和不超过10^9。 题解二分答案+贪心 这道题由于满足答案可行性单调，可以进行二分答案。 对于二分的答案判断可以用贪心策略：每个数尽量加到一段里，不够了在用一段新的。 正确性：每一个数总要被分进一组，没组权重相等，与其多开一个，还不如尽量放入以前的对吧。 Code： 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define maxRange 2000000000int A[maxn] , n , ans , m;bool check(int cur)&#123; int now = 0 , cnt = 1 , ans = 0; for(int i = 1 ; i &lt;= n; ++i)&#123; if(now + A[i] &lt;= cur) now += A[i]; else if(A[i] &gt; cur) return false; else ++cnt , now = 0 , now += A[i]; if(cnt &gt; m) return false; &#125; return true;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;A[i]); int l = 0 , r = maxRange; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(check(mid)) ans = mid , r = mid - 1; else l = mid + 1; &#125; printf("%d",ans); &#125; [ZJOI2008]生日聚会题目描述今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。 hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件： 对于任意连续的一段，男孩与女孩的数目之差不超过k。 很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题…… 假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。 输入输出格式输入格式： 输入文件party.in仅包含一行共3个整数，分别为男孩数目n, 女孩数目m, 常数k。 输出格式： 输出文件party.out应包含一行，为题中要求的答案。 输入输出样例输入样例#1： 11 2 1 输出样例#1： 11 说明对于30%的数据，n , m ≤ 20； 对于100%的数据, n , m ≤ 150，k ≤ 20。 题解似乎没想到状态。。。其实状态还是听套路的。 由于我们要时刻知道当前状态代表的方案数中最大的差是多少，假如我们只设一维表示男生女生的差最大是多少，不一定女生和男生的差也最大。所以我们就再加一维变成四维状态。 f(i,j,k,p)表示前i个男生，j个女生，男女最大差为k，女男最大差为p 就很好转移了。 Code： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;map&gt;#define maxn 155#define maxk 25#define mod 12345678#define max(a,b) (a) &gt; (b) ? (a) : (b)int f[maxn][maxn][maxk][maxk] , n , m , k;std::map&lt;int,int&gt; dp[maxn][maxn];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); f[0][0][0][0] = 1; for(int i = 0 ; i &lt;= n ; ++i) for(int j = 0 ; j &lt;= m ; ++j) for(int t = 0 ; t &lt;= k ; ++t) for(int p = 0 ; p &lt;= k ; ++p)&#123; (f[i+1][j][t+1][max(p-1,0)] += f[i][j][t][p]) %= mod; (f[i][j+1][max(t-1,0)][p+1] += f[i][j][t][p]) %= mod; &#125; int ans = 0; for(int i = 0 ; i &lt;= k ; ++i) for(int j = 0 ; j &lt;= k ; ++j) (ans += f[n][m][i][j]) %= mod; printf("%d",ans);&#125; [POI2012]HUR-Warehouse Store题目描述n天。第i天上午会进货Ai件商品，中午的时候会有顾客需要购买Bi件商品，可以选择满足顾客的要求，或是无视掉他。 如果要满足顾客的需求，就必须要有足够的库存。问最多能够满足多少个顾客的需求。 输入输出格式输入格式： 第一行包含一个整数n，表示有n天。 第二行有n个整数ai，表示第i天上午进货a件商品。 第三行包含n个整数bi，表示在第i天中午有顾客来买b件商品。 输出格式： 第一行一个整数，表示最多能满足几天中顾客的需求。 第二行输出满足这么哪些天顾客的需求。 输入输出样例输入样例#1： 12362 2 1 2 1 01 2 2 3 4 4 输出样例#1： 1231 2 4 说明对于100%的数据， 1\leqslant n\leqslant 250000,0\leqslant a_i,b_i \leqslant 10^91⩽n⩽250000,0⩽ai,bi⩽109题解又一次想出贪心题233. 这个题是一个堆贪心。 最本质的是每个人权值均相同，所以后面的人需求小于前面的人且货不够的时候，我们优先满足他，这样使得存货最大化对后面一定不会更劣，满足了贪心的无后效性。而当前能满足则尽量满足，假设满足他不是一个最优全局决策而只是当前最优，这种策略也能保证后面出现可以更优情况时调整到最优。Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define maxn 250005#define mp(x,y) std::make_pair((x),(y))#define pii std::pair&lt;int,int&gt;std::priority_queue&lt;pii&gt; q;int n , p[maxn] , r[maxn] , ans;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;r[i]); long long sum = 0; for(int i = 1 ; i &lt;= n ; ++i)&#123; sum += p[i]; if(q.empty())&#123; if(sum &lt; r[i]) continue; else if(sum &gt;= r[i])&#123; sum -= r[i]; ++ ans; q.push(mp(r[i],i)); continue; &#125; &#125; else&#123; int k = q.top().first; if(k &gt; r[i] &amp;&amp; r[i] &gt; sum)&#123; q.pop(); sum += k; sum -= r[i]; q.push(mp(r[i],i)); &#125; else if(r[i] &lt;= sum)&#123; ++ans; sum -= r[i]; q.push(mp(r[i],i)); &#125; &#125; &#125; printf("%d",ans); putchar(10); while(!q.empty()) &#123; printf("%d ",q.top().second); q.pop(); &#125;&#125; BFS剩余类解决这样一个问题： \sum_{i=1}^{n}A_ix_i = k给定k的范围，请问有多少组非负整数解？ 大概是一种建图思想，就是把余数分类建点，然后用最短路求解，重点是这种做法的原理。 假设我们取A中一个（一般取最小，原因后面说）记为 A_1假设我们找到一个k，k在模 A_1意义下和余数r同余，使得 \sum_{i=1}^{n}A_ix_i = k k = t * A_1 + r k' = (t+1)*A_1 + r同样成立。 我们要做的就是求出那个t，即可根据余数快速统计。我们可以试着枚举那个k，每次试着加上 A_i这么做恭喜你前面白分析了。 我们考虑最短路模型，将 k ->(k+A_i)\%A_1建长度为 A_i的有向边，即可将代价最小转换成最短路。 想了半天，确实是道好题。 [国家集训队]墨墨的等式题目描述墨墨突然对等式很感兴趣，他正在研究 a_1x_1+a_2x_2+…+a_nx_n=B存在非负整数解的条件，他要求你编写一个程序，给定N、{an}、以及B的取值范围，求出有多少B可以使等式存在非负整数解。 输入输出格式输入格式： 输入的第一行包含3个正整数，分别表示N、 B_{min}、 B_{Max}分别表示数列的长度、B的下界、B的上界。 输入的第二行包含N个整数，即数列 {a_n}的值。 输出格式： 输出一个整数，表示有多少b可以使等式存在非负整数解。 输入输出样例输入样例： 122 5 103 5 输出样例#1： 15 说明对于100%的数据， N \le 12，0 \le a_i \le 5*10^5，1 \le B_{Min} \le B_{Max} \le 10^{12}题解分析如上，用上述方法的时间复杂度不是很好计算（有向边数量并不确定），但是对于题目要求没有问题。 L，R变量的意义相当于在枚举的余数下 k = t * A_1 + r其给定的t为多少。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include&lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 500005#define mp(x,y) std::make_pair((x),(y))#define pii std::pair&lt;LL,int&gt; #define LL long longconst LL INF = 9187201950435737471;int n , p[maxn];LL bmin , bmax , d[maxn] , ans;bool vis[maxn];inline void SPDIJ(int s)&#123; std::priority_queue&lt;pii , std::vector&lt;pii&gt; , std::greater&lt;pii&gt; &gt; q; std::memset(d,0x7f,sizeof(d)); std::memset(vis,false,sizeof(vis)); d[s] = 0; // s = 0 q.push(mp(d[s],s)); while(!q.empty()) &#123; int k = q.top().second; q.pop(); if(vis[k]) continue; vis[k] = true; for(int i = 2 ; i &lt;= n ; ++i)&#123; int v = (k + p[i]) % p[1]; if(d[k] + p[i] &lt; d[v])&#123; d[v] = d[k] + p[i]; q.push(mp(d[v],v)); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%lld%lld",&amp;n,&amp;bmin,&amp;bmax); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); std::sort(p+1,p+n+1); SPDIJ(0); for(int i = 0 ; i &lt; p[1] ; ++i)&#123; if(d[i] != INF)&#123; d[i] -= i , d[i] /= p[1]; LL L = (bmin - i - 1) / p[1] , R = (bmax - i) / p[1] ; // caution : [L,R] LL totL = L - d[i] + 1 , totR = R - d[i] + 1; //do not remember itself totL = std::max(1LL*0,totL) , totR = std::max(1LL*0 , totR); ans += totR - totL; &#125; &#125; printf("%lld",ans);&#125; [USACO12MAR]园林绿化Landscaping题目描述Farmer John is building a nicely-landscaped garden, and needs to move a large amount of dirt in the process. The garden consists of a sequence of N flowerbeds (1 &lt;= N &lt;= 100), where flowerbed i initially contains A_i units of dirt. Farmer John would like to re-landscape the garden so that each flowerbed i instead contains B_i units of dirt. The A_i’s and B_i’s are all integers in the range 0..10. To landscape the garden, Farmer John has several options: he can purchase one unit of dirt and place it in a flowerbed of his choice for XX. He can remove one unit of dirt from a flowerbed of his choice and have it shipped away for YY. He can also transport one unit of dirt from flowerbed i to flowerbed j at a cost of ZZtimes |i-j|. Please compute the minimum total cost for Farmer John to complete his landscaping project. 有n块土地，每块有A[i]泥土，现把其改造成B[i]泥土，有3种操作：(1)花费X向任意土地增加1泥土；(2)花费Y向任意土地减少1泥土；(3)花费Z*|i-j|把土地i的1泥土运到土地j。问最小花费是多少。 输入输出格式输入格式： * Line 1: Space-separated integers N, X, Y, and Z (0 &lt;= X, Y, Z &lt;= 1000). * Lines 2..1+N: Line i+1 contains the space-separated integers A_i and B_i. 输出格式： * Line 1: A single integer giving the minimum cost for Farmer John’s landscaping project. 输入输出样例输入样例#1： 123454 100 200 1 1 4 2 3 3 2 4 0 输出样例#1： 1210 说明There are 4 flowerbeds in a row, initially with 1, 2, 3, and 4 units of dirt. Farmer John wishes to transform them so they have 4, 3, 2, and 0 units of dirt, respectively. The costs for adding, removing, and transporting dirt are 100, 200, and 1. One unit of dirt must be removed (from flowerbed #4), at a cost of 200. The remaining dirt can be moved at a cost of 10 (3 units from flowerbed #4 to flowerbed #1, 1 unit from flowerbed #3 to flowerbed #2). 题解这是一道好神的贪心啊。（dp好像也能做），D1T2难度偏上，有概率D1T3。 看到那个10其实应该想到拆成一件一件的，然而还是没有想到。 之后的堆贪心倒不是非常的难，只不过想出前缀和的形式压进堆然后取出来和当前元素做差还是有些难度。 我们来分析一波。 假设当前是土少了，要加上或从别的地方运。 从别的地方运上一份土，我们应该运一份最优的（显然由于运输费用给定都相同，且前后路长差与代价线性）。 假设没有，我们只能买一份。 这就是这道题的大致思路。它为什么正确呢？ 考虑到当前我们没有选择最优的决策，后面选择的决策并不会因此更优，没了，不会严格证明 显然的无后效性和最优子结构 由于每份土地不能重复用（当然你可以动态调整不断地运，注意费用即可），因此用堆维护。 用堆维护什么值呢？ dis * z + x为什么是这个奇奇怪怪的东西呢？主要是考虑一种标准，使得取出的元素能快速和当前元素合并价值。 显然从前面取土是 (dis_x - dis_{now}) * z - x这样上面维护的那个元素形式就不是很难理解了吧（虽然有点难想？） 还有一点就是，假设我们拿了一块土地，并不意味着这块土地一定最优了，因此要把它的代价压进另一个堆使得后面可能会调用。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define maxn 100005int n , x , y , z , ans;std::priority_queue&lt;int&gt; q1 , q2;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;x,&amp;y,&amp;z); int fr , to; for(int k = 1 ; k &lt;= n ; ++k)&#123; scanf("%d%d",&amp;fr,&amp;to); if(fr &lt; to)&#123; for(int i = 1 ; i &lt;= to - fr ; ++i)&#123; if(q1.empty() || k * z - q1.top() &gt; x)&#123; ans += x; q2.push(k * z + x); &#125; else&#123; int g = q1.top(); ans += k * z - g; q1.pop(); q2.push(k * z + k * z - g); &#125; &#125; &#125; else &#123; for(int i = 1 ; i &lt;= fr - to ; ++i)&#123; if(q2.empty() || k * z - q2.top() &gt; y)&#123; ans += y; q1.push(k * z + y); &#125; else &#123; int g = q2.top(); ans += k * z - g; q2.pop(); q1.push(k * z + k * z - g); &#125; &#125; &#125; &#125; printf("%d",ans);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.31]]></title>
    <url>%2F2018%2F11%2F17%2Fno-31%2F</url>
    <content type="text"><![CDATA[[HAOI2015]树上染色题目描述有一棵点数为 N 的树，树边有边权。给你一个在 0~ N 之内的正整数 K ，你要在这棵树中选择 K个点，将其染成黑色，并将其他 的N-K个点染成白色 。 将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的受益。问受益最大值是多少。 输入输出格式输入格式： 第一行包含两个整数 N, K 。接下来 N-1 行每行三个正整数 fr, to, dis ， 表示该树中存在一条长度为 dis 的边 (fr, to) 。输入保证所有点之间是联通的。 输出格式： 输出一个正整数，表示收益的最大值。 输入输出样例输入样例#1： 1233 11 2 11 3 2 输出样例#1： 13 说明对于 100% 的数据， 0&lt;=K&lt;=N &lt;=2000 题解被wzx大佬毁了的一道好题。D2T2难度。 这里如果我们设 f(u,k)表示子树u内选k个点最优的价值是不可能转移的，因为它完全不存在无后效性。 因此这个题难就难在能看出每条边能被分别统计答案。 倒也不是很难想，因为可以考虑到子树内每个黑点和子树外经过的边以及白边，这个是可以树上背包解决的。 我们让 f(u,k)表示子树u内选k个点对答案的贡献。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 2005#define LL long longLL f[maxn][maxn] , n , k , head[maxn] , cnt , sz[maxn];struct edge&#123; LL next , to , dis;&#125;e[maxn*2];inline void add(LL x , LL y , LL dis)&#123; e[++cnt].next = head[x] ; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;void dfs(LL x , LL fx , LL dis)&#123; f[x][0] = f[x][1] = 0; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next)&#123; if(e[i].to == fx) continue; dfs(e[i].to , x , e[i].dis); sz[x] += sz[e[i].to]; for(int j = std::min(sz[x] , k) ; j &gt;= 0 ; --j) for(int t = 0 ; t &lt;= j &amp;&amp; t &lt;= sz[e[i].to] ; ++t)&#123; LL val = t * (k - t) * e[i].dis + (sz[e[i].to] - t) * (n - k - sz[e[i].to] + t) * e[i].dis; f[x][j] = std::max(f[x][j] , f[x][j-t] + f[e[i].to][t] + val); &#125; &#125;&#125;int main()&#123; std::memset(f,-0x3f,sizeof(f)); scanf("%lld%lld",&amp;n,&amp;k); LL x ,y , z; for(int i = 1 ; i &lt;= n-1 ; ++i) scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z) , add(x,y,z) , add(y,x,z); dfs(1,1,0); printf("%lld\n",f[1][k]);&#125; [ZJOI2012]灾难题目描述阿米巴是小强的好朋友。 阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。 学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。 我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系： 一个食物网有N个点，代表N种生物，如果生物x可以吃生物y，那么从y向x连一个有向边。 这个图没有环。 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存； 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。 我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。 举个例子：在一个草场上，生物之间的关系是： 如 如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是1。但是，如果草突然灭绝，那么整个草原上的5种生物都无法幸免，所以，草的灾难值是4。 给定一个食物网，你要求出每个生物的灾难值。 输入输出格式输入格式： 输入文件 catas.in 的第一行是一个正整数 N，表示生物的种数。生物从 1 标 号到 N。 接下来 N 行，每行描述了一个生物可以吃的其他生物的列表，格式为用空 格隔开的若干个数字，每个数字表示一种生物的标号，最后一个数字是 0 表示列 表的结束。 输出格式： 输出文件catas.out包含N行，每行一个整数，表示每个生物的灾难值。 输入输出样例输入样例#1： 123456501 01 02 3 02 0 输出样例#1： 1234541000 说明【样例说明】 样例输入描述了题目描述中举的例子。 【数据规模】 对50%的数据，N ≤ 10000。 对100%的数据，1 ≤ N ≤ 65534。 输入文件的大小不超过1M。保证输入的食物网没有环。 题解又是wzx大佬推荐的题，还是挺不错的一道题。放在D1T3挺不错。 这题主要是构造+贪心 考虑一个动物什么时候会被灭绝，可以反图拓扑。时间复杂度不够优秀。 因此我们（打开标签看到倍增）构造一棵树，树的性质是子节点有唯一的父节点，让直接导致灭绝关系的连在一起。在纸上使劲画图 发现是所有食物的LCA。 思路很明确了：拓扑 + 构造树 + 倍增优化LCA 然而我！必！须！得！说！，我倍增某处写错了导致交了10多遍，不然就一次AC了！！ 以后当程序出错了，还是要关注每一个细节，而不是只关注主要部分。 倍增好久不写居然真的出错了。。 讲真我要是NOIp想出这种难度题的正解然后写疵了我大概会气死 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define maxn 100005int f[maxn][19] , n , x , y , head[maxn] , lg[maxn] , dep[maxn] , sz[maxn] , cnt , d[maxn];struct edge&#123; int next , to;&#125;e[maxn*20];int LCA(int x , int y)&#123; if(dep[x] &lt; dep[y]) std::swap(x,y); while(dep[x] &gt; dep[y] &amp;&amp; f[x][lg[dep[x]-dep[y]]-1] != -1) x = f[x][lg[dep[x]-dep[y]]-1]; if(x == y) return x; for(int i = lg[dep[x]] ; i &gt;= 0 ; --i) if(f[x][i] != f[y][i]) x = f[x][i] , y = f[y][i]; return f[x][0];&#125;void dfs(int x , int fx)&#123; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs(e[i].to , x) , sz[x] += sz[e[i].to];&#125;void add(int x , int y)&#123; e[++cnt].next = head[x] ; e[cnt].to = y; head[x] = cnt; ++d[y];&#125;inline void Toposort()&#123; std::queue&lt;int&gt; q; for(int i = 0 ; i &lt;= n ; ++i) if(!d[i]) q.push(i); while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = head[k] ; i ; i = e[i].next)&#123; int v = e[i].to; if(f[v][0] == -1)&#123; f[v][0] = k; &#125; else&#123; f[v][0] = LCA(f[v][0] , k); &#125; --d[v]; if(!d[v])&#123; dep[v] = dep[f[v][0]] + 1; for(int j = 1 ; j &lt;= 18 ; ++j) if(f[v][j-1] != -1) f[v][j] = f[f[v][j-1]][j-1]; q.push(v); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); std::memset(f,-1,sizeof(f)); for(int i = 1 ; i &lt;= n ; ++i) lg[i] = lg[i-1] + (1&lt;&lt;lg[i-1]==i); for(int i = 1 ; i &lt;= n ; ++i)&#123; int x; while(scanf("%d",&amp;x))&#123; if(!x) break; add(x,i); &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(!d[i]) add(0,i); Toposort(); std::memset(head,0,sizeof(head)); std::memset(e,0,sizeof(e)); cnt = 0; for(int i = 1 ; i &lt;= n ; ++i) add(f[i][0],i) , add(i,f[i][0]); dfs(0,0); for(int i = 1 ; i &lt;= n ; ++i) printf("%d\n",sz[i]-1);&#125; [USACO12MAR]花盆Flowerpot题目描述Farmer John has been having trouble making his plants grow, and needs your help to water them properly. You are given the locations of N raindrops (1 &lt;= N &lt;= 100,000) in the 2D plane, where y represents vertical height of the drop, and x represents its location over a 1D number line: Each drop falls downward (towards the x axis) at a rate of 1 unit per second. You would like to place Farmer John’s flowerpot of width W somewhere along the x axis so that the difference in time between the first raindrop to hit the flowerpot and the last raindrop to hit the flowerpot is at least some amount D (so that the flowers in the pot receive plenty of water). A drop of water that lands just on the edge of the flowerpot counts as hitting the flowerpot. Given the value of D and the locations of the N raindrops, please compute the minimum possible value of W. 老板需要你帮忙浇花。给出N滴水的坐标，y表示水滴的高度，x表示它下落到x轴的位置。 每滴水以每秒1个单位长度的速度下落。你需要把花盆放在x轴上的某个位置，使得从被花盆接着的第1滴水开始，到被花盆接着的最后1滴水结束，之间的时间差至少为D。 我们认为，只要水滴落到x轴上，与花盆的边沿对齐，就认为被接住。给出N滴水的坐标和D的大小，请算出最小的花盆的宽度W。 输入输出格式输入格式： 第一行2个整数 N 和 D。 第2.. N+1行每行2个整数，表示水滴的坐标(x,y)。 输出格式： 仅一行1个整数，表示最小的花盆的宽度。如果无法构造出足够宽的花盆，使得在D单位的时间接住满足要求的水滴，则输出-1。 输入输出样例输入样例#1： 123454 56 32 44 1012 15 输出样例#1： 12 说明【样例解释】 有4滴水， (6,3), (2,4), (4,10), (12,15).水滴必须用至少5秒时间落入花盆。花盆的宽度为2是必须且足够的。把花盆放在x=4..6的位置，它可以接到1和3水滴, 之间的时间差为10-3 = 7满足条件。 【数据范围】 40%的数据：1 ≤ N ≤ 1000，1 ≤ D ≤ 2000； 100%的数据：1 ≤ N ≤ 100000，1 ≤ D ≤ 1000000，0≤x,y≤10^6。 题解很简单的单调队列嘛。 放在D1T2送分比较合适。（然而去年是个很毒瘤的模拟） 但是不要sb的交好几遍这种题才AC Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define maxn 100005int n , d;struct Node&#123; int v , t , k; bool operator &lt; (const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;p[maxn];inline int abs(int x)&#123; return x &gt;= 0 ? x : (-x);&#125;bool check(int x)&#123; std::deque&lt;int&gt; q1 , q2; for(int i = 1 ; i &lt;= n ; ++i)&#123; while(!q1.empty() &amp;&amp; p[q1.back()].t &lt; p[i].t) q1.pop_back();//max while(!q2.empty() &amp;&amp; p[q2.back()].t &gt; p[i].t) q2.pop_back();//min while(!q1.empty() &amp;&amp; p[i].v - p[q1.front()].v &gt; x) q1.pop_front(); while(!q2.empty() &amp;&amp; p[i].v - p[q2.front()].v &gt; x) q2.pop_front(); q1.push_back(i); q2.push_back(i); if(p[q1.front()].t - p[q2.front()].t &gt;= d) return true; &#125; return false;&#125;int main() &#123; scanf("%d%d",&amp;n,&amp;d); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].v,&amp;p[i].t); std::sort(p+1,p+n+1); int l = 1 , r = 1000000 , ans = 0; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(check(mid)) ans = mid , r = mid - 1; else l = mid + 1; &#125; if(ans == 0)&#123; puts("-1"); return 0; &#125; printf("%d",ans);&#125; [USACO10MAR]伟大的奶牛聚集Great Cow Gather题目描述Bessie is planning the annual Great Cow Gathering for cows all across the country and, of course, she would like to choose the most convenient location for the gathering to take place. Bessie正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。 Each cow lives in one of N (1 &lt;= N &lt;= 100,000) different barns (conveniently numbered 1..N) which are connected by N-1 roads in such a way that it is possible to get from any barn to any other barn via the roads. Road i connects barns A_i and B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N) and has length L_i (1 &lt;= L_i &lt;= 1,000). The Great Cow Gathering can be held at any one of these N barns. Moreover, barn i has C_i (0 &lt;= C_i &lt;= 1,000) cows living in it. 每个奶牛居住在 N(1&lt;=N&lt;=100,000) 个农场中的一个，这些农场由N-1条道路连接，并且从任意一个农场都能够到达另外一个农场。道路i连接农场A_i和B_i(1 &lt;= A_i &lt;=N; 1 &lt;= B_i &lt;= N),长度为L_i(1 &lt;= L_i &lt;= 1,000)。集会可以在N个农场中的任意一个举行。另外，每个牛棚中居住者C_i(0 &lt;= C_i &lt;= 1,000)只奶牛。 When choosing the barn in which to hold the Cow Gathering, Bessie wishes to maximize the convenience (which is to say minimize the inconvenience) of the chosen location. The inconvenience of choosing barn X for the gathering is the sum of the distances all of the cows need to travel to reach barn X (i.e., if the distance from barn i to barn X is 20, then the travel distance is C_i*20). Help Bessie choose the most convenient location for the Great Cow Gathering. 在选择集会的地点的时候，Bessie希望最大化方便的程度(也就是最小化不方便程度)。比如选择第X个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和，(比如，农场i到达农场X的距离是20，那么总路程就是C_i*20)。帮助Bessie找出最方便的地点来举行大集会。 Consider a country with five barns with [various capacities] connected by various roads of varying lengths. In this set of barns, neither barn 3 nor barn 4 houses any cows. 1 3 4 5 @—1—@—3—@—3—@[2] [1] | 2 | @[1] 2 Bessie can hold the Gathering in any of five barns; here is the table of inconveniences calculated for each possible location: Gather ——- Inconvenience ——— Location B1 B2 B3 B4 B5 Total 1 0 3 0 0 14 17 2 3 0 0 0 16 19 3 1 2 0 0 12 15 4 4 5 0 0 6 15 5 7 8 0 0 0 15 If Bessie holds the gathering in barn 1, then the inconveniences from each barn are: Barn 1 0 — no travel time there! Barn 2 3 — total travel distance is 2+1=3 x 1 cow = 3 Barn 3 0 — no cows there! Barn 4 0 — no cows there! Barn 5 14 — total travel distance is 3+3+1=7 x 2 cows = 14 So the total inconvenience is 17. The best possible convenience is 15, achievable at by holding the Gathering at barns 3, 4, or 5. 输入输出格式输入格式： * Line 1: A single integer: N * Lines 2..N+1: Line i+1 contains a single integer: C_i * Lines N+2..2*N: Line i+N+1 contains three integers: A_i, B_i, and L_i 第一行：一个整数 N 。 第二到 N+1 行：第 i+1 行有一个整数 C_i 第 N+2 行到 2*N 行：第 i+N+1 行为 3 个整数：A_i,B_i 和 L_i。 输出格式： * Line 1: The minimum inconvenience possible 第一行：一个值，表示最小的不方便值。 输入输出样例123456789105 1 1 0 0 2 1 3 1 2 3 2 3 4 3 4 5 3 115 题解简单树形dp中up and down的运用。 假设我们知道一个子树大小和距离和，向他的父亲贡献的答案除了已知的距离和只需要再加上到父亲那条边的长度乘上子树大小。 于是我们知道了一个有根树每个点其子树的距离和，这时候要把它转无根树，使每个点都作为根 算一遍会超时，因此考虑容斥O1转移。 因此: 设1为根（可选任意点） 设 f(i)表示i子树内距离和， g(i)表示子树内的牛数。 up -> f(x) = \sum f(v) + dis(x,v)\times g(v) down -> f(v) = f(x) - g(v) * dis + [g(root)-g(v)]*dis时间复杂度 O(n)请注意开Long Long！！ 而且注意极大值够大，毒瘤 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long longll head[maxn] , c[maxn] , cnt , n , f[maxn] , sz[maxn];struct edge&#123; ll next , to , dis;&#125;e[maxn*2];inline void add(ll x , ll y , ll dis)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;void up(ll x , ll fx)&#123; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx) continue; up(v , x); c[x] += c[v]; f[x] += f[v] + c[v] * e[i].dis; &#125;&#125;void down(ll x , ll fx)&#123; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx) continue; f[v] = (f[x] - 1ll * c[v] * e[i].dis) + 1ll*(c[1] - c[v]) * e[i].dis; down(v , x); &#125;&#125;int main()&#123; scanf("%lld",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;c[i]); int x , y , d; for(int i = 1 ; i &lt;= n-1 ; ++i) scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;d) , add(x,y,d) , add(y,x,d); up(1,1); down(1,1); ll ans = 0x7fffffffffff; for(int i = 1 ; i &lt;= n ; ++i) ans = std::min(ans , f[i]); printf("%lld",ans);&#125; [POI2008]STA-Station题目描述The first stage of train system reform (that has been described in the problem Railways of the third stage of 14th Polish OI. However, one needs not be familiar with that problem in order to solve this task.) has come to an end in Byteotia. The system consists of bidirectional segments of tracks that connect railway stations. No two stations are (directly) connected by more than one segment of tracks. Furthermore, it is known that every railway station is reachable from every other station by a unique route. This route may consist of several segments of tracks, but it never leads through one station more than once. The second stage of the reform aims at developing train connections. Byteasar count on your aid in this task. To make things easier, Byteasar has decided that: one of the stations is to became a giant hub and receive the glorious name of Bitwise, for every other station a connection to Bitwise and back is to be set up, each train will travel between Bitwise and its other destination back and forth along the only possible route, stopping at each intermediate station. It remains yet to decide which station should become Bitwise. It has been decided that the average cost of travel between two different stations should be minimal. In Byteotia there are only one-way-one-use tickets at the modest price of bythaler, authorising the owner to travel along exactly one segment of tracks, no matter how long it is. Thus the cost of travel between any two stations is simply the minimum number of tracks segments one has to ride along to get from one stations to the other. Task Write a programme that: reads the description of the train system of Byteotia, determines the station that should become Bitwise, writes out the result to the standard output. 给出一个N个点的树,找出一个点来,以这个点为根的树时,所有点的深度之和最大 ， n]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.27]]></title>
    <url>%2F2018%2F11%2F17%2FNO-27%2F</url>
    <content type="text"><![CDATA[[USACO14MAR]浇地Watering the Fields题目描述Due to a lack of rain, Farmer John wants to build an irrigation system to send water between his N fields (1 &lt;= N &lt;= 2000). Each field i is described by a distinct point (xi, yi) in the 2D plane, with 0 &lt;= xi, yi &lt;= 1000. The cost of building a water pipe between two fields i and j is equal to the squared Euclidean distance between them: (xi - xj)^2 + (yi - yj)^2 FJ would like to build a minimum-cost system of pipes so that all of his fields are linked together — so that water in any field can follow a sequence of pipes to reach any other field. Unfortunately, the contractor who is helping FJ install his irrigation system refuses to install any pipe unless its cost (squared Euclidean length) is at least C (1 &lt;= C &lt;= 1,000,000). Please help FJ compute the minimum amount he will need pay to connect all his fields with a network of pipes. 农民约翰想建立一个灌溉系统，给他的NN (1 &lt;= N &lt;= 2000)块田送水。农田在一个二维平面上，第i块农田坐标为 (x_i,y_i)，在农田ii 和农田jj 自己铺设水管的费用是这两块农田的欧几里得距离的平方 (x_i - x_j)^2 + (y_i - y_j)^2农民约翰希望所有的农田之间都能通水，而且希望花费最少的钱。但是安装工人拒绝安装费用小于C的水管(1 &lt;= CC &lt;= 1,000,000)。 请帮助农民约翰建立一个花费最小的灌溉网络，如果无法建立请输出-1。 输入输出格式输入格式： * Line 1: The integers N and C. * Lines 2..1+N: Line i+1 contains the integers xi and yi. 输出格式： * Line 1: The minimum cost of a network of pipes connecting the fields, or -1 if no such network can be built. 输入输出样例输入样例#1： 12343 110 25 04 3 输出样例#1： 146 说明INPUT DETAILS: There are 3 fields, at locations (0,2), (5,0), and (4,3). The contractor will only install pipes of cost at least 11. OUTPUT DETAILS: FJ cannot build a pipe between the fields at (4,3) and (5,0), since its cost would be only 10. He therefore builds a pipe between (0,2) and (5,0) at cost 29, and a pipe between (0,2) and (4,3) at cost 17. Source: USACO 2014 March Contest, Silver 题解可以Kruskal。 然而最开始忘了判-1还错了个点，不应该啊。D1T1难度。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 2005struct Node&#123; int x , y , dis; bool operator&lt;(const Node&amp; p)const&#123; return dis &lt; p.dis; &#125;&#125;p[maxn*maxn];int n , px[maxn] , c , py[maxn] , tot , f[maxn] , mst , cnt;inline int dist(int x , int y , int xx , int yy)&#123; return (x-xx)*(x-xx) + (y-yy)*(y-yy);&#125;int find(int x)&#123; if(f[x] != x) return f[x] = find(f[x]); return f[x];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;c); for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%d%d",&amp;px[i],&amp;py[i]); for(int j = 1 ; j &lt; i ; ++j) p[++cnt].x = i , p[cnt].y = j , p[cnt].dis = dist(px[i] , py[i] , px[j] , py[j]); &#125; std::sort(p+1,p+cnt+1); for(int i = 1; i &lt;= n ; ++i) f[i] = i; for(int i = 1 ; i &lt;= cnt ; ++i)&#123; int x = p[i].x , y = p[i].y , d = p[i].dis; int fx = find(x) , fy = find(y); if(d &lt; c) continue; if(tot == n-1) break; if(fx != fy)&#123; f[fx] = fy; mst += d; ++tot; &#125; &#125; if(tot &lt; n-1)&#123; puts("-1"); return 0; &#125; printf("%d",mst); &#125; [USACO16FEB]负载平衡Load Balancing_Silver题目描述Farmer John’s NN cows are each standing at distinct locations (x_1, y_1) \ldots (x_n, y_n)(x1,y1)…(xn,yn) on his two-dimensional farm (1 \leq N \leq 10001≤N≤1000, and the x_ixi’s and y_iyi’s are positive odd integers of size at most 1,000,0001,000,000). FJ wants to partition his field by building a long (effectively infinite-length) north-south fence with equation x=ax=a (aawill be an even integer, thus ensuring that he does not build the fence through the position of any cow). He also wants to build a long (effectively infinite-length) east-west fence with equation y=by=b, where bb is an even integer. These two fences cross at the point (a,b)(a,b), and together they partition his field into four regions. FJ wants to choose aa and bb so that the cows appearing in the four resulting regions are reasonably “balanced”, with no region containing too many cows. Letting MM be the maximum number of cows appearing in one of the four regions, FJ wants to make MM as small as possible. Please help him determine this smallest possible value for MM. 给你一个矩阵，里面有些点，让你横向切一刀，纵向切一刀，使得得到的四个区域内的最大的点数最少。 输入输出格式输入格式： The first line of the input contains a single integer, NN. The next NN lines each contain the location of a single cow, specifying its xx and yy coordinates. 输出格式： You should output the smallest possible value of MM that FJ can achieve by positioning his fences optimally. 输入输出样例输入样例#1： 1234567877 35 57 133 111 75 39 1 输出样例#1： 12 题解本题的主要思路是离散化+前缀和优化。 考虑点数较小而坐标较大，我们对点坐标离散化。离散化的标准是值的相对关系不变。可以用如下方法： 1234567891011std::sort(g+1,g+cnt+1);for(int i = 1 ; i &lt;= cnt ; ++i)&#123; if(g[i].type)&#123; if(g[i].v == g[i-1].v) X[g[i].k] = tot; else X[g[i].k] = ++tot; &#125;else&#123; if(g[i].v == g[i-1].v) Y[g[i].k] = tot; else Y[g[i].k] = ++tot; &#125;&#125; 这是我自己琢磨出来的办法，还是很好用的。 然后我们把这n个坐标不超过tot的点放到二维数组中做前缀和。 然后枚举每一条横线与纵线， O(1)的更新答案。 最后的时间复杂度为 O(n^2)可以通过本题。 一遍切D1T2难度的题呢。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 2005int p[maxn][maxn] , s[maxn][maxn] , n , tot , ans = 0x7fffffff, X[maxn] , Y[maxn] , ss[maxn];struct Node&#123; int v , k , type; bool operator &lt; (const Node&amp; p)const &#123; return v &lt; p.v; &#125;&#125;g[maxn];int main()&#123; scanf("%d",&amp;n); int x , y; int cnt = 0; for(int i = 1 ; i &lt;= n ; ++i)&#123; scanf("%d%d",&amp;x,&amp;y); g[++cnt].v = x , g[cnt].k = i , g[cnt].type = 0; g[++cnt].v = y , g[cnt].k = i , g[cnt].type = 1; &#125; std::sort(g+1,g+cnt+1); for(int i = 1 ; i &lt;= cnt ; ++i) &#123; if(g[i].type)&#123; if(g[i].v == g[i-1].v) X[g[i].k] = tot; else X[g[i].k] = ++tot; &#125;else&#123; if(g[i].v == g[i-1].v) Y[g[i].k] = tot; else Y[g[i].k] = ++tot; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) p[X[i]][Y[i]] = 1; n = tot; for(int i = 1 ; i &lt;= n ; ++i) &#123; std::memset(ss,0,sizeof(ss)); for(int j = 1 ; j &lt;= n ; ++j) ss[j] = ss[j-1] + p[i][j]; for(int j = 1 ; j &lt;= n ; ++j) s[i][j] = s[i-1][j] + ss[j]; &#125; for(int i = 1 ; i &lt;= tot ; ++i) for(int j = 1 ; j &lt;= tot ; ++j) &#123; int cur = -0x7fffff; cur = std::max(cur , s[i][j]); cur = std::max(cur , s[tot][j] - s[i][j]); cur = std::max(cur , s[i][tot] - s[i][j]); cur = std::max(cur , s[tot][tot] - s[tot][j] - s[i][tot] + s[i][j]); ans = std::min(ans , cur); &#125; printf("%d",ans);&#125; [USACO07NOV]挤奶的时间Milking Time题目描述Bessie is such a hard-working cow. In fact, she is so focused on maximizing her productivity that she decides to schedule her next N (1 ≤ N ≤ 1,000,000) hours (conveniently labeled 0..N-1) so that she produces as much milk as possible. Farmer John has a list of M (1 ≤ M ≤ 1,000) possibly overlapping intervals in which he is available for milking. Each interval i has a starting hour (0 ≤ starting_houri ≤ N), an ending hour (starting_houri &lt; ending_houri ≤ N), and a corresponding efficiency (1 ≤ efficiencyi ≤ 1,000,000) which indicates how many gallons of milk that he can get out of Bessie in that interval. Farmer John starts and stops milking at the beginning of the starting hour and ending hour, respectively. When being milked, Bessie must be milked through an entire interval. Even Bessie has her limitations, though. After being milked during any interval, she must rest R (1 ≤ R ≤ N) hours before she can start milking again. Given Farmer Johns list of intervals, determine the maximum amount of milk that Bessie can produce in the N hours. 奶牛Bessie在0~N时间段产奶。农夫约翰有M个时间段可以挤奶，时间段f,t内Bessie能挤到的牛奶量e。奶牛产奶后需要休息R小时才能继续下一次产奶，求Bessie最大的挤奶量。 输入输出格式输入格式： * Line 1: Three space-separated integers: N, M, and R * Lines 2..M+1: Line i+1 describes FJ’s ith milking interval withthree space-separated integers: starting_houri , ending_houri , and efficiencyi 输出格式： * Line 1: The maximum number of gallons of milk that Bessie can product in the N hours 输入输出样例输入样例#1： 1234512 4 21 2 810 12 193 6 247 10 31 输出样例#1： 143 题解这个题是个很简单的dp，然而我并没有想出状态是什么。。。非常失败qwq 我们考虑最大的那种方案肯定是以某个区间结尾，然后我们需要一个子问题满足后面可以方便的转移。 就设 f(i)表示以第i个区间作为结尾的最大值，然后从前面不相交的状态中找一个最大的加上它自己就可以了。 当然这种dp必须将区间按照左端点排序，否则就没有无后效性的性质了。 比较套路，然后我没做出来，GG Code： 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define maxn 1005#define maxm 1000005int n , m , r , ans , f[maxn];struct Node&#123; int l , r , v; bool operator &lt; (const Node&amp; x)const&#123; return l &lt; x.l; &#125; bool operator &gt; (const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;p[maxn];int main()&#123; scanf("%d%d%d",&amp;m,&amp;n,&amp;r); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d%d",&amp;p[i].l , &amp;p[i].r , &amp;p[i].v); std::sort(p+1,p+n+1); for(int i = 1 ; i &lt;= n ; ++i)&#123; for(int j = 1 ; j &lt; i ; ++j) if(p[i].l - p[j].r &gt;=r) f[i] = std::max(f[i],f[j]); f[i] += p[i].v; ans = std::max(ans , f[i]); &#125; printf("%d",ans);&#125; CF670C Cinema题意翻译莫斯科在举办一场重要的有nn 个不同国家的珂学家参与的国际会议，每个珂学家都只会一种语言。为了方便起见，我们规定一种语言用11 到10^9109 的数来描述。 在会议之后的晚上，珂学家们决定去看电影。他们去的电影院有mm 场电影，每场有两个不同的数字，分别代表配音的语言和字幕的语言。如果一个珂学家能听懂配音，他会非常愉悦；如果能看懂字幕，他会比较满意。如果既看不懂也听不懂，他会很生气。 珂学家们决定去看同一场电影，你必须帮助他们选择一场电影，让愉悦的人最多的前提下，比较满意的人最多。 输入格式： 第一行一个整数n(1 \leq n \leq 200000)n(1≤n≤200000) 表示珂学家个数。 第二行nn 个整数a_1, a_2, …, a_n(1 \leq a_i \leq 10^9)a1,a2,…,an(1≤ai≤109) 表示珂学家们会的语言。 第三行一个整数1 \leq m \leq 2000001≤m≤200000 表示电影的场数。 第四行mm 个整数b_1, b_2, …, b_n(1 \leq b_j \leq 10^9)b1,b2,…,bn(1≤bj≤109) 表示电影的配音用的语言。 第五行mm 个整数c_1, c_2, …, c_n(1 \leq c_j \leq 10^9)c1,c2,…,cn(1≤cj≤109) 表示电影的字幕用的语言。 输出格式： 一个整数表示安排哪一场电影。 如果有多种情况，选择比较满意的方案输出。 题目描述Moscow is hosting a major international conference, which is attended by nn scientists from different countries. Each of the scientists knows exactly one language. For convenience, we enumerate all languages of the world with integers from 11 to 10^{9}109 . In the evening after the conference, all nn scientists decided to go to the cinema. There are mm movies in the cinema they came to. Each of the movies is characterized by two distinct numbers — the index of audio language and the index of subtitles language. The scientist, who came to the movie, will be very pleased if he knows the audio language of the movie, will be almost satisfied if he knows the language of subtitles and will be not satisfied if he does not know neither one nor the other (note that the audio language and the subtitles language for each movie are always different). Scientists decided to go together to the same movie. You have to help them choose the movie, such that the number of very pleased scientists is maximum possible. If there are several such movies, select among them one that will maximize the number of almost satisfied scientists. 输入输出格式输入格式： The first line of the input contains a positive integer n ( 1]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.17]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-17%2F</url>
    <content type="text"><![CDATA[P3917 异或序列题目描述给出序列 A_1,A_2,\cdots,A_N求 \sum_{1\le i\le j\le N} A_i\bigoplus A_{i+1}\bigoplus\cdots\bigoplus A_j∑1≤i≤j≤NAi⨁Ai+1⨁⋯⨁Aj的值。其中， \bigoplus表示按位异或。 输入输出格式输入格式： 第1 行，1 个整数NN。 第2 行，NN个整数A_1,A_2,\cdots,A_NA1,A2,⋯,AN。 输出格式： 一个数，为表达式的值 输入输出样例输入样例#1： 1221 2 输出样例#1： 16 说明• 对于60% 的数据， 1 \le N \le 10^3• 对于100% 的数据， 1 \le N \le 10^5; 0 \le A_i \le 10^9题解计算一个区间的xor我们首先可以想到前缀异或，两个前缀异或进行异或运算就是区间异或值。 然后我们怎么快速统计所有区间异或值呢？ 不难想到按位统计，每一位上0和1的个数乘起来（0不要忘了+1，还有左端点为0的情况）就是所有这一位能是一的区间个数（乘法原理） Code: 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long longll A[maxn] , n , Xor[55][maxn] , ans;int main()&#123; scanf("%lld",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;A[i]); for(int i = 2 ; i &lt;= n ; ++i) A[i] ^= A[i-1]; for(int k = 53 ; k &gt;= 0 ; --k) for(int i = 1 ; i &lt;= n ; ++i) Xor[k][i] = (A[i]&gt;&gt;k)&amp;1; for(int k = 53 ; k &gt;= 0 ; --k) &#123; int tot = 0 ; for(int i = 1 ; i &lt;= n ; ++i) if(Xor[k][i]) ++tot; ans += (1&lt;&lt;k) * tot * (n-tot+1); &#125; printf("%lld",ans);&#125; P2188 小Z的 k 紧凑数题目描述小 Z 在草稿纸上列出了很多数，他觉得相邻两位数字差的绝对值不超过 k 的整数特别奇特，称其为 k 紧凑数。 现在小 Z 想知道 [l，r] 内有多少个 k 紧凑数，希望你帮帮他。 输入输出格式输入格式： 第一行包含三个整数 l，r，k。 输出格式： 第一行包含一个整数，表示 [l，r] 内 k 紧凑数的个数。 输入输出样例输入样例#1： 复制 11 13 1 输出样例#1： 复制 112 说明【数据规模】 对于 30% 的数据， r − l ≤ 10^5；对于另外 30% 的数据，l = 1，r 为 10 的倍数； 对于 100% 的数据， 1 ≤ l ≤ r ≤ 10^{18}，0 ≤ k ≤ 8。题解又独立切了省选难度的题嘤嘤嘤。 我的数位dp似乎比大佬的麻烦 状态设计为：f(i,0/1,0/1,j)表示当前是从高位的第i位，卡不卡上界，是否全是前导0，最后一位是j的数量。 由于我是做差所以没有带卡下界状态，假如只做一次DP可以带上卡下界。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define ll long longll L, R , k , f[25][2][2][10] , p[25] , len = 0;inline void set(ll x)&#123; if(x &lt; 10) &#123;p[++len] = x;return;&#125; set(x/10); p[++len] = x % 10;&#125;inline int abs(ll x)&#123; return x &gt;= 0 ? x : -x;&#125;inline ll solve(ll x)&#123; ll ans = 0; std::memset(f,0,sizeof(f)); std::memset(p,0,sizeof(p)); len = 0; set(x); for(int i = 0 ; i &lt;= p[1] ; ++i) f[1][i==p[1]][i==0][i] = 1; for(int i = 2 ; i &lt;= len ; ++i)//cur digit for(int up = 0 ; up &lt;= 1 ; ++up) for(int allz = 0 ; allz &lt;= 1 ; ++allz) for(int la = 0 ; la &lt;= 9 ; ++la) if(f[i-1][up][la]) for(int nd = 0 ; nd &lt;= 9 ; ++nd) &#123; int nup = 0 , nz = 0; if(up &amp;&amp; (nd==p[i])) nup = 1; if(up &amp;&amp; nd &gt; p[i]) continue; if(allz &amp;&amp; nd == 0) nz = 1; if(abs(nd-la) &gt; k &amp;&amp; (!allz)) continue; f[i][nup][nz][nd] += f[i-1][up][allz][la]; // printf("f[%d][%d][%d] += f[%d][%d][%d]\n",i,nup,nd,i-1,up,la); &#125; for(int up = 0 ; up &lt;= 1 ; ++up) for(int az = 0 ; az &lt;= 1 ; ++az) for(int la = 0 ; la &lt;= 9 ; ++la) ans += f[len][up][az][la]; return ans;&#125;int main()&#123; // k = 9; scanf("%lld%lld",&amp;L,&amp;R); scanf("%lld",&amp;k); printf("%lld",solve(R) - solve(L-1)); // std::cout&lt;&lt;solve(13);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.45]]></title>
    <url>%2F2018%2F11%2F17%2FNO-45%2F</url>
    <content type="text"><![CDATA[[国家集训队]单选错位题目描述gx和lc去参加noip初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。试卷上共有n道单选题，第i道单选题有ai个选项，这ai个选项编号是1,2,3,…,ai，每个选项成为正确答案的概率都是相等的。lc采取的策略是每道题目随机写上1-ai的某个数作为答案选项，他用不了多少时间就能期望做对\sum_{i=1}^n \frac{1}{a_i}∑i=1nai1道题目。gx则是认认真真地做完了这n道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第i道题目的答案抄到了答题纸上的第i+1道题目的位置上，特别地，第n道题目的答案抄到了第1道题目的位置上。现在gx已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被lc鄙视了。 我们假设gx没有做错任何题目，只是答案抄错位置了。 输入输出格式输入格式： n很大，为了避免读入耗时太多，输入文件只有5个整数参数n, A, B, C, a1，由上交的程序产生数列a。下面给出pascal/C/C++的读入语句和产生序列的语句（默认从标准输入读入）： 12345678910111213// for pascalreadln(n,A,B,C,q[1]);for i:=2 to n doq[i] := (int64(q[i-1]) * A + B) mod 100000001;for i:=1 to n doq[i] := q[i] mod C + 1;// for C/C++scanf("%d%d%d%d%d",&amp;n,&amp;A,&amp;B,&amp;C,a+1);for (int i=2;i&lt;=n;i++)a[i] = ((long long)a[i-1] * A + B) % 100000001;for (int i=1;i&lt;=n;i++)a[i] = a[i] % C + 1; 选手可以通过以上的程序语句得到n和数列a（a的元素类型是32位整数），n和a的含义见题目描述。 输出格式： 输出一个实数，表示gx期望做对的题目个数，保留三位小数。 输入输出样例输入样例#1： 13 2 0 4 1 输出样例#1： 11.167 说明【样例说明】 1234567正确答案 | gx的答案 | 做对题目| 出现概率&#123;1,1,1&#125; | &#123;1,1,1&#125; | 3 | 1/6&#123;1,2,1&#125; | &#123;1,1,2&#125; | 1 | 1/6&#123;1,3,1&#125; | &#123;1,1,3&#125; | 1 | 1/6&#123;2,1,1&#125; | &#123;1,2,1&#125; | 1 | 1/6&#123;2,2,1&#125; | &#123;1,2,2&#125; | 1 | 1/6&#123;2,3,1&#125; | &#123;1,2,3&#125; | 0 | 1/6 a[] = {2,3,1} 共有6种情况，每种情况出现的概率是1/6，gx期望做对(3+1+1+1+1+0)/6 = 7/6题。（相比之下，lc随机就能期望做对11/6题） 对于30%的数据 n≤10, C≤10 对于80%的数据 n≤10000, C≤10 对于90%的数据 n≤500000, C≤100000000 对于100%的数据 2≤n≤10000000, 0≤A,B,C,a1≤100000000 题解一道比较简单的期望题。 对于当前A_i个选项，假如 A_{i+1}比它小，那么只有 A_{i+1}个有效可能，每种可能均相等为 1/A_{i+1},期望做对也是 1/A_{i+1}另一种同样分析。 所以第i道做对的期望是： 1/max\{A_i,A_{i+1}\}Code: 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 10000005int n , a[maxn] , A , B , C;double ans;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;A,&amp;B,&amp;C,a+1); for (int i=2;i&lt;=n;i++) a[i] = ((long long)a[i-1] * A + B) % 100000001; for (int i=1;i&lt;=n;i++) a[i] = a[i] % C + 1; for(int i = 1 ; i &lt; n ; ++i) ans += (double)1 / std::max(a[i] , a[i+1]); ans += (double)1 / std::max(a[n] , a[1]); printf("%.3lf",ans);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.42]]></title>
    <url>%2F2018%2F11%2F17%2FNO-42%20%E7%BB%88%E6%9C%AB%E4%B8%8E%E5%BC%80%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[2018.11.11 由于去昌邑带的笔记本不支持Typora，因此没能写篇游记。可能写了只会更难过了吧。 这次的NOIP是场灾难，虽然题目质量确实没有去年那么好，但是还是失误太多了，只能怪自己。 D1策略严重失误，以至于全场都切的D1T2我只拿了15分，这意味着我D2必须发挥很好才能翻盘了。 很可惜D2并没有翻盘的余地了，D2T1用了两个小时调线性做法，后来发现不需要，因此没有足够时间打T3，读错了题，44分白白溜走。 最终预期得分可能是：100 + 15 + 35 + 100 + 0 + 0 = 250 这样我就成功因为最后的失误省一 —&gt; 省二 这个结果大概自己都没想到吧。。 无论如何，前方的路还很长，自己努力吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.41]]></title>
    <url>%2F2018%2F11%2F17%2FNO-41%20%E5%87%BA%E5%8F%91%E5%89%8D%E7%9A%84Note%2F</url>
    <content type="text"><![CDATA[P2736 “破锣摇滚”乐队 Raucous Rockers题目描述你刚刚继承了流行的“破锣摇滚”乐队录制的尚未发表的N(1 &lt;= N &lt;= 20)首歌的版权。你打算从中精选一些歌曲，发行M(1 &lt;= M &lt;= 20)张CD。每一张CD最多可以容纳T(1 &lt;= T &lt;= 20)分钟的音乐，一首歌不能分装在两张CD中。CD数量可以用完，也可以不用完 不巧你是一位古典音乐迷，不懂如何判定这些歌的艺术价值。于是你决定根据以下标准进行选择： 1.歌曲必须按照创作的时间顺序在所有的CD盘上出现。(注：第i张盘的最后一首的创作时间要早于第i+1张盘的第一首) 2.选中的歌曲数目尽可能地多 输入输出格式输入格式： 第一行： 三个整数：N, T, M. 第二行： N个整数，分别表示每首歌的长度，按创作时间顺序排列。 输出格式： 一个整数，表示可以装进M张CD盘的乐曲的最大数目。 输入输出样例输入样例#1： 124 5 24 3 4 2 输出样例#1： 13 说明题目翻译来自NOCOW。 USACO Training Section 3.4 题解一道二维费用背包题，后面的物品后选就可以了。 显然我们将时间作为费用，但是由于并没用什么差异所以不用放进状态中。 然后我们用 f(i,j,k)表示我们将前i首歌放进j个光盘，最后一张剩余时间k的最大值，考虑全情况，尤其是可以新开一张的转移状态。 Code： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 1005int f[maxn][maxn] , n , m , T , v[maxn] , ans;int max(int x , int y , int z)&#123; int k = x &gt; y ? x : y; return k &gt; z ? k : z;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;T,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); for(int i = 1 ; i &lt;= n ; ++i)&#123; for(int j = m ; j &gt;= 1 ; --j) for(int k = T ; k &gt;= v[i]; --k)&#123; f[j][k] = max(f[j][k] , f[j-1][T] + 1, f[j][k - v[i]] + 1); &#125; &#125; printf("%d",f[m][T]);&#125; P2440 木材加工题目背景要保护环境 题目描述题目描述: 木材厂有一些原木，现在想把这些木头切割成一些长度相同的小段木头（木头有可能有 剩余），需要得到的小段的数目是给定的。当然，我们希望得到的小段木头越长越好，你的任务 是计算能够得到的小段木头的最大长度。木头长度的单位是cm。原木的长度都是正整数， 我们要求切割得到的小段木头的长度也是正整数。 例如有两根原木长度分别为11和21，要求切割成到等长的6段，很明显能切割出来的小段木头长度最长为5. 输入输出格式输入格式： 输入: 第一行是两个正整数N和K(1 ≤ N ≤ 100000，1 ≤ K ≤ 100000000)，N是原木的数目，K是需要得到的小段的数目。 接下来的N行，每行有一个1到100000000之间的正整数，表示一根原木的长度。 输出格式： 输出: 能够切割得到的小段的最大长度。如果连1cm长的小段都切不出来，输出”0”。 输入输出样例输入样例#1： 12343 7232124456 输出样例#1： 1114 题解一眼二分答案，然后发现check只需要一个循环。。 Code： 123456789101112131415161718192021222324252627#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int p[maxn] , n , k;inline int solve(int now)&#123; int ans = 0; for(int i = 1 ; i &lt;= n ; ++i) ans += p[i] / now; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); int l = 1 , r = 1000000000 , ans = 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(solve(mid) &gt;= k) ans = mid , l = mid + 1; else r = mid - 1; &#125; printf("%d",ans);&#125; P4949 最短距离题目描述给出一个 {N}N 个点 {N}N 条边的无向连通图。 你需要支持两种操作： 修改 第 {x}x 条边的长度为 {y}y ； 查询 点 {x}x 到点 {y}y 的最短距离。 共有 {M}M 次操作。 输入输出格式输入格式： 输入共 N + M + 1 行： 第 1 行，包含 2 个正整数 N，M，表示点数即边数，操作次数。 第 2 行到第 N + 1 行，每行包含 3 个正整数 x，y，z，表示 x 与 y 间有一条长度 为 z 的边。 第 N + 2 到 N + M + 1 行，每行包含 3 个正整数 opt，x，y，表示操作种类，操作的参数（含义见【题目描述】）。 输出格式： 对于每次操作 2 输出查询的结果。 输入输出样例输入样例#1： 123456789104 51 2 111 3 122 3 131 4 152 2 31 2 12 2 32 2 42 3 4 输出样例#1： 123413122616 说明 题解实现有点麻烦，NOIp以后再写（如果不退役的话），先随便说说思路，以后写个完整版。 基环树是在树上连了一条边。 首先我们找出这个环，标记上面的点，再以每个点为根求出其子树内的点的根（即环上的点，这样对于后面的点我们可以知道它们在环上的点）。 接下来我的做法比题解就优秀了，尤其是空间上我们任意取环上一条边标记断边，然后以1为根HPD。 接下来将环上的边按顺序放到线段树上。（一条链） 同时维护一个变量为环上边权 修改每条边的时候假如是树边，就把HPD更新即可，假如是环上的边，更新上述三个。 对于每次查询，其答案为 min\{Qlink(x,y) , Qlink(x,y) sum - 2 * dis(belong(x) , belong(y) )\}belong数组是在找出环后对每个点子树内的点做的处理。 时间复杂度 Ｏ(nlogn + qlogn)以小常数通过本题]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.43]]></title>
    <url>%2F2018%2F11%2F17%2FNO-43%20%E5%BC%80%E7%AB%AF%E4%B9%8B%E5%88%9D%2F</url>
    <content type="text"><![CDATA[可能接下来一段时间里就不能一心一意学OI了，我落下的文化课可能是最多的。 突然想到一道题 [USACO07MAR]排名的牛Ranking the Cows题目描述Each of Farmer John’s N cows (1 ≤ N ≤ 1,000) produces milk at a different positive rate, and FJ would like to order his cows according to these rates from the fastest milk producer to the slowest. FJ has already compared the milk output rate for M (1 ≤ M ≤ 10,000) pairs of cows. He wants to make a list of C additional pairs of cows such that, if he now compares those C pairs, he will definitely be able to deduce the correct ordering of all N cows. Please help him determine the minimum value of C for which such a list is possible. FJ想按照奶牛产奶的能力给她们排序。现在已知有N头奶牛（1 ≤ N ≤ 1,000）。FJ通过比较，已经知道了M（1 ≤ M ≤ 10,000）对相对关系。每一对关系表示为“X Y”，意指X的产奶能力强于Y。现在FJ想要知道，他至少还要调查多少对关系才能完成整个排序。 输入输出格式输入格式： Line 1: Two space-separated integers: N and M Lines 2..M+1: Two space-separated integers, respectively: X and Y. Both X and Y are in the range 1…N and describe a comparison where cow X was ranked higher than cow Y. 输出格式： Line 1: A single integer that is the minimum value of C. 输入输出样例输入样例#1： 1234565 52 11 52 31 43 4 输出样例#1： 13 说明From the information in the 5 test results, Farmer John knows that since cow 2 &gt; cow 1 &gt; cow 5 and cow 2 &gt; cow 3 &gt; cow 4, cow 2 has the highest rank. However, he needs to know whether cow 1 &gt; cow 3 to determine the cow with the second highest rank. Also, he will need one more question to determine the ordering between cow 4 and cow 5. After that, he will need to know if cow 5 &gt; cow 3 if cow 1 has higher rank than cow 3. He will have to ask three questions in order to be sure he has the rankings: “Is cow 1 &gt; cow 3? Is cow 4 &gt; cow 5? Is cow 5 &gt; cow 3?” 题解bitset传递闭包。 我突然想到之所以我错的原因是 12for(int i = 1 ; i &lt;= n ; ++i) s[i] |= 1 &lt;&lt; i; 无话可说。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// luogu-judger-enable-o2// luogu-judger-enable-o2// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;bitset&gt;#define maxn 1005std::vector&lt;int&gt; G[maxn]; // positive , negetiveint n , m , ans , d[maxn];bool vis[maxn][maxn];std::bitset&lt;maxn&gt; s[maxn];inline void Toposort()&#123; std::queue&lt;int&gt; q; for(int i = 1 ; i &lt;= n ; ++i) if(!d[i]) q.push(i); while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = 0 ; i &lt; (int)G[k].size() ; ++i)&#123; int v = G[k][i]; s[v] |= s[k]; --d[v]; if(!d[v]) q.push(v); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= m ; ++i)&#123; int x , y; scanf("%d%d",&amp;x,&amp;y); if(vis[x][y] || vis[y][x]) continue; G[y].push_back(x); vis[x][y] = vis[y][x] = true; ++d[x]; &#125; for(int i = 1 ; i &lt;= n ; ++i) s[i][i] = 1; Toposort(); for(int i = 1 ; i &lt;= n ; ++i) ans += s[i].count();//include itself , so it is n ans = n * (n - 1) / 2 + n - ans; printf("%d",ans);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.37写给自己]]></title>
    <url>%2F2018%2F11%2F17%2FNO-37%2F</url>
    <content type="text"><![CDATA[今天是11.5日，距离NOIp 2018还有4天。 虽然水平有限，不过还是会尽力做到最好 最近两周也算是很勤奋啦，比起以前一个月的效率可能还高，然而有时候也想知道，假如最初来的时候就把OI当成一件最重要的事来做，会不会比现在的我强的多呢？那时候假如我不是在天天做什么无聊的搜索模拟题，而是在学习的同时慢慢提高自己的代码能力，也许结果会好的多。 不过RBZ对自己还是有信心的，对于除了NOIp 2017难度以外，都是有信心400+的，然而假如今年更难了呢？会不会后悔浪费了太多时间呢？ 大概还有几道比较难的题没写：宝藏 列队 开车旅行 天天爱跑步 NOIp前肯定会完成的。 8月在夏令营的时候我有没有意识到我的水平很低呢？ 不管怎么样，尽力而为，不要轻易放弃。尽管如此，依然希望自己NOIp拿到一个较为不错的分数，让自己高一有更多时间学习OI。否则可能高二的打算仅仅是联赛高分了。 瑾以纪念我的努力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.40]]></title>
    <url>%2F2018%2F11%2F17%2FNO-40%20%E6%98%8C%E9%82%91%E5%89%8D%E5%A4%9C%2F</url>
    <content type="text"><![CDATA[明天中午就要去昌邑了，今天下午为了放松出去和妈妈到处转了转。 心里其实还是紧张的，毕竟自己虽然水平一般可却不得不达到一批的标准？ 其实假如发挥稳定，省一还是能拿到的吧。。千万不要有意外啊。 打了一遍Treap的板子，感觉除了平衡树以外的都没什么问题了。 其中果然犯了很细微但是很严重的错误 12345678if(vx == v[Node])&#123; if(c[Node] &gt; 1) --c[Node] , --sz[Node]; else if(!ls[Node] || !rs[Node]) Node = ls[Node] + rs[Node]; else if(p[ls[Node]] &lt; p[rs[Node]]) Zig(Node) , Delete(Node , vx); else Zag(Node) , Delete(Node , vx); return ; // return ! return ! return !&#125; Delete函数中这段最后不加return是会严重错误的，它将使sz的维护彻底错误。 [HNOI2015]菜肴制作题目描述知名美食家小 A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小 A 准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。 由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如”i 号菜肴’必须’先于 j 号菜肴制作“的限制，我们将这样的限制简写为。 现在，酒店希望能求出一个最优的菜肴的制作顺序，使得小 A能尽量先吃到质量高的菜肴： 也就是说， (1)在满足所有限制的前提下，1 号菜肴”尽量“优先制作； (2)在满足所有限制，1号菜肴”尽量“优先制作的前提下，2号菜肴”尽量“优先制作； (3)在满足所有限制，1号和2号菜肴”尽量“优先的前提下，3号菜肴”尽量“优先制作 ；(4)在满足所有限制，1 号和 2 号和 3 号菜肴”尽量“优先的前提下，4 号菜肴”尽量“优先制作； (5)以此类推。 例1：共4 道菜肴，两条限制、，那么制作顺序是 3,4,1,2。 例2：共5道菜肴，两条限制、 ，那么制作顺序是 1,5,2,4,3。 例1里，首先考虑 1，因为有限制和，所以只有制作完 3 和 4 后才能制作 1，而根据(3)，3 号又应”尽量“比 4 号优先，所以当前可确定前三道菜的制作顺序是 3,4,1；接下来考虑2，确定最终的制作顺序是 3,4,1,2。 例 2里，首先制作 1是不违背限制的；接下来考虑 2 时有的限制，所以接下来先制作 5 再制作 2；接下来考虑 3 时有的限制，所以接下来先制作 4再制作 3，从而最终的顺序是 1,5,2,4,3。 现在你需要求出这个最优的菜肴制作顺序。无解输出”Impossible!“ （不含引号，首字母大写，其余字母小写） 输入输出格式输入格式： 第一行是一个正整数D，表示数据组数。 接下来是D组数据。 对于每组数据： 第一行两个用空格分开的正整数N和M，分别表示菜肴数目和制作顺序限制的条目数。 接下来M行，每行两个正整数x,y，表示”x号菜肴必须先于y号菜肴制作“的限制。（注意：M条限制中可能存在完全相同的限制） 输出格式： 输出文件仅包含 D 行，每行 N 个整数，表示最优的菜肴制作顺序，或者“Impossible!“表示无解（不含引号）。 输入输出样例输入样例#1： 1234567891011121335 45 45 34 23 23 31 22 33 15 25 24 3 输出样例#1： 1231 5 3 4 2 Impossible! 1 5 2 4 3 说明【样例解释】 第二组数据同时要求菜肴1先于菜肴2制作，菜肴2先于菜肴3制作，菜肴3先于 菜肴1制作，而这是无论如何也不可能满足的，从而导致无解。 100%的数据满足N,M&lt;=100000,D&lt;=3。 题解]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.46]]></title>
    <url>%2F2018%2F11%2F17%2Fno-46%2F</url>
    <content type="text"><![CDATA[P4949 最短距离题目描述给出一个 N 个点 N 条边的无向连通图。 你需要支持两种操作： 修改 第 x 条边的长度为 y ； 查询 点 x 到点 y 的最短距离。 共有 M 次操作。 输入输出格式输入格式： 输入共 N + M + 1 行： 第 1 行，包含 2 个正整数 N，M，表示点数即边数，操作次数。 第 2 行到第 N + 1 行，每行包含 3 个正整数 x，y，z，表示 x 与 y 间有一条长度 为 z 的边。 第 N + 2 到 N + M + 1 行，每行包含 3 个正整数 opt，x，y，表示操作种类，操作的参数（含义见【题目描述】）。 输出格式： 对于每次操作 2 输出查询的结果。 输入输出样例输入样例#1： 123456789104 51 2 111 3 122 3 131 4 152 2 31 2 12 2 32 2 42 3 4 输出样例#1： 123413122616 说明 题解这道题思维难度还行，代码实现难度略高。 首先我们需要实现支持以下功能的函数： O(1)查询每条边代表的点，断边为0即可 O(1)维护环上边权总和 O(1)查询一条边是否为割边。 O(1)查询邻接表中每个编号所对应的读入顺序 O(1)查询一个点所属的环子树 接下来任选一条边断开，将这颗树用HPD维护。 当给出一个修改操作时 如果是树边，直接HPD维护， O(nlogn) 如果是环边，O(1)在数组中修改这条环边边权，O(1)更新环上边权总和，O(nlogn)更新HPD这条边对应点点权 对于查询操作 如果两点属于同一环子树，直接查询两点距离， O(nlog^2n) 如果属于不同子树，需要考虑环上另一条路径长度（O(1)查询即可），复杂度同样 上一下一遍过的Code（NOIP要是我代码能力发挥出写这题的一半就不会炸这么惨。。。）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define maxn 105005#define ll long longint n , head[maxn] , cnt = 1 , u , v , circle[maxn] , m , eref[maxn &lt;&lt; 1];ll val[maxn];struct edge&#123; int next , to ; ll dis;&#125;e[maxn&lt;&lt;1];inline bool isEdge(int x , int y)&#123; if(x == u &amp;&amp; y == v) return false; if(x == v &amp;&amp; y == u) return false; return true;&#125;inline bool c(int x)&#123; return circle[x];&#125;inline void add(int x , int y , ll d)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;namespace cir&#123; int dfn[maxn] , low[maxn] , idx , tot , cirnum , sz[maxn]; bool flag; std::stack&lt;int&gt; st; void DFS_CIRCLE(int x , int pre) &#123; if(flag) return; dfn[x] = low[x] = ++idx; st.push(x); for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(!dfn[v])&#123; DFS_CIRCLE(v , x); low[x] = std::min(low[x] , low[v]); &#125; else if(v != pre) low[x] = std::min(low[x] , dfn[v]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; circle[st.top()] = tot; ++sz[tot]; st.pop(); &#125; circle[st.top()] = tot; ++sz[tot]; st.pop(); if(sz[tot] &gt; 1) &#123; flag = true; cirnum = tot; return; &#125; &#125; &#125; void pre() &#123; DFS_CIRCLE(1,1); for(int i = 1 ; i &lt;= n ; ++i) if(circle[i] != cirnum) circle[i] = 0; for(int i = 1 ; i &lt;= n ; ++i)&#123; if(circle[i])&#123; u = i; for(int j = head[i] ; j ; j = e[j].next)&#123; if(circle[e[j].to]) v = e[j].to; &#125; break; &#125; &#125; &#125;&#125;struct SegmentTree&#123; #define ls(x) (x &lt;&lt; 1) #define rs(x) (x &lt;&lt; 1 | 1) #define pushup(x) sum[x] = sum[ls(x)] + sum[rs(x)] ll sum[maxn&lt;&lt;2]; void build(int l , int r , int Node , ll v[]) &#123; if(l == r) &#123; sum[Node] = v[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(l , mid , ls(Node) , v); build(mid + 1 , r , rs(Node) , v); pushup(Node); &#125; void update(int p , int l , int r , int Node , ll v) &#123; if(l == r)&#123; sum[Node] = v; return; &#125; int mid = l + r &gt;&gt; 1; if(p &lt;= mid) update(p , l , mid , ls(Node) , v); else update(p , mid + 1 , r , rs(Node) , v); pushup(Node); &#125; ll query(int L , int R , int l , int r , int Node) &#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; return sum[Node]; &#125; int mid = l + r &gt;&gt; 1 ; ll ans = 0; if(L &lt;= mid) ans += query(L , R , l , mid , ls(Node)); if(R &gt; mid) ans += query(L , R , mid + 1 , r , rs(Node)); return ans; &#125;&#125;;struct HPD&#123; int id[maxn] , hs[maxn] , sz[maxn] , top[maxn] , f[maxn] , dep[maxn] , idx; ll v[maxn]; SegmentTree tr; void dfs1(int x , int fx) &#123; dep[x] = dep[fx] + 1; f[x] = fx; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx || !isEdge(x , v)) continue; dfs1(v , x); sz[x] += sz[v]; if(sz[v] &gt; sz[hs[x]]) hs[x] = v; &#125; &#125; void dfs2(int x , int topv) &#123; top[x] = topv; id[x] = ++idx; v[id[x]] = val[x]; if(!hs[x]) return; dfs2(hs[x] , topv); for(int i = head[x] ; i ; i = e[i].next)&#123; int ver = e[i].to; if(ver == f[x] || !isEdge(x , ver) || ver == hs[x]) continue; dfs2(ver , ver); &#125; &#125; void build()&#123; tr.build(1,n,1,v); &#125; inline ll query(int x , int y) &#123; ll ans = 0; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); ans += tr.query(id[top[x]] , id[x] , 1 , n , 1); x = f[top[x]]; &#125; if(dep[x] &lt; dep[y]) std::swap(x,y); ans += tr.query(id[y] , id[x] , 1 , n , 1); ans -= tr.query(id[y] , id[y] , 1 , n , 1); return ans; &#125; void update(int p , ll x)&#123; if(!p) return; tr.update(id[p] , 1 , n , 1 , x); &#125;&#125;forest;namespace Solve&#123; ll cirsum , cirEdis[maxn &lt;&lt; 1]; int eid[maxn &lt;&lt; 1] , bl[maxn] , cirnum; // the edge to the point bool cire[maxn &lt;&lt; 1]; // the type of points void DFS_Down(int x , int fx , ll dis , int Enum) // Enum -&gt; the real id of edge &#123; val[x] = dis; eid[Enum] = x; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx) continue; if(!isEdge(x , v)) continue; DFS_Down(v , x , e[i].dis , eref[i]); &#125; &#125; void getBelong(int x , int fx , int rt) &#123; bl[x] = rt; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx &amp;&amp; !circle[e[i].to]) getBelong(e[i].to , x , rt); &#125; inline ll q(int x , int y) &#123; if(bl[x] == bl[y])&#123; return forest.query(x,y); &#125; else&#123; ll ans = forest.query(x,y); ll tmp = forest.query(bl[x] , bl[y]); ans -= tmp; tmp = std::min(tmp , cirsum - tmp); ans += tmp; return ans; &#125; &#125; inline void upd(int x , ll y) &#123; int p = eid[x]; if(cire[x])&#123; cirsum += y - cirEdis[x]; cirEdis[x] = y; &#125; forest.update(p , y); &#125; inline void solve() &#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i)&#123; int x , y ; ll d; scanf("%d%d%lld",&amp;x,&amp;y,&amp;d); add(x,y,d) , eref[cnt] = i , add(y,x,d) , eref[cnt] = i; &#125; cir::pre();// get the circle , identify the edge to cut DFS_Down(1 , 1 , 0 , 0); // the root must be invalid !! forest.dfs1(1 , 1); forest.dfs2(1 , 1); forest.build(); for(int i = 1 ; i &lt;= n ; ++i)&#123; if(circle[i])&#123; getBelong(i , i , i); for(int j = head[i] ; j ; j = e[j].next) if(circle[e[j].to]) cire[eref[j]] = true , cirsum += e[j].dis , cirEdis[eref[j]] = e[j].dis; &#125; &#125; cirsum &gt;&gt;= 1; for(int i = 1 ; i &lt;= m ; ++i)&#123; int op ,x , z; ll y; scanf("%d",&amp;op); if(op == 1)&#123; scanf("%d%lld",&amp;x,&amp;y); upd(x,y); &#125; if(op == 2)&#123; scanf("%d%d",&amp;x,&amp;z); printf("%lld\n",q(x,z)); &#125; &#125; &#125;&#125;int main()&#123; Solve::solve();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.12]]></title>
    <url>%2F2018%2F11%2F17%2FBEF%2012%2F</url>
    <content type="text"><![CDATA[NOIp 2017 D1T3 逛公园题目描述策策同学特别喜欢逛公园。公园可以看成一张NN个点MM条边构成的有向图，且没有 自环和重边。其中1号点是公园的入口，NN号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。 策策每天都会去逛公园，他总是从1号点进去，从NN号点出来。 策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果1号点 到NN号点的最短路长为dd，那么策策只会喜欢长度不超过d + Kd+K的路线。 策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？ 为避免输出过大，答案对PP取模。 如果有无穷多条合法的路线，请输出-1−1。 输入输出格式输入格式： 第一行包含一个整数 TT, 代表数据组数。 接下来TT组数据，对于每组数据： 第一行包含四个整数 N,M,K,PN,M,K,P，每两个整数之间用一个空格隔开。 接下来MM行，每行三个整数a_i,b_i,c_iai,bi,ci，代表编号为a_i,b_iai,bi的点之间有一条权值为 c_ici的有向边，每两个整数之间用一个空格隔开。 输出格式： 输出文件包含 TT 行，每行一个整数代表答案。 输入输出样例输入样例#1： 12345678910111225 7 2 101 2 12 4 04 5 22 3 23 4 13 5 21 5 32 2 0 101 2 02 1 0 输出样例#1： 123-1 说明【样例解释1】 对于第一组数据，最短路为 33。 $1 – 5, 1 – 2 – 4 – 5, 1 – 2 – 3 – 5$ 为 33 条合法路径。 【测试数据与约定】 对于不同的测试点，我们约定各种参数的规模不会超过如下 测试点编号 TT NN MM KK 是否有0边 1 5 5 10 0 否 2 5 1000 2000 0 否 3 5 1000 2000 50 否 4 5 1000 2000 50 否 5 5 1000 2000 50 否 6 5 1000 2000 50 是 7 5 100000 200000 0 否 8 3 100000 200000 50 否 9 3 100000 200000 50 是 10 3 100000 200000 50 是 对于 100%的数据, 1 \le P \le 10^9,1 \le a_i,b_i \le N ,0 \le c_i \le 10001≤P≤109,1≤ai,bi≤N,0≤ci≤1000。数据保证：至少存在一条合法的路线。 题解表示除了30分最短路计数以外并不会这道题，这道题好难啊qwq 这道题可以dp，似乎很容易想到的一种做法是先从n跑一边单源最短路，然后设 f(i,j)表示点i比i的最短路长j的方案数，然后按照到点1的最短路长度为第一关键字 ， 拓扑序为第二关键字转移。 然后这个可以记忆化搜索。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define mp(x,y) std::make_pair((x),(y))#define pii std::pair&lt;int,int&gt;#define maxn 100005#define maxk 52int head[maxn] , d[maxn] , f[maxn][maxk] , cnt , n , m , T , k , p , cntr , h[maxn] , flag , ans;bool vis[maxn] , get[maxn][maxk];struct edge&#123; int next , to , dis;&#125;e[maxn*4] , r[maxn*4];inline void add(int x , int y , int dis)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;inline void addr(int x , int y , int dis)&#123; r[++cntr].next = h[x]; r[cntr].to = y; r[cntr].dis = dis; h[x] = cntr;&#125;inline void init()&#123; std::memset(head,0,sizeof(head)); std::memset(e,0,sizeof(e)); std::memset(r,0,sizeof(r)); std::memset(d,0,sizeof(d)); std::memset(f,-1,sizeof(f)); std::memset(h,0,sizeof(h)); cnt = 0 , cntr = 0 , flag = 0 , ans = 0; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;p); int x , y , dis; for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;dis) , add(x,y,dis) , addr(y,x,dis); // puts("OK");&#125;inline void SPDIJ(int s)&#123; std::priority_queue&lt;pii , std::vector&lt;pii&gt; , std::greater&lt;pii&gt; &gt; q; std::memset(d,0x3f,sizeof(d)); std::memset(vis,false,sizeof(vis)); d[s] = 0; q.push(mp(d[s],s)); while(!q.empty()) &#123; int k = q.top().second; q.pop(); if(vis[k]) continue; vis[k] = true; for(int i = h[k] ; i ; i = r[i].next) if(d[k] + r[i].dis &lt; d[r[i].to]) d[r[i].to] = d[k] + r[i].dis , q.push(mp(d[r[i].to] , r[i].to));//new style , warning! &#125; // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d ",d[i]); // puts("SPDIJ");&#125;int dfs(int x , int v)&#123; if(get[x][v])&#123;flag = 1 ; return 0;&#125; if(f[x][v] != -1) return f[x][v]; int ans = 0; get[x][v] = true; for(int i = head[x] ; i ; i = e[i].next) &#123; int nowv = v - (d[e[i].to] + e[i].dis - d[x]); if(nowv &gt; k || nowv &lt; 0) continue; ans = (ans + dfs(e[i].to , nowv)) % p; if(flag) return 0; &#125; get[x][v] = false; if(x == n &amp;&amp; v == 0) ++ans; return f[x][v] = ans;&#125;int main()&#123; // freopen("garden.in","r",stdin); scanf("%d",&amp;T); while(T--)&#123; init(); SPDIJ(n); // putchar(10); for(int i = 0 ; i &lt;= k ; ++i) ans += dfs(1,i), ans %= p , std::memset(get,false,sizeof(get));; // for(int i = 0 ; i &lt;= k ; ++i) // printf("%d\n",f[1][i]); if(flag) puts("-1");//the 0 rings else printf("%d\n",ans); &#125;&#125; [AHOI2009]中国象棋题目描述这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！ 输入输出格式输入格式： 一行包含两个整数N，M，之间由一个空格隔开。 输出格式： 总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。 输入输出样例输入样例#1：11 3 输出样例#1： 17 说明样例说明 除了3个格子里都塞满了炮以外，其它方案都是可行的，所以一共有222-1=7种方案。 数据范围 100%的数据中N和M均不超过100 50%的数据中N和M至少有一个数不超过8 30%的数据中N和M均不超过6 题解首先对于50分，我们可以对每行压缩状态，然后暴力跑状态压缩就可以了。 但是题目显然要求一个 n^3级别的算法，这时候我们发现，状态压缩之所以效率低是因为没有很好地利用组合数学来快速对一样的情况计数我们发现，我们每行最多填两个，也就是 1+m+C_{m}^{2}个状态这比 2^m要小得多。其次我们并不需要知道当前到底是那些列有一个，哪些列有两个。 因此我们可以用组合来优化。 设 f(i,j,k)表示前i行填完有j列1和k列2的方案数。 然后分情况来转移 确定情况 我们可以在当前第i行不放棋子. 我们可以在当前第i行放一个棋子 我们可以在当前第i行放两个棋子. 接下来就需要分类讨论这些情况. 分类讨论一.不放棋子我们可以直接继承上面的状态.即 f[i][j][k]=f[i-1][j][k]二.放一个棋子显然我们不会选择放在有两个棋子的列. 因此存在情况如下 解释：放在一个棋子的列 我们在某一个有一个棋子列放置棋子,会使这一列变为有两个棋子. 即我们要得到 f[i][j][k]需要在j+1个有一个棋子的列放置棋子,变为j个有一个棋子的列 而我们又会得到一个新的有两个棋子的列.因此我们之前必须有k-1个有两个棋子的列. 即 f[i-1][j+1][k-1]的状态可以传递给 f[i][j][k]而我们又可以在(j+1)中的任何一列放置这一个棋子. 因此我们要 \times (j+1)放在没有棋子的列 在一个没有棋子的列放置棋子,我们会得到一个新的有一个棋子的列. 即我们要从j-1得到j. 而这个时候,我们有两个棋子的列的数量不会变,所以从k传递即可. 即 f[i-1][j-1][k]的状态可以传递给 f[i][j][k]又因为我在空列中的任何一列放置这个棋子. 所以要 \times (m-(j-1)-k)三.放两个棋子这个时候情况会多一个.先请大家自己考虑一下. 这个时候存在情况如下 解释一个放在有一个棋子的列,一个放在没有棋子的列 这个时候,我们放置之后 : 一个没有棋子的列会变成一个有一个棋子的列,而一个有一个棋子的列会变成一个有两个棋子的列。 此时我们发现, 有一个棋子的列的数量不会变,因此第二维依旧为j， 又因为我们会新增一个有两个棋子的列,所以我们需要从k-1转移过来. 又因为我们可以在有一个棋子的列随便放,空列随便放. 根据乘法原理,需要 \times j \times (m-j-(k-1))都放在没有棋子的列 此时我们放置之后 会增加两个新的有一个棋子的列. 因此我们需要从j-2转移过来. 而两个棋子的列的数量并不会改变,所以依旧为k 又因为在空列中我们随便放. 根据组合数学,需要 \times C_{m-(j-2)-k}^{2}都放在有一个棋子的列 我们放置在有一个棋子的列之后： 这两个有一个棋子的列都会变成有两个子的列. 即j+2变成j，从k-2变成k 又因为这些有一个棋子的列我们随便选择. 根据组合数学,需要 \times C_{j+2}^{2} 注意细节，以及取模。 Code: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ll long long#define mod 9999973#define maxn 105ll f[maxn][maxn][maxn] , n , m;ll C(ll n)&#123; return n * (n-1) / 2;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); f[1][0][0] = 1 ; f[1][1][0] = m ; f[1][2][0] = C(m); for(int i = 2 ; i &lt;= n ; ++i) for(int j = 0 ; j &lt;= m ; ++j) for(int k = 0 ; k + j &lt;= m ; ++k) &#123; f[i][j][k] += f[i-1][j][k] , f[i][j][k] %= mod;//no one on this line //puts one if(j &gt; 0) f[i][j][k] += f[i-1][j-1][k] * (m - (j-1) - k) % mod , f[i][j][k] %= mod; // on the empty row if(j &lt; m &amp;&amp; k &gt; 0) f[i][j][k] += f[i-1][j+1][k-1] * (j + 1) % mod , f[i][j][k] %= mod; //puts two if(j &gt; 1) f[i][j][k] += f[i-1][j-2][k] * C(m - (j-2) - k) % mod , f[i][j][k] %= mod;//two empty rows if(k &gt; 0) f[i][j][k] += f[i-1][j][k-1] * j * (m - (k-1) - j) % mod , f[i][j][k] %= mod;//one&amp;empty f[i][j][k] += f[i-1][j+2][k-2] * C(j+2) % mod , f[i][j][k] %= mod; &#125; ll ans = 0; for(int i = 0 ; i &lt;= m ; ++i) for(int j = 0 ; j + i &lt;= m ; ++j) ans += f[n][i][j] , ans %= mod; printf("%lld",ans);&#125; [CQOI2016]手机号码题目描述人们选择手机号码时都希望号码好记、吉利。比如号码中含有几位相邻的相同数字、不含谐音不吉利的数字等。手机运营商在发行新号码时也会考虑这些因素，从号段中选取含有某些特征的号码单独出售。为了便于前期规划，运营商希望开发一个工具来自动统计号段中满足特征的号码数量。 工具需要检测的号码特征有两个：号码中要出现至少 33 个相邻的相同数字；号码中不能同时出现 88 和 44。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。 手机号码一定是 11 位数，前不含前导的 00。工具接收两个数 LL 和 RR，自动统计出 [L,R][L,R] 区间内所有满足条件的号码数量。LL 和 RR 也是 1111 位的手机号码。 输入输出格式输入格式： 输入文件内容只有一行，为空格分隔的 22 个正整数 L,RL,R。 输出格式： 输出文件内容只有一行，为 11 个整数，表示满足条件的手机号数量。 输入输出样例输入样例#1： 112121284000 12121285550 输出样例#1： 15 说明样例解释：满足条件的号码： 12121285000、 12121285111、 12121285222、 12121285333、 12121285550。 数据范围： 10^{10}\leq L\leq R= \lfloor k / (k/x) \rfloor = x \lfloor k/g(x) \rfloor = \lfloor k/ ( k / \lfloor k/x \rfloor ) \rfloor = \lfloor k/x \rfloor所以 \lfloor k/g(x) \rfloor = \lfloor k/x \rfloor也就是说对于 [x,g(x)] , \lfloor k/i \rfloor是相同的 而由于对于 i < \sqrt{k} , 不同取值不超过 \sqrt{k}个 对于 i > \sqrt{k}, k / i < \sqrt{k}不同取值也不会超过 \sqrt{k}个，因此整除分块时间复杂度为 O(2\sqrt{k})[CQOI2007]余数求和题目描述给出正整数n和k，计算G(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值，其中k mod i表示k除以i的余数。例如G(10, 5)=5 mod 1 + 5 mod 2 + 5 mod 3 + 5 mod 4 + 5 mod 5 …… + 5 mod 10=0+1+2+1+0+5+5+5+5+5=29 输入输出格式输入格式： 两个整数n k 输出格式： 答案 输入输出样例输入样例#1： 110 5 输出样例#1： 129 说明30%: n,k &lt;= 1000 60%: n,k &lt;= 10^6 100% n,k &lt;= 10^9 题解 \sum_{i=1}^{n}k\%i因为 k \% i = k - \lfloor k/i \rfloor * i所以原式就是 n*k - \sum_{i=1}^{n} \lfloor k/i \rfloor * i对右边整除分块优化，时间复杂度为 O(\sqrt{k})Code: 12345678910111213141516171819// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ll long longll n , k , ans;int main()&#123; scanf("%lld%lld",&amp;n,&amp;k); int gx = 0; ans = n * k; for(int i = 1 ; i &lt;= n ; i = gx + 1) &#123; gx = k/i ? std::min(k/(k/i) , n) : n; ans -= (k/i) * (i + gx) * (gx - i + 1) / 2; &#125; printf("%lld",ans);&#125; 那么还记得那道优美的题吗？请看#11 简述题意，对于任意小于n的x*y矩形，将它密铺成正方形所用的最小数量为v，求所有v的和。 显然变成一个正方形，边长得相等，设最小q个在x的方向，t个在y的方向，所用个数为t * q \frac{x}{y} = \frac{t}{q}显然当x,y约分至互质的情况时t * q最小 因此我们所求的就是 \prod_{i=1}^{n}\prod_{j=1}^{n}\frac{ij}{gcd(i,j)^2}由题目数据可知，我们要么On求出1~n的所有答案O1查询，要么对于每次查询是一个线性复杂度以下的算法。 首先看分子的处理 \prod_{i=1}^{n}\prod_{j=1}^{n}ij \prod_{i=1}^{n}i(\prod_{j=1}^{n}j)这就是 (n!)^{2n}那么我们该考虑分母的积该如何算了 , 算出来后乘上逆元即可。 \prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j)^2我们可以最后平方 (\prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j))^2我们可以用常用的数论技巧来优化 \prod_{i=1}^{n}\prod_{j=1}^{n}gcd(i,j) \prod_{k=1}^{n}k^{\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==k]}对于 \sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)==k] \sum_{i=1}^{n/k}\sum_{j=1}^{n/k}[gcd(i,j)==1]这就是 2\sum_{i=1}^{n/k}\varphi(i)-1因此每次询问的答案的分母就是 \prod_{k=1}^{n}k^{2\sum\limits_{i=1}^{n/k}\varphi(i)-1}最后的答案是 \frac{(n!)^{2n}}{(\prod_{k=1}^{n}k^{2\sum\limits_{i=1}^{n/k}\varphi(i)-1})^2}显然欧拉函数作为积性函数可以线性筛，并且只需要一次即可，然后从指数幂的特点来看再用前缀和来优化欧拉函数求和，这样复杂度是 O(n+Tnlogn)这样做期望得分60 我们可以对分子的k做一个简单的根号优化 有一个著名的结论，对于 (n/d)的取值不超过 2\sqrt{n}个，这个就不证明了挺麻烦的，进阶指南上有。 那么我们可以对于k的指数幂一样的项一起处理，这样时间复杂度就是 O(n+2T\sqrt{n}logn) \frac{(n!)^{2n}}{(\prod_{k=1}^{n}k^{2\sum\limits_{i=1}^{n/k}\varphi(i)-1})^2}补一下Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define mod 19260817#define ll long long#define maxn 1000005ll n , T , phi[maxn] , prime[maxn/8] , fac[maxn] , cnt;bool inprime[maxn];inline void euler(ll n)&#123; phi[1] = 1; for(ll i = 2 ; i &lt;= n ; ++i) &#123; if(!inprime[i]) phi[i] = i - 1 , prime[++cnt] = i; for(int j = 1 ; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n ; ++j) &#123; inprime[i*prime[j]] = true; if(!(i%prime[j])) phi[i*prime[j]] = prime[j] * phi[i]; else phi[i*prime[j]] = phi[i] * phi[prime[j]]; if(!(i%prime[j])) break; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) phi[i] += phi[i-1] ;&#125;ll exgcd(ll a , ll b , ll&amp; x , ll&amp; y)&#123; if(!b) &#123; x = 1 , y = 0; return a; &#125; ll g = exgcd(b , a % b , y , x); y -= a/b * x; return g;&#125;ll inv(ll k)&#123; if(!k || k == 1) return 1; ll x , y; ll g = exgcd(k,mod,x,y); x = (x % mod + mod) % mod; return x;&#125;inline void pre(ll n)&#123; fac[0] = fac[1] = 1; for(int i = 2 ; i &lt;= n ; ++i) fac[i] = fac[i-1] * i % mod;&#125;inline ll pow(ll x , ll y)&#123; ll ans = 1 , base = x; while(y) &#123; if(y&amp;1) ans = ans * base % mod; base = base % mod * base % mod; y /= 2; &#125; return ans;&#125;void solve(ll n)&#123; ll ans = pow(fac[n] , 2 * n); ll frac = 1; ll gx = 0; for(int i = 1 ; i &lt;= n ; i = gx + 1) &#123; gx = n/(n/i); // puts("OK"); ll pw = 2 * phi[n/i] - 1; // puts("OK"); // printf("%lld %lld\n",fac[gx] , inv(fac[i-1])); ll base = (fac[gx] % mod * inv(fac[i-1])) % mod ; // puts("OK"); // printf("pw = %lld base = %lld\n",pw,base); frac = frac * pow(base , pw) % mod; // printf("%\frac = %lld\n",frac); &#125; printf("%lld\n",ans * inv(frac) % mod * inv(frac) % mod);&#125;int main()&#123; scanf("%lld",&amp;T); euler(1000000); pre(1000000);//the fac // puts("OK"); // printf("%lld\n",fac[5] * inv(fac[3]) % mod); // printf("%lld\n",inv(fac[5])); while(T--) &#123; scanf("%lld",&amp;n); solve(n); // puts("OK"); &#125;&#125;]]></content>
      <tags>
        <tag>记忆化搜索 数位dp 整数分块 计数dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.29]]></title>
    <url>%2F2018%2F11%2F17%2FNO-29%2F</url>
    <content type="text"><![CDATA[[USACO10NOV]巧克力牛奶Chocolate Milk题目描述Farmer John’s milk production and shipping system is an intricate one! He uses milking machines for his many cows to harvest the milk that then flows into pipes. Each of these pipes connects a milking machine to a joint, where it might be joined by exactly one more pipe (the milk flowing through both pipes merges). The milk then flows through additional pipes (which all start and end at joints) until it reaches the long central pipe connecting to the distribution room. The milk then goes through a reverse process of splitting at various joints until it is flows into milk tanks that are picked up and taken to market. Farmer John notices that there is at most one way for milk to travel from one joint to any other joint. Furthermore, since Farmer John is an efficient man by nature, he has made sure that milk will flow through each and every pipe; in other words, no pipe is unneeded. If we think of a milking machine, joint, or milk tank as a node, there are N (2 &lt;= N &lt;= 100,000) nodes in total (and N-1 pipes connecting them). The input describes each pipe as an ordered pair of nodes, A_i (1 &lt;= A_i &lt;= N) and B_i (1 &lt;= B_i &lt;= N; A_i &lt; B_i) indicating milk flows from node A_i to node B_i. If there is no pipe coming in to A_i, it is a milking machine. Likewise, if no pipe goes out from B_i, it is a tank. The demand of chocolate milk has skyrocketed in recent months, and Farmer John wants to install a chocolate inserter at one of the joints so he can create delicious chocolate milk for customers. Being thrifty, Farmer John has only bought one chocolate inserter, so he wants to place it at a joint through which all the milk passes. He knows that such a joint exists. Help Farmer John find all the possible places he can install the chocolate inserter. (Note that Farmer John cannot install the chocolate inserter at the same location as a milking machine.) As an example, consider a milking setup like this one: 12345671 ----+ | v2 --&gt; 4 --&gt; 6 ------------------&gt; 7 --&gt; 8 ^ | | |3 --&gt; 5 ----+ + --&gt; 9 Visual inspection shows that the chocolate inserter can be installed at either joint 6 or 7, as all milk flows through those joints. 农民约翰的牛奶生产和运输系统是极其复杂的！他用挤奶机为他的许多奶牛收获牛奶，然后流入管道。 每一个管道连接挤奶机到一个节点，在那里它可能会加入一个管道（牛奶流过两个管道合并）。然后，牛奶流通过额外的管道（所有的开始点和结束点在其它节点上的），直到它到达一个关键的节点。 牛奶然后经过一个反向的过程，在不同的关节分裂，直到它流入牛奶罐被拾起，并送往市场。 农场主约翰注意到，牛奶从一个关节到另一个关节的方式最多。此外，由于农民约翰本质上是一个能干的人，他已经确信，牛奶会流通过每个管道；换句话说，没有管道是不必要的。 如果我们认为挤奶机，节点，或牛奶罐都看作一个节点，有N (2 &lt;= N &lt;= 100,000)节点总数（N-1个管道连接它们）。 输入描述每个管节点的有序对，A_i（1 &lt;= A_i &lt;= N）和B_i（1 &lt;= B_i &lt;= N；A_i &lt; B_i）表示牛奶从A_i流向B_i。如果A_i入度为0，它是一个挤奶机。同样，B_i出度为0，它是一个牛奶罐。 巧克力牛奶的需求已经在最近几个月急剧增加，农民约翰想安装一个巧克力插件在一个节点上，保证他能为顾客创造美味的巧克力牛奶。 为了节俭，农民约翰只买了一个巧克力插件，所以他想把它安在一个牛奶都经过的节点上。他知道这样的节点存在。 帮助农民约翰找到所有可能的地方，他将在那儿安装巧克力的插件。（注：农民约翰巧克力插件不能安装在一个挤奶机上。） 12345671 ----+ | v2 --&gt; 4 --&gt; 6 ------------------&gt; 7 --&gt; 8 ^ | | |3 --&gt; 5 ----+ + --&gt; 9 巧克力插件可以安装在6或7上，所有牛奶流经这些节点。 输入输出格式输入格式： * Line 1: A single integer: N * Lines 2..N: Line i+1 contains two space-separated integers that describe a pipe’s connectivity: A_i and B_i 第1行：一个整数：N 2到N行：包含空格分隔的两个整数描述管道的连接：A_i和B_i 输出格式： * Lines 1..??: Integers, one per line and in ascending order, each denoting a possible joint at which to install the chocolate inserter. 第1行到？？行：每行一个整数，升序排列，每个表示可以安装巧克力插件的节点。 输入输出样例输入样例#1： 1234567899 1 4 3 5 2 4 5 6 6 7 7 8 4 6 7 9 输出样例#1： 126 7 题解这题我想了个乱搞做法结果没想到是正解23333 虽然从来没学过网络流但是我看完这道题莫名其妙的想到了最大流这个我都不知道概念的东西（跟最大流没有任何关系） 考虑一种类似模拟的算法：将每台挤奶机设置一个流量，拓扑排序后平均转移流量，或者怎么分都行（差不多那种。。）因为我们只关心最大汇聚的流量是多少。 然后就交了10多遍轻松AC Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define maxn 100005int n , x , y , d[maxn];long long flow[maxn];bool vis[maxn];std::vector&lt;int&gt; e[maxn];std::queue&lt;int&gt; q;int main()&#123;// freopen("flow.in","r",stdin); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n-1 ; ++i)&#123; scanf("%d%d",&amp;x,&amp;y); e[x].push_back(y); ++d[y]; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(!d[i]) q.push(i) , flow[i] = 100000 , vis[i] = true; while(!q.empty())&#123; int k = q.front(); q.pop(); if(!e[k].size()) continue; long long rem = flow[k] - flow[k] / e[k].size();// printf("%d %d %lld\n",e[k].size() , rem , flow[k]); if(e[k].size() &gt; 1) flow[e[k][0]] += rem / 2 , flow[e[k][1]] += rem - rem / 2; else flow[e[k][0]] += rem; for(int i = 0 ; i &lt; e[k].size() ; ++i)&#123; --d[e[k][i]]; if(!d[e[k][i]]) q.push(e[k][i]); flow[e[k][i]] += flow[k] / e[k].size(); &#125; &#125; std::queue&lt;int&gt; ans; long long maxx = -0x7fffff; for(int i = 1 ; i &lt;= n ; ++i)&#123; if(flow[i] &gt; maxx)&#123; maxx = flow[i]; while(!q.empty()) q.pop(); q.push(i); &#125; else if(flow[i] == maxx)&#123; q.push(i); &#125; &#125; while(!q.empty()) &#123; if(vis[q.front()]) &#123; q.pop() ; continue; &#125; printf("%d\n",q.front()) , q.pop(); &#125; &#125; 二分图匹配找出给定二分图最大图匹配。（四种图匹配中最简单一种了） Dinic是可以的，不过联赛前不打算学这种高级算法。 使用匈牙利算法解决。 首先引入增广路概念：已匹配的边和未匹配的边在一条长度为奇数的路径中交替出现，且端点是两个未匹配的点。这条路径即是这组边集的增广路。 不断寻找增广路并取反，直到图中没有任何增广路即最大二分图匹配（berge theorem） Code： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 1005int n , cnt , m , match[maxn] , ans ,x, y , enums;bool vis[maxn] , g[maxn][maxn];bool DFS(int x)&#123; for(int i = 1 ; i &lt;= m ; ++i)&#123; if(!g[x][i] || vis[i]) continue; vis[i] = true; if(!match[i] || DFS(match[i]))&#123; match[i] = x ; return true; &#125; &#125; return false;&#125;int main()&#123;// freopen("graph.in","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;enums); for(int i = 1 ; i &lt;= enums ; ++i)&#123; scanf("%d%d",&amp;x,&amp;y) ; if (x&lt;=n&amp;&amp;y&lt;=m) g[x][y] = true; &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123; std::memset(vis,false,sizeof(vis)); if(DFS(i)) ++ans; &#125; printf("%d",ans);&#125; 这是一个较为低效的算法，复杂度为 O(nm)n与m为二分图的两边的点。 Code： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 1005int n , cnt , m , match[maxn] , ans ,x, y , enums;bool vis[maxn] , g[maxn][maxn];bool DFS(int x)&#123; for(int i = 1 ; i &lt;= m ; ++i)&#123; if(!g[x][i] || vis[i]) continue; vis[i] = true; if(!match[i] || DFS(match[i]))&#123; match[i] = x ; return true; &#125; &#125; return false;&#125;int main()&#123;// freopen("graph.in","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;enums); for(int i = 1 ; i &lt;= enums ; ++i)&#123; scanf("%d%d",&amp;x,&amp;y) ; if (x&lt;=n&amp;&amp;y&lt;=m) g[x][y] = true; &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123; std::memset(vis,false,sizeof(vis)); if(DFS(i)) ++ans; &#125; printf("%d",ans);&#125; [USACO15JAN]踩踏Stampede题目描述Farmer John’s N cows (1 &lt;= N &lt;= 50,000) appear to be stampeding along the road at the front of FJ’s farm, but they are actually just running in a foot race to see which cow is the fastest. Viewed from above, each cow is represented by a unit-length horizontal line segment, specified by the coordinates of its left corner point at time t=0. For example, (-3,6) would specify a cow who at time t=0 is represented by the segment from (-3,6) to (-2,6). Each cow is moving to the right (in the +x direction) at a certain rate, specified by the integer amount of time it takes her to move 1 unit to the right. FJ is not particularly thrilled that his cows are outside running instead of in the barn producing milk. He plans to admonish them with a stern lecture after the race ends. In order to determine which of his cows are participating in the race, FJ situates himself at (0,0) and looks along a ray extending in the +y direction. As the race unfolds, FJ sees a cow if she is ever the first cow visible along this ray. That is, a cow might not be visible if another cow is “in front” of her during the entire time she crosses FJ’s line of sight. Please compute the number of cows FJ can see during the entire race. DJ站在原点上向y轴正半轴看，然后有一群奶牛从他眼前飞过。这些奶牛初始都在第二象限，尾巴在(Xi,Yi)，头在(Xi+1,Yi)，每Ci秒向右走一个单位。 DJ能看见一匹奶牛当且仅当它身体任意某部位x坐标为0时，没有其它y坐标小于此奶牛的奶牛身体某部位x坐标为0。 问DJ能看见多少奶牛？ 输入输出格式输入格式： INPUT: (file stampede.in) The first line of the input contains N. Each of the following N lines describes a cow with three integers x y r, corresponding to a cow whose left endpoint is at (x,y) at time t=0, moving to the right at a continuous speed of 1 unit of distance every r units of time. The value of x is in the range -1000..-1, the value of y is in the range 1..1,000,000 (and distinct for every cow, to prevent any possible collisions), and the value of r is in the range 1..1,000,000. 输出格式： OUTPUT: (file stampede.out) A single integer, specifying the number of cows FJ can see during the entire race (from t=0 onward). 输入输出样例输入样例#1： 12343 -2 1 3 -3 2 3 -5 100 1 输出样例#1： 12 说明SOLUTION NOTES: FJ can see cows 1 and 2 but not cow 3. 题解没想到还左闭右开。。。我怎么读题都没读出这个意思来。 总之思路就是离散化+扫描线+线段树。也就是我们算出每头牛的时间区间，然后从下到上线段覆盖完事了。 不卡我边界我就一边AC了嘤嘤嘤 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 50005struct Node&#123; int l , r , v; bool operator &lt; (const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;p[maxn];struct Map&#123; int v , type , k; bool operator &lt; (const Map&amp; x)const&#123; return v &lt; x.v; &#125; &#125;g[maxn*2];int n , x , y , z , tot , ans;struct SegmentTree&#123; int sum[maxn&lt;&lt;3] , add[maxn&lt;&lt;3]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) inline void pushup(int Node)&#123; sum[Node] = sum[ls(Node)] + sum[rs(Node)]; &#125; inline void pushdown(int Node , int ln , int rn) &#123; if(add[Node])&#123; sum[ls(Node)] = ln; sum[rs(Node)] = rn; add[ls(Node)] = add[rs(Node)] = 1; add[Node] = 0; &#125; &#125; void update(int L , int R , int l , int r , int Node)&#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; sum[Node] = r - l + 1; add[Node] = 1; return; &#125; int mid = l + r &gt;&gt; 1; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) update(L , R , l , mid , ls(Node)); if(R &gt; mid) update(L , R , mid + 1 , r , rs(Node)); pushup(Node); &#125; int query(int L , int R , int l , int r , int Node)&#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; return sum[Node]; &#125; int mid = l + r &gt;&gt; 1 , ans = 0; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) ans += query(L , R , l , mid , ls(Node)); if(R &gt; mid) ans += query(L , R , mid + 1 , r , rs(Node)); return ans; &#125;&#125;tr;int main()&#123;// freopen("stamp.in","r",stdin); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); p[i].v = y; p[i].l = (-(1+x)) * z; p[i].r = p[i].l + z; &#125; std::sort(p+1,p+n+1); int num = 0; for(int i = 1 ; i &lt;= n ; ++i)&#123; g[++num].v = p[i].l , g[num].type = 0 , g[num].k = i; g[++num].v = p[i].r , g[num].type = 1 , g[num].k = i; &#125; std::sort(g+1,g+num+1); g[0].v = 1934537; for(int i = 1 ; i &lt;= num ; ++i)&#123; if(g[i].type)&#123; if(g[i].v == g[i-1].v)&#123; p[g[i].k].r = tot; &#125; else p[g[i].k].r = ++tot; &#125; else&#123; if(g[i].v == g[i-1].v)&#123; p[g[i].k].l = tot; &#125; else p[g[i].k].l = ++tot; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123; int l = p[i].l , r = p[i].r; int cur = tr.query(l , r - 1, 1 , tot , 1); if(cur != r - l) ++ans; tr.update(l , r - 1 , 1 , tot , 1); &#125; printf("%d",ans);&#125; [AHOI2008]紧急集合 / 聚会题目描述欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有N个等待点，有N-1条道路连接着它们，每一条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一个点到另一个点要花费一个游戏币。 参加游戏的人三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对话机（用于和同组的成员联系）。当集合号吹响后，每组成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在N个等待点中确定一个集结点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。 小可可和他的朋友邀请你一起参加这个游戏，由你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？ 输入输出格式输入格式： 第一行两个正整数N和M（N&lt;=500000，M&lt;=500000），之间用一个空格隔开。分别表示等待点的个数（等待点也从1到N进行编号）和获奖所需要完成集合的次数。 随后有N-1行，每行用两个正整数A和B，之间用一个空格隔开，表示编号为A和编号为B的等待点之间有一条路。 接着还有M行，每行用三个正整数表示某次集合前小可可、小可可的朋友以及你所在等待点的编号。 输出格式： 一共有M行，每行两个数P,C，用一个空格隔开。其中第i行表示第i次集合点选择在编号为P的等待点，集合总共的花费是C个游戏币。 输入输出样例输入样例#1： 123456789106 4 1 2 2 3 2 4 4 55 64 5 66 3 12 4 4 6 6 6 输出样例#1： 12345 22 54 16 0 说明提示： 40%的数据中N&lt;=2000，M&lt;=2000100%的数据中，N&lt;=500000，M&lt;=500000 题解一道贪心结论题。主要考察对LCA的理解，大概NOIp D1T2难度或者D2T1 显然当三点LCA相同时没有什么优化，当有且仅有一个LCA比较低，那就选这个点，最后容斥一下发现答案对于 (x,y,z)为 dep(x) + dep(y) + dep(z) - dep(LCA(x,y)) - dep(LCA(y,z)) - dep(LCA(x,z))考虑数据范围比较大（HPD好），HPD LCA即可。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005int head[maxn] , dep[maxn] , f[maxn] , top[maxn] , hs[maxn] , sz[maxn] , n , m , cnt;struct edge&#123; int next , to;&#125;e[maxn*2];inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;void dfs1(int x , int fx)&#123; f[x] = fx; dep[x] = dep[fx] + 1; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next)&#123; if(e[i].to == fx) continue; dfs1(e[i].to , x); sz[x] += sz[e[i].to]; if(sz[e[i].to] &gt; sz[hs[x]]) hs[x] = e[i].to; &#125;&#125;void dfs2(int x , int topv)&#123; top[x] = topv; if(!hs[x]) return; dfs2(hs[x] , topv); for(int i = head[x] ; i ; i = e[i].next)&#123; if(e[i].to == f[x] || e[i].to == hs[x]) continue; dfs2(e[i].to , e[i].to); &#125;&#125;int LCA(int x , int y)&#123; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); x = f[top[x]]; &#125; if(dep[x] &gt; dep[y]) std::swap(x,y); return x;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y; for(int i = 1 ; i &lt;= n - 1 ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , add(y,x); dep[1] = -1; dfs1(1,1); dfs2(1,1); int z; for(int i = 1 ; i &lt;= m ; ++i)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); int f1 = LCA(x,y) , f2 = LCA(y,z) , f3 = LCA(x,z) , f = 0; if(f1 == f2 &amp;&amp; f2 == f3)&#123; printf("%d %d\n",f1,dep[x] + dep[y] + dep[z] - 3 * dep[f1]); continue; &#125; if(dep[f1] &gt; dep[f]) f = f1; if(dep[f2] &gt; dep[f]) f = f2; if(dep[f3] &gt; dep[f]) f = f3; printf("%d %d\n",f,dep[x] + dep[y] + dep[z] - dep[f1] - dep[f2] - dep[f3]); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.36]]></title>
    <url>%2F2018%2F11%2F17%2FNO-36%2F</url>
    <content type="text"><![CDATA[NOIp 2015 D2T2 子串题目描述有两个仅包含小写英文字母的字符串 AA 和 BB。 现在要从字符串 AA 中取出 kk 个互不重叠的非空子串，然后把这 kk 个子串按照其在字符串 AA 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 BB 相等？ 注意：子串取出的位置不同也认为是不同的方案。 输入输出格式输入格式： 第一行是三个正整数 n,m,k，分别表示字符串 AA 的长度，字符串 BB 的长度，以及问题描述中所提到的 kk，每两个整数之间用一个空格隔开。 第二行包含一个长度为 nn 的字符串，表示字符串 AA。 第三行包含一个长度为 mm 的字符串，表示字符串 BB。 输出格式： 一个整数，表示所求方案数。 由于答案可能很大，所以这里要求输出答案对 1000000007 取模的结果。 输入输出样例输入样例#1： 1236 3 1 aabaab aab 输出样例#1： 12 输入样例#2： 1236 3 2 aabaab aab 输出样例#2： 17 输入样例#3： 1236 3 3 aabaab aab 输出样例#3： 17 说明对于所有 10 组数据: 1≤n≤1000,1≤m≤200,1≤k≤m题解一道非常好的计数dp题。 可惜我用将近两个小时设计出状态写出转移只有20分， 离正解很接近，觉得非常可惜。 对母串中的那一位记录选或不选才好转移。 其实我一开始思路是这样的： f(i,j,k)表示母串中用k个子串匹配到模式串第j位的方案数。 转移： 如果 A_i = B_j f(i,j,k) = \sum_{L}f(i-L,j-L,k-1) + f(i-1,j,k)不相等就去掉前面的求和式，复杂度 O(nm^2k+m^3)是可以获得70分的好成绩的。 上面那个说的就是我最初能做的。 然后我觉得很麻烦，就猜这个东西有继承性，然后只需要关注前一位，像扫描线（或者说前缀和？）一样 猜成： f(i,j,k) = f(i-1,j-1,k) + f(i-1,j-1,k-1) + f(i-1,j,k)很可惜，离正解很接近，但是是错误的，跑样例输出状态值然后自己算就能明白为什么，前一位能不能选不一定是继承所有的方案。 然后变成了20pts。。。考场上一定要写有把握有理有据的算法。 然而我居然没想到常用套路：加一维0/1表示母串当前位选不选，那样我就发现可以转移了。。 首先假设母串当前位不选，那么不管枚举到的匹配对是否相等，都有 f(i,j,k,0) = f(i-1,j,k,0) + f(i-1,j,k,1)考虑当前位相等并且选择母串当前位匹配模式串的话（用递推那种分类讨论的思想！） 当前匹配位独立出一个子串。（上一位不一定选） 当前匹配位与上一个子串合并（要求上一位必须选）。 f(i,j,k,1) = f(i-1,j-1,k-1,0) + f(i-1,j-1,k-1,1) + f(i-1,j-1,k,1)滚动数组后可AC，复杂度 O(nmk)Code: 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 1005#define maxk 205#define mod 1000000007int n , m , k;long long f[2][maxk][maxk][2];char s1[maxn] , s2[maxn];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); getchar(); scanf("%s",s1+1); scanf("%s",s2+1); for(int i = 1 ; i &lt;= n ; ++i)&#123; int now = i &amp; 1; std::memset(f[now],0,sizeof(f[now])); f[now^1][0][0][0] = 1; for(int j = 1 ; j &lt;= m ; ++j)&#123; for(int t = 1 ; t &lt;= k ; ++t)&#123; if(s1[i] == s2[j])&#123; (f[now][j][t][1] = f[now^1][j-1][t-1][0] + f[now^1][j-1][t][1] + f[now^1][j-1][t-1][1]) %= mod; (f[now][j][t][0] = f[now^1][j][t][0] + f[now^1][j][t][1]) %= mod ; &#125; else&#123; f[now][j][t][1] = 0; f[now][j][t][0] = f[now^1][j][t][1] + f[now^1][j][t][0]; &#125; &#125; &#125; &#125; printf("%lld",(f[n&amp;1][m][k][0] + f[n&amp;1][m][k][1]) % mod);&#125; NOIp 2017 D1T2 时间复杂度题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y 循环体E 其中F i x y表示新建变量 ii（变量 ii 不可与未被销毁的变量重名）并初始化为 xx， 然后判断 ii 和 yy 的大小关系，若 ii 小于等于 yy 则进入循环，否则不进入。每次循环结束后 ii 都会被修改成 i +1i+1，一旦 ii 大于 yy 终止循环。 xx 和 yy 可以是正整数（xx 和 yy 的大小关系不定）或变量 nn。nn 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100100。 “E”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“O”表示通常意义下“Θ”的概念。 输入输出格式输入格式： 输入文件第一行一个正整数 tt，表示有 tt（t \le 10t≤10）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 F i x y和E即可计算时间复杂度。注意：循环结构 允许嵌套。 接下来每个程序的第一行包含一个正整数 LL 和一个字符串，LL 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为n^wnw，其 中w是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 LL 行代表程序中循环结构中的F i x y或者 E。 程序行若以F开头，表示进入一个循环，之后有空格分离的三个字符（串）i x y， 其中 ii 是一个小写字母（保证不为nn），表示新建的变量名，xx 和 yy 可能是正整数或 nn ，已知若为正整数则一定小于 100。 程序行若以E开头，则表示循环体结束。 输出格式： 输出文件共 tt 行，对应输入的 tt 个程序，每行输出Yes或No或者ERR（输出中不包含引号），若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① F 和 E 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入输出样例输入样例#1： 复制 1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 输出样例#1： 复制 12345678YesYesERRYesNoYesYesERR 说明【输入输出样例解释1】 第一个程序 ii 从 1 到 1 是常数复杂度。 第二个程序 xx 从 1 到 nn 是 nn 的一次方的复杂度。 第三个程序有一个 F 开启循环却没有 E 结束，语法错误。 第四个程序二重循环，nn 的平方的复杂度。 第五个程序两个一重循环，nn 的一次方的复杂度。 第六个程序第一重循环正常，但第二重循环开始即终止（因为nn远大于100，100大于4）。 第七个程序第一重循环无法进入，故为常数复杂度。 第八个程序第二重循环中的变量 xx 与第一重循环中的变量重复，出现语法错误②，输出 ERR。 【数据规模与约定】 对于 30\%30%的数据：不存在语法错误，数据保证小明给出的每个程序的前 L/2L/2 行一定为以 F 开头的语句，第 L/2+1L/2+1 行至第 LL 行一定为以 EE 开头的语句，L \le 10L≤10，若 xx、yy 均 为整数，xx 一定小于 yy，且只有 yy 有可能为 nn。 对于 50\%50%的数据：不存在语法错误，L \le 100L≤100，且若 xx、yy 均为整数，xx 一定小于 yy， 且只有 yy 有可能为 nn。 对于 70\%70%的数据：不存在语法错误，L \le 100L≤100。 对于 100\%100%的数据：L \le 100L≤100。 题解这道模拟题很考验代码能力，写完之后我感觉有些地方一定要注意。 考虑到每年的NOIp都会有模拟题，而且去年难度（也就是本题）相当高。 对于大模拟，能写成函数的一定要写成函数。功能性的并且重用性高的代码一定也要写成函数。这样子就算程序会变长，但是调试会变得非常轻松！！讲真，一开始我注意这点的话，我可能在考场上两个小时之内切掉它，假如那样的话我就可以在顺利完成第一题的情况下写完第三题30分。第一天230的话啥都稳了（T3考场想不大出正解的感觉。。） 先上一开始写的狗屁不通还得了点分的程序。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define maxn 222#define INF 101010101int t , n , comp , ans , cur_ans;std::string s[maxn] , p;struct Node&#123; char var; bool valid;&#125;;std::stack&lt;Node&gt; st;bool ins[maxn];inline void print()&#123; printf("%d ",n); std::cout&lt;&lt;p; putchar(10); for(int i = 1 ; i &lt;= n ; ++i) std::cout &lt;&lt; s[i] &lt;&lt; std::endl;&#125;inline int calc()&#123; int now = 0 , ans = -1; while(now &lt; p.length())&#123; while(p[now] == ' ' || p[now] == '\n') ++now; if(now == p.length()) break; if(p[now] == 'n') ans = 1; if(p[now] &gt;= '0' &amp;&amp; p[now] &lt;= '9')&#123; if(ans == 1)&#123; ans = p[now] - 48; &#125; else ans = 0; &#125; ++now; &#125; return ans;&#125;inline bool isNum(char ch)&#123; if(ch == 'n' || (ch &gt;= '9' &amp;&amp; ch &lt;= '0')) return true; return false;&#125;inline int getNum(std::string s , int&amp; i)&#123; int x = 0; if(s[i] == 'n') return INF; while(i &lt; s.length() &amp;&amp; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + s[i] - 48; ++i; &#125; return x;&#125;inline bool Constant(int x)&#123; return x != INF;&#125;inline int getComplexity(std::string s)&#123; int ans = -1 , x1 = -1 , x2 = -1; for(int i = 0 ; i &lt; s.length() ; ++i)&#123; if(isNum(s[i]))&#123; if(!(~x1)) x1 = getNum(s,i); else x2 = getNum(s,i); &#125; &#125;// printf("%d %d\n",x1,x2); if(x1 == INF) return ans; else if(Constant(x1) &amp;&amp; Constant(x2)) return ans = 0; else return ans = 1;&#125;inline bool isVar(char ch)&#123; if(ch &gt;= 97 &amp;&amp; ch &lt;= 122) return true; return false;&#125;inline char getName(std::string s)&#123; for(int i = 0 ; i &lt; s.length() ; ++i) if(isVar(s[i])) return s[i];&#125;inline int Mark(char var)&#123; if(ins[var]) return -1; ins[var] = true; return 0;&#125;inline int Process(int num)&#123; int cur = 0 , pw = -1 , var = -1; var = getName(s[num]); pw = getComplexity(s[num]); int k = Mark(var); if(!(~k)) return -1; if(pw == -1)&#123; st.push((Node)&#123;var,false&#125;); &#125; else if(pw == 0)&#123; if(st.size() &amp;&amp; st.top().valid == false) st.push((Node)&#123;var , false&#125;); else st.push((Node)&#123;var , true&#125;); &#125; else if(pw == 1)&#123; if(st.size() &amp;&amp; st.top().valid == false) st.push((Node)&#123;var,false&#125;); else ++cur_ans , ans = std::max(ans , cur_ans) , st.push((Node)&#123;var,true&#125;); &#125; ans = std::max(ans , cur_ans); return 0;//Normal&#125;inline void Expop()&#123; if(st.top().valid == true) --cur_ans; ins[st.top().var] = false; st.pop();&#125;inline int getType(std::string s)&#123; for(int i = 0 ; i &lt; s.length() ; ++i) if(s[i] == 'F') return 1; else if(s[i] == 'E') return 0;&#125;inline void solve()&#123; int num = 1; while(num &lt;= n)&#123; int type = getType(s[num]) , judge = 0; if(type == 1) judge = Process(num); else Expop(); if(judge == -1) &#123;// from Process ans = -1 ; return ; &#125; ++num; &#125; if(!st.empty()) ans = -1;&#125;int main()&#123; scanf("%d",&amp;t); while(~(--t))&#123; std::memset(ins,false,sizeof(ins)); while(!st.empty()) st.pop(); ans = cur_ans = 0; scanf("%d",&amp;n); std::cin&gt;&gt;p; getchar(); for(int i = 1 ; i &lt;= n ; ++i) getline(std::cin,s[i]); comp = calc(); solve(); if(ans == -1)&#123; puts("ERR"); continue; &#125; if(ans == comp)&#123; puts("Yes"); &#125; else puts("No"); &#125;&#125; 考场上要头脑清醒。。 上面那个代码每一个函数都是错的。 然后上正确的代码，调试时间并不长，在考场有大样例的情况下最起码能得到80以上的分数。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define maxn 2222#define INF 101010101int t , n , comp , ans , cur_ans;std::string s[maxn] , p;struct Node&#123; char var; bool valid , is_PWD;&#125;;std::stack&lt;Node&gt; st;bool ins[maxn];inline void print()&#123; printf("%d ",n); std::cout&lt;&lt;p; putchar(10); for(int i = 1 ; i &lt;= n ; ++i) std::cout &lt;&lt; s[i] &lt;&lt; std::endl;&#125;inline int getNum(std::string s , int&amp; i)&#123; int x = 0; if(s[i] == 'n') return INF; while(i &lt; s.length() &amp;&amp; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + s[i] - 48; ++i; &#125; return x;&#125;inline bool isNum(char ch)&#123; if(ch == 'n' || (ch &lt;= '9' &amp;&amp; ch &gt;= '0')) return true; return false;&#125;inline bool Constant(int x)&#123; return x != INF;&#125;inline int calc()&#123; int now = 0 , ans = -1 , x1 = -1 , x2 = -1; for(int i = 0 ; i &lt; p.length() ; ++i)&#123; if(isNum(p[i]))&#123; if(!(~x1)) x1 = getNum(p,i); else x2 = getNum(p,i); &#125; &#125; if(Constant(x1)) return 0; else return x2; return ans;&#125;inline int getComplexity(std::string s)&#123; int ans = -1 , x1 = -1 , x2 = -1; for(int i = 0 ; i &lt; s.length() ; ++i)&#123; if(isNum(s[i]))&#123; if(!(~x1)) x1 = getNum(s,i); else x2 = getNum(s,i); &#125; &#125; if(x1 &gt; x2) return -1; if(x1 == INF &amp;&amp; x2 == INF) return 0; if(Constant(x1) &amp;&amp; Constant(x2)) return 0; else return ans = 1;&#125;inline bool isVar(char ch)&#123; if(ch &gt;= 97 &amp;&amp; ch &lt;= 122) return true; return false;&#125;inline char getName(std::string s)&#123; for(int i = 0 ; i &lt; s.length() ; ++i) if(isVar(s[i])) return s[i];&#125;inline int Mark(char var)&#123; if(ins[var]) return -1; ins[var] = true; return 0;&#125;inline int Process(int num)&#123; int cur = 0 , pw = -1 , var = -1; var = getName(s[num]); pw = getComplexity(s[num]); int k = Mark(var); if(!(~k)) return -1; if(pw == -1)&#123; st.push((Node)&#123;var,false,false&#125;); &#125; else if(pw == 0)&#123; if(st.size() &amp;&amp; st.top().valid == false) st.push((Node)&#123;var , false , false&#125;); else st.push((Node)&#123;var , true , false&#125;); &#125; else if(pw == 1)&#123; if(st.size() &amp;&amp; st.top().valid == false) st.push((Node)&#123;var,false,false&#125;); else ++cur_ans , ans = std::max(ans , cur_ans) , st.push((Node)&#123;var,true,true&#125;); &#125; ans = std::max(ans , cur_ans); return 0;//Normal&#125;inline int Expop()&#123; if(st.empty()) return -1; if(st.top().valid == true &amp;&amp; st.top().is_PWD == true) --cur_ans; ins[st.top().var] = false; st.pop(); return 0;&#125;inline int getType(std::string s)&#123; for(int i = 0 ; i &lt; s.length() ; ++i) if(s[i] == 'F') return 1; else if(s[i] == 'E') return 0;&#125;inline void solve()&#123; int num = 1; while(num &lt;= n)&#123; int type = getType(s[num]) , judge = 0; if(type == 1) judge = Process(num); else judge = Expop(); if(judge == -1) &#123;// from Process ans = -1 ; return ; &#125; ++num; &#125; if(!st.empty()) ans = -1;&#125;int main()&#123;// freopen("time.in","r",stdin); scanf("%d",&amp;t); while(~(--t))&#123; std::memset(ins,false,sizeof(ins)); while(!st.empty()) st.pop(); ans = cur_ans = 0; scanf("%d",&amp;n); std::cin&gt;&gt;p; getchar(); for(int i = 1 ; i &lt;= n ; ++i) getline(std::cin,s[i]); comp = calc(); solve();// print(); if(ans == -1)&#123; puts("ERR"); continue; &#125; if(ans == comp)&#123; puts("Yes"); &#125; else puts("No"); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.39]]></title>
    <url>%2F2018%2F11%2F17%2FNO-39%2F</url>
    <content type="text"><![CDATA[P5002 专心OI - 找祖先题目背景最后一个点15ptsImakf是一个小蒟蒻，他最近刚学了LCA，他在手机APP里看到一个游戏也叫做LCA就下载了下来。 题目描述这个游戏会给出你一棵树，这棵树有NN个节点，根结点是RR，系统会选中MM个点P_1,P_2…P_MP1,P2…PM，要Imakf回答有多少组点对(u_i,v_i)(ui,vi)的最近公共祖先是P_iPi。Imakf是个小蒟蒻，他就算学了LCA也做不出，于是只好求助您了。 Imakf毕竟学过一点OI,所以他允许您把答案模 (10^9+7)(109+7) 输入输出格式输入格式： 第一行 N , R , MN,R,M 此后N-1N−1行 每行两个数a,ba,b 表示a,ba,b之间有一条边 此后11行 MM个数 表示P_iPi 输出格式： MM行，每行一个数，第ii行的数表示有多少组点对(u_i,v_i)(ui,vi)的最近公共祖先是P_iPi 输入输出样例输入样例#1： 123456787 1 31 21 32 42 53 63 71 2 4 输出样例#1： 1233171 说明 N\leq10000,M\leq50000 题解一道D1T1水平的结论题成功找错结论调了半天。 我连最基本的组合数学都不会了呢。 今天上午的考试大概也是彻底失望了。 假如一道编程复杂度很小的结论题出现错误，请检查结论是否有误而不是调试程序以及尽量把结论化简，往往能看出你的错误 f(x) = sum(son)^2 - \sum_{son}sz(son)^2 + 2 * sz(x) - 1Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005#define ll long long#define mod 1000000007int n , m , rt , head[maxn] , cnt;struct edge&#123; int next , to ;&#125;e[maxn*2]; ll f[maxn] , sz[maxn] , sq[maxn];inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;void dfs(int x , int fx)&#123; sz[x] = 1 ; int chd = 0; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx) continue; dfs(v , x); ++chd; sz[x] += sz[e[i].to]; sq[x] += sz[e[i].to] * sz[e[i].to]; &#125; f[x] += (sz[x] &lt;&lt; 1) - 1; f[x] += ((sz[x] - 1) * (sz[x] - 1)) - sq[x];&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;rt,&amp;m); for(int i = 1 ; i &lt;= n - 1 ; ++i)&#123; int x , y; scanf("%d%d",&amp;x,&amp;y); add(x,y) , add(y,x); &#125; dfs(rt,rt); for(int i = 1 ; i &lt;= m ; ++i)&#123; int x; scanf("%d",&amp;x); printf("%lld\n",f[x] % mod); &#125;&#125; P5004 专心OI - 跳房子题目背景数据已经重做Imakf有一天参加了PINO 2017 PJ组，他突然看见最后一道题 他十分蒟蒻，写不出来 而如今他还是一个蒟蒻，他又看见一道题 他还是写不出来，于是便来请教您 题目描述您有NN个格子，排成一行，从左往右编号为1,2,…,N1,2,…,N。您站在11号格子的左边，开始从左往右跳，跳到NN号格子右侧为止。由于您是一位成功的OIerOIer，您自然长得很胖，但您的力量也非常大！这使得您跳一次，当前格子到目标格子中间必须至少空出来MM格，但您可以跳无数格远！ 您认为这么跳太没意思了，于是便想计算出有多少种方案可以跳完全程。由于方案可能过多，您会输出方案数量模(10^9+7)(109+7)的值 方案指经过格子编号的顺序不同，具体可见说明 题目简化一下……把NN个无色格子排成一行，可以把某些格子染成黑色，但两个黑色格子之间必须至少有MM个无色格子，求方案数 输入输出格式输入格式： 第一行 N,MN,M 输出格式： 跳完全程的方案模(10^9+7)(109+7) 输入输出样例输入样例#1： 15 1 输出样例#1： 113 输入样例#2： 16 2 输出样例#2： 113 样例一 样例二 绿色格子为您站在上面过的格子 对于100%的数据： n]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.28]]></title>
    <url>%2F2018%2F11%2F17%2FNO-28%2F</url>
    <content type="text"><![CDATA[[USACO06DEC]牛的过山车Cow Roller Coaster题目描述The cows are building a roller coaster! They want your help to design as fun a roller coaster as possible, while keeping to the budget. The roller coaster will be built on a long linear stretch of land of length L (1 ≤ L ≤ 1,000). The roller coaster comprises a collection of some of the N (1 ≤ N ≤ 10,000) different interchangable components. Each component i has a fixed length Wi (1 ≤ Wi ≤ L). Due to varying terrain, each component i can be only built starting at location Xi (0 ≤ Xi ≤ L - Wi). The cows want to string together various roller coaster components starting at 0 and ending at L so that the end of each component (except the last) is the start of the next component. Each component i has a “fun rating” Fi (1 ≤ Fi ≤ 1,000,000) and a cost Ci (1 ≤ Ci ≤ 1000). The total fun of the roller coster is the sum of the fun from each component used; the total cost is likewise the sum of the costs of each component used. The cows’ total budget is B (1 ≤ B ≤ 1000). Help the cows determine the most fun roller coaster that they can build with their budget. 奶牛们正打算造一条过山车轨道．她们希望你帮忙，找出最有趣，但又符合预算 的方案． 过山车的轨道由若干钢轨首尾相连，由x=0处一直延伸到X=L(1≤L≤1000)处．现有N(1≤N≤10000)根钢轨，每根钢轨的起点 Xi(0≤Xi≤L- Wi)，长度wi(l≤Wi≤L)，有趣指数Fi(1≤Fi≤1000000)，成本Ci(l≤Ci≤1000)均己知．请确定一 种最优方案，使得选用的钢轨的有趣指数之和最大，同时成本之和不超过B(1≤B≤1000)． 输入输出格式输入格式： Line 1: Three space-separated integers: L, N and B. Lines 2..N+1: Line i+1 contains four space-separated integers, respectively: Xi, Wi, Fi, and Ci. 输出格式： Line 1: A single integer that is the maximum fun value that a roller-coaster can have while staying within the budget and meeting all the other constraints. If it is not possible to build a roller-coaster within budget, output -1. 输入输出样例输入样例#1： 12345675 6 100 2 20 62 3 5 60 1 2 11 1 1 31 2 5 43 2 10 2 输出样例#1： 117 说明Taking the 3rd, 5th and 6th components gives a connected roller-coaster with fun value 17 and cost 7. Taking the first two components would give a more fun roller-coaster (25) but would be over budget. 题解今天一觉睡到8点半，迷迷糊糊来到机房开了这道题随手写了个01背包结果华丽爆零 这道题的状态当然要带上位置（一看位置那么小就是dp的一维嘛） Code： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define maxn 10005#define maxm 1005#define INF 0x3fffffffint f[maxm][maxm] , n , l , m;struct Node&#123; int x , len , c , w; bool operator &lt; (const Node&amp; g)const&#123; return x &lt; g.x; &#125;&#125;p[maxn];std::vector&lt;Node&gt; q[maxm];int main()&#123; scanf("%d%d%d",&amp;l,&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d%d%d",&amp;p[i].x,&amp;p[i].len,&amp;p[i].c,&amp;p[i].w) , q[p[i].x + p[i].len].push_back(p[i]); std::sort(p+1,p+n+1); for(int i = 1 ; i &lt;= l ; ++i) for(int j = 1 ; j &lt;= m ; ++j) f[i][j] = -INF; f[0][0] = 0; for(int i = 1 ; i &lt;= l ; ++i)&#123; for(int j = m ; j &gt;= 1 ; --j) for(int k = 0 ; k &lt; q[i].size() ; ++k)&#123; if(q[i][k].w &gt; j) continue; if(f[i-q[i][k].len][j-q[i][k].w] == -INF) continue; f[i][j] = std::max(f[i][j] , f[i-q[i][k].len][j-q[i][k].w] + q[i][k].c); &#125; &#125; if(f[l][m] == -INF)&#123; puts("-1");return 0; &#125; printf("%d\n",f[l][m]);&#125; P2194 HXY烧情侣题目描述众所周知，HXY已经加入了FFF团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。这里有n座电影院，n对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。m条单向通道连接相邻的两对情侣所在电影院。然后HXY有个绝技，如果她能从一个点开始烧，最后回到这个点，那么烧这条回路上的情侣的费用只需要该点的汽油费即可。并且每对情侣只需烧一遍，电影院可以重复去。然后她想花尽可能少的费用烧掉所有的情侣。问最少需要多少费用，并且当费用最少时的方案数是多少？由于方案数可能过大，所以请输出方案数对1e9+7取模的结果。 （注：这里HXY每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY自行选择顶点进行烧情侣行动。且走过的道路可以重复走。） 输入输出格式输入格式： 第一行，一个整数n。 第二行，n个整数，表示n个情侣所在点的汽油费。 第三行，一个整数m。 接下来m行，每行两个整数xi，yi，表示从点xi可以走到yi。 输出格式： 一行，两个整数，第一个数是最少费用，第二个数是最少费用时的方案数对1e9+7取模 输入输出样例输入样例#1： 复制 12345631 2 331 22 33 2 输出样例#1： 复制 13 1 输入样例#2： 1234567310 20 1041 21 33 12 1 输出样例#2： 110 2 说明数据范围： 对于30%的数据，1&lt;=n，m&lt;=20； 对于10%的数据，保证不存在回路。 对于100%的数据，1&lt;=n&lt;=100000，1&lt;=m&lt;=300000。所有输入数据保证不超过10^9。 题解思考后不难发现每个scc的代价是最小值，方案数是所有scc的最小值的数目相乘。 一开始我还准备建新图dp，后来想了想转移方程发现就是相乘。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#define mod 1000000007#define maxn 100005#define maxm 300005int head[maxn] , cnt , tot[maxn] , idx , dfn[maxn] , low[maxn] , scct , scc[maxn] , v[maxn] , x, y , n , m , f[maxn] , g[maxn] , d[maxn];long long ans1 , ans2 = 1 ;bool ins[maxn];std::map&lt;int , bool&gt; rep[maxn];struct edge&#123; int next , to;&#125;e[maxm*2];struct Node&#123; int fr , to;&#125;er[maxm*2];inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt; ++d[y];&#125;std::stack&lt;int&gt; st;void Tarjan(int x)&#123; dfn[x] = low[x] = ++idx; st.push(x); ins[x] = true; for(int i = head[x] ; i ; i = e[i].next)&#123; if(!dfn[e[i].to])&#123; Tarjan(e[i].to); low[x] = std::min(low[x] , low[e[i].to]); &#125; else if(ins[e[i].to]) low[x] = std::min(low[x] , dfn[e[i].to]); &#125; if(dfn[x] == low[x]) &#123; ++scct; int minn = 0x7f7ffff , count = 1; while(st.top() != x) &#123; if(v[st.top()] &lt; minn)&#123; minn = v[st.top()]; count = 1; &#125; else if(v[st.top()] == minn)&#123; ++count; &#125; scc[st.top()] = scct; ins[st.top()] = false; st.pop(); &#125; //last element judge if(v[st.top()] &lt; minn)&#123; minn = v[st.top()]; count = 1; &#125; else if(v[st.top()] == minn)&#123; ++count; &#125; scc[st.top()] = scct; ins[st.top()] = false; st.pop(); //final update f[scct] = minn , g[scct] = count; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); scanf("%d",&amp;m); int mtr = 0; for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , er[++mtr].fr = x , er[mtr].to = y; for(int i = 1 ; i &lt;= n ; ++i)&#123; if(dfn[i]) continue; while(!st.empty()) st.pop(); Tarjan(i); &#125; for(int i = 1 ; i &lt;= scct ; ++i) ans1 += f[i] , (ans2 *= g[i]) %= mod; printf("%lld %lld\n",ans1,ans2);// std::memset(e,0,sizeof(e));// std::memset(head,0,sizeof(head));// std::memset(d,0,sizeof(d));// cnt = 0;// for(int i = 1 ; i &lt;= mtr ; ++i)&#123;// int u = er[i].fr , v = er[i].to;// if(!vis[scc[u]][scc[v]])&#123;// add(scc[u] , scc[v]);// vis[scc[u]][scc[v]] = true;// &#125;// &#125; &#125; NOIp 2016 D1T3 换教室题目描述对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。 在可以选择的课程中，有 2n2n 节课程安排在 nn 个时间段上。在第 ii（1 \leq i \leq n1≤i≤n）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 c_ici 上课，而另一节课程在教室 d_idi 进行。 在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 nn 节安排好的课程。如果学生想更换第 ii 节课程的教室，则需要提出申请。若申请通过，学生就可以在第 ii 个时间段去教室 d_idi 上课，否则仍然在教室 c_ici 上课。 由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 ii 节课程的教室时，申请被通过的概率是一个已知的实数 k_iki，并且对于不同课程的申请，被通过的概率是互相独立的。 学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 mm 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的 mm 门课程，也可以不用完这 mm 个申请的机会，甚至可以一门课程都不申请。 因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。 牛牛所在的大学有 vv 个教室，有 ee 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。 当第 ii（1 \leq i \leq n-11≤i≤n−1）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。 现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 输入输出格式输入格式： 第一行四个整数 n,m,v,en,m,v,e。nn 表示这个学期内的时间段的数量；mm 表示牛牛最多可以申请更换多少节课程的教室；vv 表示牛牛学校里教室的数量；ee表示牛牛的学校里道路的数量。 第二行 n 个正整数，第 i（1 \leq i \leq n1≤i≤n）个正整数表示 c_ici，即第 ii 个时间段牛牛被安排上课的教室；保证 1 \le c_i \le v1≤ci≤v。 第三行 n 个正整数，第 i（1 \leq i \leq n1≤i≤n）个正整数表示 d_idi，即第 ii 个时间段另一间上同样课程的教室；保证 1 \le d_i \le v1≤di≤v。 第四行 n 个实数，第 i（1 \leq i \leq n1≤i≤n）个实数表示 k_iki，即牛牛申请在第 ii 个时间段更换教室获得通过的概率。保证 0 \le k_i \le 10≤ki≤1。 接下来 e 行，每行三个正整数 a_j, b_j, w_j，表示有一条双向道路连接教室 a_j, b_j，通过这条道路需要耗费的体力值是 w_jwj；保证 1 \le a_j, b_j \le 300， 1 \le w_j \le 300保证 1 \leq n \leq 2000，0 \leq m \leq 2000，1 \leq v \leq 300，0 \leq e \leq 90000保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。 保证输入的实数最多包含 33 位小数。 输出格式： 输出一行，包含一个实数，四舍五入精确到小数点后恰好22位，表示答案。你的输出必须和标准输出完全一样才算正确。 测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于 4 \times 10^{-3}4×10−3。 （如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理） 输入输出样例输入样例#1： 12345673 2 3 32 1 21 2 10.8 0.2 0.5 1 2 51 3 32 3 1 输出样例#1： 12.80 说明【样例1说明】 所有可行的申请方案和期望收益如下表: 【提示】 道路中可能会有多条双向道路连接相同的两间教室。 也有可能有道路两端连接的是同一间教室。 请注意区分n,m,v,e的意义, n不是教室的数量, m不是道路的数量。 特殊性质1:图上任意两点 a_iai, b_ibi, a_iai≠ b_ibi间,存在一条耗费体力最少的路径只包含一条道路。 特殊性质2:对于所有的 1≤ i≤ n1≤i≤n， k_i= 1ki=1 。 题解是个很sb的概率期望dp 然而我一开始读错了题 状态设计： f(i,j,0/1)表示前i个课程申请了j次，当前申不申请。 转移傻逼组合合并期望，不写了（巨麻烦） Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 305#define maxm 2005#define INF 9999999int n , m , p , enums , dis[maxn][maxn] , c[maxm] , d[maxm];double k[maxm] , f[maxm][maxm][2];int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;enums); std::memset(dis,0x3f,sizeof(dis)); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;c[i]); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;d[i]); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lf",&amp;k[i]); int x , y , curd; for(int i = 1 ; i &lt;= enums ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;curd) , dis[x][y] = dis[y][x] = std::min(dis[x][y] , curd); for(int k = 1 ; k &lt;= p ; ++k) for(int i = 1 ; i &lt;= p ; ++i) for(int j = 1 ; j &lt;= p ; ++j) dis[i][j] = std::min(dis[i][k] + dis[k][j] , dis[i][j]); for(int i = 1; i &lt;= p ; ++i) dis[i][i] = 0; for(int i = 0 ; i &lt;= n ; ++i) for(int j = 0 ; j &lt;= m ; ++j) f[i][j][0] = f[i][j][1] = INF; f[1][1][1] = 0 , f[1][0][0] = 0; for(int i = 2 ; i &lt;= n ; ++i)&#123; f[i][0][0] = f[i-1][0][0] + dis[c[i]][c[i-1]]; for(int j = 1 ; j &lt;= std::min(i,m); ++j)&#123; f[i][j][0] = std::min(f[i][j][0] , f[i-1][j][0] + dis[c[i]][c[i-1]]); f[i][j][0] = std::min(f[i][j][0] , f[i-1][j][1] + k[i-1] * dis[c[i]][d[i-1]] + (1-k[i-1]) * dis[c[i]][c[i-1]]); f[i][j][1] = std::min(f[i][j][1] , f[i-1][j-1][0] + k[i] * dis[d[i]][c[i-1]] + (1-k[i]) * dis[c[i]][c[i-1]]); f[i][j][1] = std::min(f[i][j][1] , f[i-1][j-1][1] + k[i]*k[i-1]*dis[d[i]][d[i-1]] + k[i]*(1-k[i-1])*dis[d[i]][c[i-1]] + (1-k[i])*k[i-1]*dis[c[i]][d[i-1]] + (1-k[i]) * (1-k[i-1]) * dis[c[i]][c[i-1]]); &#125; &#125; double ans = 9999999; for(int i = 0 ; i &lt;= m ; ++i) ans = std::min(ans , std::min(f[n][i][0] , f[n][i][1])); printf("%.2lf",ans);&#125; 卢卡斯定理 其中： 并且 是m和n的p进制展开。当m &lt; n时，二项式系数 {\displaystyle {\tbinom {m}{n}}=0}时间复杂度应该是 O(plogp)证明对于素数p和n，满足1≤n≤p-1, 二项式系数 可被p整除。由此可得，在母函数中 应用数学归纳法可证，对于任意非负整数i，有 对于任意非负整数m和素数p，将m用p进制表示,注意到 证明好复杂。。 然后是Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define LL long longLL n,m,Mod;LL fast_pow(LL a,LL p)&#123; LL ans=1LL; for (;p;p&gt;&gt;=1,a=a*a%Mod) if (p&amp;1) ans=ans*a%Mod; return ans;&#125;LL inv(LL x)&#123; return fast_pow(x,Mod-2);&#125;LL C(LL n,LL m)&#123; if (m&gt;n) return 0LL; LL up=1LL,down=1LL; for (LL i=n-m+1;i&lt;=n;++i) up=up*i%Mod; for (LL i=1;i&lt;=m;++i) down=down*i%Mod; return up*inv(down)%Mod;&#125;LL lucas(LL n,LL m)&#123; if (m&gt;n) return 0LL; LL ans=1; for (;m;n/=Mod,m/=Mod) ans=ans*C(n%Mod,m%Mod)%Mod; return ans;&#125;int main()&#123; while (~scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;Mod)) printf("%lld\n",lucas(n-m+1,m));&#125;--------------------- 作者：Clove_unique 然后这个东西必须模数互质，和crt一样没用，所以我们有了 EXLUKAS暂时没看懂，以后再说。 Cantor Expansion是个很基础的东西了。 展开公式 一个n^2的计算过程，看上去没什么卵用。 如n=5,x=96时： 1234567首先用96-1得到95，说明x之前有95个排列.(将此数本身减去1)用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.用5去除2!得到2余1，类似地，这一位是3.用1去除1!得到1余0，这一位是2.最后一位只能是1.所以这个数是45321. 逆运算也没了，就这样。 [USACO11FEB]牛线Cow Line题目背景征求翻译。如果你能提供翻译或者题意简述，请直接发讨论，感谢你的贡献。 题目描述The N (1 &lt;= N &lt;= 20) cows conveniently numbered 1…N are playing yet another one of their crazy games with Farmer John. The cows will arrange themselves in a line and ask Farmer John what their line number is. In return, Farmer John can give them a line number and the cows must rearrange themselves into that line. A line number is assigned by numbering all the permutations of the line in lexicographic order. Consider this example: Farmer John has 5 cows and gives them the line number of 3. The permutations of the line in ascending lexicographic order: 1st: 1 2 3 4 5 2nd: 1 2 3 5 4 3rd: 1 2 4 3 5 Therefore, the cows will line themselves in the cow line 1 2 4 3 5. The cows, in return, line themselves in the configuration ‘1 2 5 3 4’ and ask Farmer John what their line number is. Continuing with the list: 4th : 1 2 4 5 3 5th : 1 2 5 3 4 Farmer John can see the answer here is 5 Farmer John and the cows would like your help to play their game. They have K (1 &lt;= K &lt;= 10,000) queries that they need help with. Query i has two parts: C_i will be the command, which is either ‘P’ or ‘Q’. If C_i is ‘P’, then the second part of the query will be one integer A_i (1 &lt;= A_i &lt;= N!), which is a line number. This is Farmer John challenging the cows to line up in the correct cow line. If C_i is ‘Q’, then the second part of the query will be N distinct integers B_ij (1 &lt;= B_ij &lt;= N). This will denote a cow line. These are the cows challenging Farmer John to find their line number. N(1&lt;=N&lt;=20)头牛，编号为1…N，正在与FJ玩一个疯狂的游戏。奶牛会排成一行（牛线），问FJ此时的行号是多少。之后，FJ会给牛一个行号，牛必须按照新行号排列成线。 行号是通过以字典序对行的所有排列进行编号来分配的。比如说：FJ有5头牛，让他们排为行号3，排列顺序为： 1：1 2 3 4 5 2：1 2 3 5 4 3：1 2 4 3 5 因此，牛将在牛线1 2 4 3 5中。 之后，奶牛排列为“1 2 5 3 4”，并向FJ问他们的行号。继续列表： 4：1 2 4 5 3 5：1 2 5 3 4 FJ可以看到这里的答案是5。 FJ和奶牛希望你的帮助玩他们的游戏。他们需要K(1&lt;=K&lt;=10000)组查询，查询有两个部分：C_i将是“P”或“Q”的命令。 如果C_i是’P’，则查询的第二部分将是一个整数A_i（1 &lt;= A_i &lt;= N！），它是行号。此时，你需要回答正确的牛线。 如果C_i是“Q”，则查询的第二部分将是N个不同的整数B_ij（1 &lt;= B_ij &lt;= N）。这将表示一条牛线，此时你需要输出正确的行号。 输入输出格式输入格式： * Line 1: Two space-separated integers: N and K * Lines 2..2K+1: Line 2i and 2*i+1 will contain a single query. Line 2*i will contain just one character: ‘Q’ if the cows are lining up and asking Farmer John for their line number or ‘P’ if Farmer John gives the cows a line number. If the line 2i is ‘Q’, then line 2i+1 will contain N space-separated integers B_ij which represent the cow line. If the line 2i is ‘P’, then line 2i+1 will contain a single integer A_i which is the line number to solve for. 输出格式： * Lines 1..K: Line i will contain the answer to query i. If line 2i of the input was ‘Q’, then this line will contain a single integer, which is the line number of the cow line in line 2i+1. If line 2i of the input was ‘P’, then this line will contain N space separated integers giving the cow line of the number in line 2i+1. 输入输出样例输入样例#1： 123455 2 P 3 Q 1 2 5 3 4 输出样例#1： 121 2 4 3 5 5 说明题解cantor展开的模板题。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 21long long n , q , x , qr[maxn];bool vis[maxn];char ch;inline long long fac(long long x)&#123; long long ans = 1; for(int i = 1 ; i &lt;= x ; ++i) ans *= i; return ans ;&#125;inline void cantor(long long x)&#123; --x; std::memset(vis,false,sizeof(vis)); for(int i = 1 ; i &lt;= n ; ++i)&#123; int cur = x / fac(n-i) , j; for(j = 1 ; j &lt;= n; ++j)&#123; if(!vis[j])&#123; if(!cur) break; --cur; &#125; &#125; vis[j] = true; printf("%d ",j); x %= fac(n-i); &#125; putchar(10);&#125;inline long long revcantor()&#123; long long ans = 0; for(int i = 1 ; i &lt;= n ; ++i)&#123; int rank = 0; for(int j = i + 1 ; j &lt;= n ; ++j)&#123; if(qr[i] &gt; qr[j]) ++rank; &#125; ans += 1ll * fac(1ll*(n-i)) * rank; &#125; return ans + 1; &#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;q); for(int i = 1 ; i &lt;= q ; ++i) &#123; std::cin&gt;&gt;ch; if(ch == 'P')&#123; scanf("%lld",&amp;x); cantor(x); &#125;else&#123; for(int j = 1 ; j &lt;= n ; ++j) scanf("%lld",&amp;qr[j]); std::cout &lt;&lt; revcantor() &lt;&lt; std::endl; &#125; &#125;&#125; [USACO11OPEN]学习语言Learning Languages题目描述Farmer John’s N (2 &lt;= N &lt;= 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 &lt;= M &lt;= 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in K_i (1 &lt;= K_i &lt;= M) languages, namely L_i1, L_i2,…, L_{iK_i} (1 &lt;= L_ij &lt;= M). FJ’s cows aren’t THAT smart, so the sum of K_i over all cows i is at most 100,000. Two cows can’t directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows T_1, T_2, …, T_k such that A and T_1 share a language, T_1 and T_2 share a language, etc., and T_k and B share a language. Farmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine: * The minimum number of books he must purchase * Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output. By way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone. 1 #2 #3Alberta x x Bessie x Contessa x FJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another. Note that an alternate solution exists: instead, FJ could buy Contessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted. 农夫约翰的N（2&lt;=N&lt;=10,000）只奶牛标号为1..N，同样的有M（1&lt;=M&lt;=30,000）种牛语标号为1..M，第i只奶牛会说K_i（1&lt;=K_i&lt;=M）种牛语，分别为L_i1，L_i2，…，L_{iK_i}（1&lt;=L_ij&lt;=M），农夫的奶牛不是特别聪明，所以K_i的累加和不大于100,000。 两只奶牛只有当他们至少有一门语言一样的时候才可以沟通。否则这两只奶牛就需要别人来帮他们翻译才能交流。换句话说，A和B要进行沟通，他们可以通过T_1，T_2，…，T_k来传递，比如A和T_1，T_1和T_2，…，T_k和B进行交流。 农夫希望他的奶牛可以多多沟通，所以他买了很多课本去教她的奶牛语言。当然农夫非常的吝啬，他希望买最少的书就可以让所有的奶牛可以交流。你的任务就是帮他算出最少需要买几本书。 输入输出格式输入格式： * Line 1: Two space-separated integers: N and M * Lines 2..N+1: Line i+1 describes the languages that cow i can speak with (K_i)+1 space-separated integers: K_i, L_i1, L_i2,…,L_i{K_i}. 输出格式： * Line 1: A single integer that is the minimum number of books that FJ must purchase. * Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one. 输入输出样例输入样例#1： 12343 3 2 3 2 1 2 1 1 输出样例#1： 121 2 3 题解一道很不错的并查集的题。 我们把没头奶牛合并到每种语言，同一个集合内的奶牛就能互相交流=并查集。 注意不要把并查集写疵了。 Code： 12 P1868 饥饿的奶牛题目描述有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。 现用汉语翻译为： 有N个区间，每个区间x，y表示提供的x~y共y-x+1堆优质牧草。你可以选择任意区间但不能有重复的部分。 对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。 输入输出格式输入格式： 第一行，N，如题 接下来N行，每行一个数x，y，如题 输出格式： 一个数，最多能吃到的牧草堆数 输入输出样例输入样例#1： 123431 37 83 4 输出样例#1： 15 说明1&lt;=n&lt;=150000 0&lt;=x&lt;=y&lt;=3000000 题解这个题以前我写过 O(n^2)的dp。 那个题我是直接找当前区间前的和本区间不相交的最大f值。 但是这道题显然不能这么做了。 然后我们可以按照右端点排序，然后在当前区间我们二分一个右端点小于当前区间左端点的最大的f值。 但是假如状态设计为以第i个区间结尾的最优值不能保证二分的状态值最大。 所以我们每次继承上一次的状态值就保证单调不降了，状态的含义应该修改成以前i个区间结尾的最大答案。 Code： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 200005struct Node&#123; int l , r , val; bool operator &lt; (const Node&amp; x)const &#123; return r &lt; x.r; &#125;&#125;p[maxn];int n , f[maxn] , ans;int find(int x)&#123; int l = 0 , r = n , ans = 0; while(l &lt;= r)&#123; int mid = l + r &gt;&gt; 1; if(p[mid].r &lt; x) ans = mid , l = mid + 1; else r = mid - 1; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].l,&amp;p[i].r) , p[i].val = p[i].r - p[i].l + 1; std::sort(p+1,p+n+1); for(int i = 1 ; i &lt;= n ; ++i)&#123; f[i] = f[i-1]; int j = find(p[i].l); f[i] = std::max(f[i] , f[j] + p[i].val); &#125; for(int i = 1 ; i &lt;= n ; ++i) ans = std::max(ans , f[i]); printf("%d",ans);&#125; [USACO06NOV]糟糕的一天Bad Hair Day题意翻译农夫约翰有N (N \leq 80000)N(N≤80000)头奶牛正在过乱头发节。每一头牛都站在同一排面朝东方，而且每一头牛的身高为h_ihi。第NN头牛在最前面，而第11头牛在最后面。 对于第ii头牛前面的第jj头牛，如果h_i&gt;h_{i+1}hi&gt;hi+1并且h_i&gt;h_{i+2}hi&gt;hi+2 \cdots⋯ h_i&gt;h_jhi&gt;hj，那么认为第ii头牛可以看到第i+1i+1到第jj头牛 定义C_iCi为第ii头牛所能看到的别的牛的头发的数量。请帮助农夫约翰求出\sum_{i=1}^n C_i∑i=1nCi 题目描述Some of Farmer John’s N cows (1 ≤ N ≤ 80,000) are having a bad hair day! Since each cow is self-conscious about her messy hairstyle, FJ wants to count the number of other cows that can see the top of other cows’ heads. Each cow i has a specified height hi (1 ≤ hi ≤ 1,000,000,000) and is standing in a line of cows all facing east (to the right in our diagrams). Therefore, cow i can see the tops of the heads of cows in front of her (namely cows i+1, i+2, and so on), for as long as these cows are strictly shorter than cow i. Consider this example: ​ = = = = - = Cows facing right —&gt; = = = = - = = = = = = = = = 1 2 3 4 5 6 Cow#1 can see the hairstyle of cows #2, 3, 4 Cow#2 can see no cow’s hairstyle Cow#3 can see the hairstyle of cow #4 Cow#4 can see no cow’s hairstyle Cow#5 can see the hairstyle of cow 6 Cow#6 can see no cows at all! Let ci denote the number of cows whose hairstyle is visible from cow i; please compute the sum of c1 through cN.For this example, the desired is answer 3 + 0 + 1 + 0 + 1 + 0 = 5. 输入输出格式输入格式： Line 1: The number of cows, N. Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i. 输出格式： Line 1: A single integer that is the sum of c1 through cN. 输入输出样例输入样例#1： 1234567610374122 输出样例#1： 15 题解单调栈一眼题（这就是交上去WA了3次结果看题解发现少了等号的理由吗？） 最开始WA是因为用各种奇怪的姿势统计答案错了，之后发现等号没弹栈结果多统计了。。 思路很简单：我们只需要知道每头牛从自己最远能看到哪，而且是连续的，然后也不必知道具体每头牛，考虑对答案的贡献就行了。 Code： 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define maxn 80005int n , h[maxn];long long tot , ans;struct Node&#123; int v , k; bool operator &lt; (const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;p[maxn];std::stack&lt;int&gt; st;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ;++i) scanf("%d",&amp;h[i]); for(int i = 1 ; i &lt;= n ; ++i) &#123; int k = 0; while(!st.empty() &amp;&amp; h[st.top()] &lt;= h[i])&#123; ++k; st.pop(); &#125; ans += st.size(); st.push(i); &#125; tot += st.size(); printf("%lld",ans);&#125; [COI2007] Patrik 音乐会的等待题目描述N个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人A和B，如果他们是相邻或他们之间没有人比A或B高，那么他们是可以互相看得见的。 写一个程序计算出有多少对人可以互相看见。 输入输出格式输入格式： 输入的第一行包含一个整数N (1 ≤ N ≤ 500 000), 表示队伍中共有N个人。 接下来的N行中，每行包含一个整数，表示人的高度，以毫微米(等于10的-9次方米)为单位，每个人的调度都小于2^31毫微米。这些高度分别表示队伍中人的身高。 输出格式： 输出仅有一行，包含一个数S，表示队伍中共有S对人可以互相看见。 输入输出样例输入样例#1： 123456787 2 4 1 2 2 5 1 输出样例#1： 110 题解上一题的加强版，做了半天。。 这题要多考虑不少情况，主要是可以相等导致的 其中最坑的一种情况是来几个一样的来个小的再来个一样的然后来个大的，能考虑到这种情况就AC了。 所以我们栈中每个元素同时要维护多少个相等的，不必连续原因是假设来了一个大的，它可以把所有和这个相等的都加上而不重复计数 总之是个很坑的细节题，得考虑周全。 Code： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define maxn 500005#define pii std::pair&lt;int,int&gt;#define mp(x,y) std::make_pair((x),(y))int n , h[maxn];long long tot , ans;std::stack&lt;pii&gt; st;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ;++i) scanf("%d",&amp;h[i]); for(int i = 1 ; i &lt;= n ; ++i) &#123; pii p(h[i],1); for( ; !st.empty() &amp;&amp; st.top().first &lt;= h[i] ; st.pop())&#123; ans += st.top().second; if(st.top().first == h[i]) p.second += st.top().second; &#125; if(!st.empty()) ++ans; st.push(p); &#125; printf("%lld",ans);&#125; [HEOI2014]南园满地堆轻絮题目描述小 Z 是 ZRP（Zombies’ Republic of Poetry，僵尸诗歌共和国）的一名诗歌爱好者，最近 他研究起了诗词音律的问题。 在过去，诗词是需要编成曲子唱出来的，比如下面这首《菩萨蛮》，唱出来的话其对应的音符就是这样的： 12南 园 满 地 堆 轻 絮， 愁 闻 一 霎 清 明 雨 1 1 5 5 6 6 5 4 4 3 3 2 2 1 因而可以发现，1 1 5 5 6 6 5 4 4 3 3 2 2 1这串音符就成为了研究音律的关键。 小 Z 翻阅了众多史料发现，过去的一首曲子的音调是不下降的。 小 Z 想要知道对于一首给定的曲子，如何通过提高音调或者降低音调，将它的音调修改的不下降，而且使得修改幅度最大的那个音符的修改幅度尽量小。即如果把一个包含 nn 个音 符的曲子看做是一个正整数数列 A[1] \cdots A[n]A[1]⋯A[n]，那么目标是求另一个正整数数列 B[1]…B[n]B[1]…B[n]， 使得对于任意的 1≤i&lt;n1≤i&lt;n 有 B[i] ≤B[i+1]B[i]≤B[i+1]，而且使得 Ans = Max\{|A[j]-B[j]|,1≤j≤n\}Ans=Max{∣A[j]−B[j]∣,1≤j≤n}尽量 小。 小 Z 很快就想清楚了做法，但是鉴于他还忙着写诗，所以这个任务就交给了你。 输入输出格式输入格式： 由于数据规模可能较大，因此采用如下方式生成数据。 每个数据包含 7 个数：n,S_a,S_b,S_c,S_d,A[1],Modn,Sa,Sb,Sc,Sd,A[1],Mod，即共有 n 个音符，第一个音符为 A[1]。 生成规则如下： 定义生成函数 F(x) = S_ax^3 + S_bx^2 + S_c*x + S_dF(x)=Sa∗x3+Sb∗x2+Sc∗x+Sd; 那么给出递推公式 A[i] =( F(A[i-1]) + F(A[i-2]) )\%modA[i]=(F(A[i−1])+F(A[i−2]))%mod，此处规定 A[0] = 0A[0]=0. 由于中间过程的数可能会特别大，所以要求每一步与 AA 中的每个数都对一个给定的数 ModMod 取模。 输出格式： 输出一行，包含一个正整数 AnsAns。 输入输出样例输入样例#1： 复制 13 815 6901 3839 178 199 10007 输出样例#1： 复制 11334 说明【数据范围】 对于 10% 的数据， n≤3n≤3 对于 20% 的数据, n≤10n≤10 对于 30% 的数据, n≤100n≤100 对于 50% 的数据, n≤1000n≤1000 对于 70% 的数据, n≤100000n≤100000 对于 100% 的数据,#include 【友情提示】 样例中生成的数列为： 199 4568 1901，此时将 4568 修改为 3234,1901 也修改为 3234 即可，代价为 1334。 题解其实是一道比较简单的贪心了。 假如序列是上升的，显然不用调整。 假如来了一个下降的，那么和它之前最大的一起调整到两者的平均值，由于序列单调不降其他值调整的标准都小于它。调整到平均值显然是一个调整幅度最大中的最小，注意向上取整这种边界问题。 Code: 123456789101112131415161718192021222324252627282930// luogu-judger-enable-o2// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ll long long#define max(a,b) (a) &gt; (b) ? (a) : (b)ll n , a , b , c , d , cur , A1 , A2 , A3 , mod , ans;inline ll F(ll x)&#123; ll c1 = 0 , c2 = 0 , c3 = 0 , g = x * x % mod; c1 = a * x % mod * g % mod; c2 = b * g % mod; c3 = c * x % mod; return (c1 + c2 + c3 + d) % mod;&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld%lld",&amp;n,&amp;a,&amp;b,&amp;c,&amp;d,&amp;A2,&amp;mod); ll maxx = A2; for(register int i = 2 ; i &lt;= n ; ++i)&#123; A3 = (F(A2) + F(A1))% mod; if(A3 &lt; 0) A3 += mod; maxx = max(maxx , A3); ans = max(ans , (maxx - A3 + 1) / 2); A1 = A2 , A2 = A3; &#125; printf("%lld\n",ans);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.16]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-16%2F</url>
    <content type="text"><![CDATA[P2416 泡芙题目背景此题空间限制256M，保证系统栈空间与内存限制大小相同 此题空间限制256M，保证系统栈空间与内存限制大小相同 此题空间限制256M，保证系统栈空间与内存限制大小相同 题目描述火星猫经过一番努力终于到达了冥王星。他发现冥王星有 N 座城市，M 条无向边。火星猫准备出发去找冥王兔，他听说有若干泡芙掉落在一些边上，他准备采集一些去送给冥王兔。但是火星猫的火星光环和冥王星相生相克，当火星猫走过一条路之后，这条路就不能再走了。如果冥王兔吃不到泡芙，他们就不能嘿嘿嘿了。所以告诉你火星猫和冥王兔的位置，请问冥王兔能不能吃到泡芙。 输入输出格式输入格式： 第一行 N,M 表示点数和边数。 接下来 M 行每行 X,Y,Z 表示 X 到 Y 有一条无向边，Z=1 表示有泡芙，Z=0 表示没有 接下来一行是 Q，表示有 Q 组询问。 每行 S,T 表示火星猫和冥王兔的位置。 输出格式： 对于每组询问输出 YES 或 NO 输入输出样例输入样例#1： 123456789106 71 2 02 3 03 1 03 4 14 5 05 6 06 4 011 6 输出样例#1： 1YES 说明123456no N&lt;= M&lt;= Q&lt;= 备注3-4 1000 N-1 50000 保证图是一棵树5-8 300000 N-1 300000 9-10 20 50 5 无11-14 1000 5000 50000 15-20 300000 300000 300000 保证图联通 题解这道题还是有一定思维难度的，让我们来分析一波。 也许我们会考虑最大生成树，因为那样可以使两点间最小的边最大化，但是并不能使两点间最大的边最大化。 然后我们看了看数据范围，发现和树上倍增的范围很像，于是想到缩边双联通分量把图缩成树。 下面我们来说这是为什么正确的，首先ECC有一个性质：ECC内任意两点均有两条严格不相交的路线（否则就会有桥）。这意味着只要ECC内有一条边长度为1，那么我们就能走过这条边而选择另一条严格不相交路径到达ECC其他点 因此本题算法是Tarjan ECC + LCA 将ECC视为点，处理点权即ECC内是否有边为1，然后做树上点权前缀和与边权前缀和（倍增也行，而且更加好想） 时间复杂度 O(n+m+qlogn)Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// luogu-judger-enable-o2#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstring&gt;#define maxn 300005int head[maxn] , cnt , n , m , ecc[maxn] , tot , dfn[maxn] , low[maxn] , f[maxn][22] , dep[maxn] , lg[maxn] , idx , gg , SE[maxn] , SV[maxn];bool ins[maxn];std::stack&lt;int&gt; st;struct edge&#123; int next ,to ,dis;&#125;e[maxn*2];struct E&#123; int f , t ,d;&#125;ed[maxn*2];inline void add(int x, int y , int d)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;void Tarjan(int x , int fx)&#123; dfn[x] = low[x] = ++idx; st.push(x); // ins[x] = true; for(int i = head[x] ; i ; i = e[i].next) &#123; if(!dfn[e[i].to]) &#123; // printf("Tarjan! %d -&gt; %d\n",x,e[i].to); Tarjan(e[i].to , x); low[x] = std::min(low[x] , low[e[i].to]); &#125; else if(e[i].to != fx) low[x] = std::min(low[x] , dfn[e[i].to]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; ecc[st.top()] = tot; // ins[st.top()] = false; st.pop(); &#125; ecc[st.top()] = tot; st.pop(); &#125;&#125;void dfs(int x , int fx , int fd)&#123; // printf("%d %d %d:\n",x,fx,fd); f[x][0] = fx; // printf("%d\n",f[x][0]); // printf("g[%d][0] = %d\n",x,g[x][0]); SE[x] = SE[fx] + fd; SV[x] += SV[fx]; dep[x] = dep[fx] + 1; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs(e[i].to , x , e[i].dis);&#125;inline void OPTI()&#123; for(int i = 1 ; i &lt;= tot ; ++i) lg[i] = lg[i-1] + ((1 &lt;&lt; lg[i-1] )== i); for(int j = 1 ; j &lt;= 21 ; ++j) for(int i = 1 ; i &lt;= tot ; ++i) f[i][j] = f[f[i][j-1]][j-1];&#125;inline int LCA(int x , int y)&#123; if(dep[x] &lt; dep[y]) std::swap(x,y); while(dep[x] &gt; dep[y]) x = f[x][lg[dep[x]-dep[y]]-1]; if(x == y) return x; for(int i = lg[dep[x]] ; i &gt;= 0 ; --i) if(f[x][i] != f[y][i]) x = f[x][i] , y = f[y][i]; return f[x][0];&#125;void test(int x , int fx)&#123; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) printf("%d -&gt;%d\n",x,e[i].to) , test(e[i].to , x);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y , d; for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;d) , add(x,y,d) , add(y,x,d) , ed[++gg].f = x , ed[gg].t = y , ed[gg].d = d , ed[++gg].f = y , ed[gg].t = x , ed[gg].d = d; Tarjan(1,0); // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d ",ecc[i]); std::memset(head,0,sizeof(head)); std::memset(e,0,sizeof(e)); cnt = 0; // for(int i = 1 ; i &lt;= 2 * m ; ++i) // printf("%d %d %d\n",ed[i].f , ed[i].t , ed[i].d); for(int i = 1 ; i &lt;= 2 * m ; ++i) &#123; int u = ed[i].f , v = ed[i].t; if(ecc[u] == ecc[v]) SV[ecc[u]] += ed[i].d; if(ecc[u] != ecc[v]) add(ecc[u] , ecc[v] , ed[i].d); &#125;//clear // test(1,0); dfs(1,0,0); // for(int i = 1 ; i &lt;= tot ; ++i) // printf("%d ",dep[i]); // printf("%d\n",g[2][0]); //clear OPTI(); // printf("%d\n",g[2][0]); // puts("OK")； // printf("%d\n",tot); int q; scanf("%d",&amp;q); for(int i = 1 ; i &lt;= q ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); int u = ecc[x] , v = ecc[y]; int fx = LCA(u,v); int ans = SV[u] + SV[v] - SV[fx] - SV[f[fx][0]] + SE[u] + SE[v] - 2 * SE[fx]; if(ans &gt; 0) puts("YES"); else puts("NO"); // printf("%d %d %d\n",s[u] , s[v] , s[LCA(u,v)]); &#125;&#125; Trie字典树一种将每个字符串的每个字符按位置对应到树上节点的算法，可以O(n)插入，O(n)查询前缀等等等等。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 50005#define maxz 60int trie[maxn][maxz] , n , tot , q;bool mark[maxn * maxz];std::string s[maxn] , p[maxn];inline void insert(std::string s)&#123; int u = 1; for(int i = 0 ; i &lt; s.length() ; ++i) &#123; int c = s[i] - 'a' ;// not all if(!trie[u][c]) trie[u][c] = ++tot; u = trie[u][c]; &#125; mark[u] = true;&#125;inline int queryLCP(std::string s)&#123; int u = 1 , ans = 0; for(int i = 0 ; i &lt; s.length() ; ++i) &#123; int c = s[i] - 'a'; if(trie[u][c]) ++ans; else return ans; u = trie[u][c]; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) std::cin&gt;&gt;s[i]; for(int i = 1 ; i &lt;= n ; ++i) insert(s[i]); scanf("%d",&amp;q); for(int i = 1 ; i &lt;= q ; ++i) std::cin&gt;&gt;p[i] , printf("%d\n",queryLCP(p[i]));&#125; Phone ListDescription Given a list of phone numbers, determine if it is consistent in the sense that no number is the prefix of another. Let’s say the phone catalogue listed these numbers: Emergency 911 Alice 97 625 999 Bob 91 12 54 26 In this case, it’s not possible to call Bob, because the central would direct your call to the emergency line as soon as you had dialled the first three digits of Bob’s phone number. So this list would not be consistent. Input The first line of input gives a single integer, 1 ≤ t ≤ 40, the number of test cases. Each test case starts with n, the number of phone numbers, on a separate line, 1 ≤ n ≤ 10000. Then follows n lines with one unique phone number on each line. A phone number is a sequence of at most ten digits. Output For each test case, output “YES” if the list is consistent, or “NO” otherwise. Sample Input 12345678910112391197625999911254265113123401234401234598346 Sample Output 12NOYES Source Nordic 2007 题解显然是一道Trie字典树的题。在线插入的同时分别看看当前插入的字符串是不是之前的字符串前缀以及之前是否有当前串的前缀。思维难度海星 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005#define maxlen 10int trie[maxn][maxlen] , n , t , tot = 1;std::string s;bool mark[maxn];inline bool insert(const std::string&amp; s)&#123; int u = 1; bool flag = false , nw = true; for(int i = 0 ; i &lt; s.length() ; ++i) &#123; int c = s[i] - 48; if(!trie[u][c]) trie[u][c] = ++tot , nw = false; u = trie[u][c] ; if(mark[u]) flag = true; &#125; mark[u] = true; flag = flag || nw ; return flag;&#125;int main()&#123; // freopen("data.in","r",stdin); // freopen("my.out","w",stdout); scanf("%d",&amp;t); while(t--) &#123; std::memset(trie,0,sizeof(trie)); std::memset(mark,false,sizeof(mark)); tot = 1 ; bool flag = false; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) &#123; std::cin&gt;&gt;s; if(insert(s)) flag = true ; &#125; if(!flag) puts("YES"); else puts("NO"); &#125;&#125; Redundant Paths Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 18836 Accepted: 7795 Description In order to get from one of the F (1 &lt;= F &lt;= 5,000) grazing fields (which are numbered 1..F) to another field, Bessie and the rest of the herd are forced to cross near the Tree of Rotten Apples. The cows are now tired of often being forced to take a particular path and want to build some new paths so that they will always have a choice of at least two separate routes between any pair of fields. They currently have at least one route between each pair of fields and want to have at least two. Of course, they can only travel on Official Paths when they move from one field to another. Given a description of the current set of R (F-1 &lt;= R &lt;= 10,000) paths that each connect exactly two different fields, determine the minimum number of new paths (each of which connects exactly two fields) that must be built so that there are at least two separate routes between any pair of fields. Routes are considered separate if they use none of the same paths, even if they visit the same intermediate field along the way. There might already be more than one paths between the same pair of fields, and you may also build a new path that connects the same fields as some other path. Input Line 1: Two space-separated integers: F and R Lines 2..R+1: Each line contains two space-separated integers which are the fields at the endpoints of some path. Output Line 1: A single integer that is the number of new paths that must be built. Sample Input 123456787 71 22 33 42 54 55 65 7 Sample Output 12 Hint Explanation of the sample: One visualization of the paths is: 123456789 1 2 3 +---+---+ | | | |6 +---+---+ 4 / 5 / / 7 + Building new paths from 1 to 6 and from 4 to 7 satisfies the conditions. 123456789 1 2 3 +---+---+ : | | : | |6 +---+---+ 4 / 5 : / : / :7 + - - - - Check some of the routes: 1 – 2: 1 –&gt; 2 and 1 –&gt; 6 –&gt; 5 –&gt; 21 – 4: 1 –&gt; 2 –&gt; 3 –&gt; 4 and 1 –&gt; 6 –&gt; 5 –&gt; 43 – 7: 3 –&gt; 4 –&gt; 7 and 3 –&gt; 2 –&gt; 5 –&gt; 7 Every pair of fields is, in fact, connected by two routes. It’s possible that adding some other path will also solve the problem (like one from 6 to 7). Adding two paths, however, is the minimum. Source USACO 2006 January Gold 题解显然对于任何一个ECC，其中的任意两点都可以找到两条严格不相交路径，所以对于整个图的任意两点，经过ECC可以视为一个整体。所以我们将原图缩ECC成一颗树，通过推导树的性质我们可以发现只需要将树的叶子两两配对(奇数多出的连向任意一个叶子)，这样对于树上任何两点都处于一个环中，整个图就联通了，这是充分条件。（就是本方案一定正确的原因） 必要条件（即证明本方案最优）也十分好证明，假设任意两片叶子没有连边，那么这两点间只有一条路（树的性质）。对不是叶节点的点连边显然会导致比不连要更劣（因为每个叶子）。因此这个方法是正确的。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;map&gt;#define maxn 5005#define maxm 10005int head[maxn] , cnt , n , m , dfn[maxn] , low[maxn] , idx , ecc[maxn] , tot , sz[maxn];std::stack&lt;int&gt; st;std::map&lt;int,int&gt; vis[maxn];struct edge&#123; int next , to;&#125;e[maxm * 2];struct E&#123; int from , to;&#125;ed[maxm*2];inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y ; head[x] = cnt;&#125;void Tarjan(int x , int fx)&#123; dfn[x] = low[x] = ++idx; st.push(x); for(int i = head[x] ; i ; i = e[i].next) &#123; if(!dfn[e[i].to]) &#123; // printf("Tarjan! %d -&gt; %d\n",x,e[i].to); Tarjan(e[i].to , x); low[x] = std::min(low[x] , low[e[i].to]); &#125; else if(e[i].to != fx) low[x] = std::min(low[x] , dfn[e[i].to]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; ecc[st.top()] = tot; st.pop(); &#125; ecc[st.top()] = tot; st.pop(); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y , d; int g = 0; for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , add(y,x) , ed[++g].from = x , ed[g].to = y , ed[++g].from = y , ed[g].to = x; Tarjan(1,1); std::memset(head,0,sizeof(head)); std::memset(e,0,sizeof(e)); cnt = 0; // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d ",ecc[i]); for(int i = 1 ; i &lt;= 2 * m ; i++) &#123; int u = ed[i].from , v = ed[i].to; if(!vis[ecc[v]][ecc[u]] &amp;&amp; !vis[ecc[v]][ecc[u]] &amp;&amp; ecc[v] != ecc[u]) add(ecc[u] , ecc[v]) , add(ecc[v] , ecc[u]) , sz[ecc[u]] ++ , sz[ecc[v]] ++ , vis[ecc[v]][ecc[u]] = vis[ecc[u]][ecc[v]] = 1; &#125; int ans = 0; for(int i = 1 ; i &lt;= tot ; ++i) if(sz[i] == 1) ++ans; ans = (ans + 1) / 2; printf("%d",ans);&#125; P4551 最长异或路径题目描述给定一棵nn个点的带权树，结点下标从11开始到NN。寻找树中找两个结点，求最长的异或路径。 异或路径指的是指两个结点之间唯一路径上的所有边权的异或。 输入输出格式输入格式： 第一行一个整数NN，表示点数。 接下来 n-1n−1 行，给出 u,v,wu,v,w ，分别表示树上的 uu 点和 vv 点有连边，边的权值是 ww。 输出格式： 一行，一个整数表示答案。 输入输出样例输入样例#1： 复制 123441 2 32 3 42 4 6 输出样例#1： 复制 17 说明最长异或序列是1-2-3，答案是 7 (=3 ⊕ 4) 数据范围 1\le n \le 100000;0 < u,v \le n;0 \le w < 2^{31}题解首先树上任意两点路径的XorSum就是两点到root的Xorsum在Xor，这是Xor的自反律。 然后我们做树上前缀Xor，然后问题就等价为从这些前缀xor中选出两个xorsum最大。 显然对于一个数来说，从其它的数中不同的位越高Xor越大，如果多个在最高位都不同一样，就再比下一位。 我们将每个数插入Trie树，然后对每个数这样在字典树上求出最大就行了 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int head[maxn] , cnt , n , trie[maxn * 33][3] , Xor[maxn] , tot , ans;bool mark[maxn*33];struct edge&#123; int next , to , dis;&#125;e[maxn * 2];inline void add(int x, int y , int d)&#123; e[++cnt].next = head[x] ; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;void dfs(int x , int fx , int dis)&#123; Xor[x] = Xor[fx] ^ dis; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs(e[i].to , x , e[i].dis);&#125;inline void insert(int x)&#123; int u = 0 , lr = 30; for( ; lr &gt;= 0 ; --lr) &#123; if(!trie[u][(x&gt;&gt;lr)&amp;1]) trie[u][1&amp;(x&gt;&gt;lr)] = ++tot; u = trie[u][(x&gt;&gt;lr)&amp;1]; &#125; mark[u] = true;&#125;inline int query(int x)&#123; int u = 0 , lr = 30 , ans = 0; for( ; lr &gt;= 0 ; --lr) &#123; if(trie[u][((x&gt;&gt;lr)&amp;1)^1]) ans += (1&lt;&lt;lr) , u = trie[u][((x&gt;&gt;lr)&amp;1)^1]; else u = trie[u][(x&gt;&gt;lr)&amp;1]; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;n); int x , y , dis; for(int i = 1 ; i &lt;= n - 1 ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;dis) , add(x,y,dis) , add(y,x,dis); dfs(1,0,0); for(int i = 1 ; i &lt;= n ; ++i) insert(Xor[i]); for(int i = 1 ; i &lt;= n ; ++i) ans = std::max(ans , query(Xor[i])); printf("%d",ans);&#125; 4260: Codechef REBXOR Description .jpg) Input输入数据的第一行包含一个整数N，表示数组中的元素个数。 第二行包含N个整数A1,A2,…,AN。 Output输出一行包含给定表达式可能的最大值。 Sample Input5 1 2 3 1 2 Sample Output6 HINT满足条件的(l1,r1,l2,r2)有：(1,2,3,3)，(1,2,4,5)，(3,3,4,5)。 对于100%的数据， 2 ≤ N ≤ 4*10^5，0 ≤ Ai ≤ 10^9。SourceBy yts1999 题解从序列选两个不相交的区间，使得两个区间异或和最大。 Xor一般可以想三个： 前缀，trie，自反 然后我们发现一个区间xor最大相当于这个区间右端点前缀xor左端点前缀最大（自反），因此本题算法似乎很显然，从前开始一遍找出对于i之前的最大的一个区间，然后最后线性枚举中间点求出最后答案。 但是要注意是枚举点并不是要求定住的区间边界，而是小于等于或大于等于这个点的边界都可以，也就是说假设i+1计算的值不如i优，i+1左边显然应该继承i的值。 写题思路一定要清晰。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 400005int tot , A[maxn] , fr[maxn] , se[maxn] , n , sf[maxn] , sa[maxn];struct trie&#123; int tr[maxn*30][2] , tot; bool mark[maxn*30]; inline void insert(int x) &#123; int lr = 30 , u = 0; for( ; lr &gt;= 0 ; --lr) &#123; if(!tr[u][(x&gt;&gt;lr)&amp;1]) tr[u][(x&gt;&gt;lr)&amp;1] = ++tot; u = tr[u][(x&gt;&gt;lr)&amp;1]; &#125; mark[u] = true; &#125; inline int query(int x) &#123; int lr = 30 , u = 0, ans = 0; for( ; lr &gt;= 0 ; --lr) &#123; if(tr[u][((x&gt;&gt;lr)&amp;1)^1]) ans += (1&lt;&lt;lr) , u = tr[u][((x&gt;&gt;lr)&amp;1)^1]; else u = tr[u][(x&gt;&gt;lr)&amp;1]; &#125; return ans; &#125;&#125;tr1 , tr2 ;int main()&#123; // freopen("rbzno1.in","r",stdin); scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;A[i]); for(int i = 1 ; i &lt;= n ; ++i) sf[i] = sf[i-1] ^ A[i]; for(int i = n ; i &gt;= 1 ; --i) sa[i] = sa[i+1] ^ A[i]; tr1.insert(0) , tr2.insert(0); tr1.insert(sf[1]) , tr2.insert(sa[n]); for(int i = 2 ; i &lt;= n ; ++i) &#123; tr1.insert(sf[i]); fr[i] = std::max(fr[i-1] ,tr1.query(sf[i])); &#125; for(int i = n-1 ; i &gt;= 1 ; --i) &#123; tr2.insert(sa[i]); se[i] = std::max(tr2.query(sa[i]) , se[i+1]); &#125; int ans = 0; fr[1] = sf[1] , se[n] = sa[n]; for(int i = 1 ; i &lt; n ; ++i) ans = std::max(ans , fr[i] + se[i + 1]); printf("%d",ans);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.24]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-24%2F</url>
    <content type="text"><![CDATA[[POI2008]BLO-Blockade题意翻译在Byteotia有n个城镇。 一些城镇之间由无向边连接。 在城镇外没有十字路口，尽管可能有桥，隧道或者高架公路（反正不考虑这些）。每两个城镇之间至多只有一条直接连接的道路。人们可以从任意一个城镇直接或间接到达另一个城镇。 每个城镇都有一个公民，他们被孤独所困扰。事实证明，每个公民都想拜访其他所有公民一次（在主人所在的城镇）。所以，一共会有n*（n-1）次拜访。 不幸的是，一个程序员总罢工正在进行中，那些程序员迫切要求购买某个软件。 作为抗议行动，程序员们计划封锁一些城镇，阻止人们进入，离开或者路过那里。 正如我们所说，他们正在讨论选择哪些城镇会导致最严重的后果。 编写一个程序： 读入Byteotia的道路系统，对于每个被决定的城镇，如果它被封锁，有多少访问不会发生，输出结果。 输入输出格式第一行读入n，m，分别是城镇数目和道路数目 城镇编号1~n 接下来m行每行两个数字a,b，表示a和b之间有有一条无向边 输出n行，每行一个数字，为第i个城镇被锁时不能发生的访问的数量。 123@[chen_zhe](/space/show?uid=8457)翻译提供者：Park 题目描述There are exactly nn towns in Byteotia. Some towns are connected by bidirectional roads. There are no crossroads outside towns, though there may be bridges, tunnels and flyovers. Each pair of towns may be connected by at most one direct road. One can get from any town to any other-directly or indirectly. Each town has exactly one citizen. For that reason the citizens suffer from loneliness. It turns out that each citizen would like to pay a visit to every other citizen (in his host’s hometown), and do it exactly once. So exactly n\cdot (n-1)n⋅(n−1) visits should take place. That’s right, should. Unfortunately, a general strike of programmers, who demand an emergency purchase of software, is under way. As an act of protest, the programmers plan to block one town of Byteotia, preventing entering it, leaving it, and even passing through. As we speak, they are debating which town to choose so that the consequences are most severe. Task Write a programme that: reads the Byteotian road system’s description from the standard input, for each town determines, how many visits could take place if this town were not blocked by programmers, writes out the outcome to the standard output. 给定一张无向图，求每个点被封锁之后有多少个有序点对(x,y)(x!=y,1&lt;=x,y&lt;=n)满足x无法到达y 输入输出格式输入格式： In the first line of the standard input there are two positive integers: nn and mm (1\le n\le 100\ 0001≤n≤100 000, 1\le m\le 500\ 0001≤m≤500 000) denoting the number of towns and roads, respectively. The towns are numbered from 1 to nn. The following mm lines contain descriptions of the roads. Each line contains two integers aa and bb (1\le a&lt;b\le n1≤a&lt;b≤n) and denotes a direct road between towns numbered aaand bb. 输出格式： Your programme should write out exactly nn integers to the standard output, one number per line. The i^{th}ith line should contain the number of visits that could not take place if the programmers blocked the town no. ii. 输入输出样例输入样例#1： 1234565 51 22 31 33 44 5 输出样例#1： 123458816148 题解这个题显然上来思路之一就是割点。 显然每个点的答案都是它分成的联通块大小的卷积加上它自己的n-1次访问（当然还要乘二）。 然后我们发现假如每个割点我们都并查集暴力合并，时间复杂度是 O(n^2)会超时。 然后我yy出一种做法。 我们可以在dfs序的这棵树上做dp。。 考虑以x为跟的子树中有多少个不能回溯到x祖先的点（同一颗子树有一个能那么这颗子树都能）。 由割点定义可知割点的的子树中至少存在一颗子树保证子树内所有点都不能回溯到割点的祖先。 因此我们统计的时候可以直接卷积乘。 但是假如数据是菊花图就变成 n^2了。。 因此记录子树节点数相同的个数，这样就有了根号优化。 注意能回溯到当先点的祖先的子树的大小应加到 sz(low(v))中，v即是这颗子树的根 代码突然不想写，有时间再补吧。。 数列求和题目描述求数列 {b_n \ = \ n^ka^n} 的前 n 项和 {T_n \ mod \ \left( 10^9+7 \right) }输入输出格式输入格式： 输入共 1 行，包含 3 个非负整数： n，a，k 输出格式： 输出共 1 行，包含 1 个非负整数： {T_n \ mod \ \left( 10^9+7 \right) }输入输出样例输入样例#1： 13 4 0 输出样例#1： 184 输入样例#2： 13 10 1 输出样例#2： 13210 输入样例#3： 13 9 2 输出样例#3： 16894 说明 题解这道题似乎只要想到按照k递推就不难了。递推中没必要带上n，因为n在这个递推式中是很好处理的。 Tn(k)=b1+b2+b3+⋯+bn即 T_n(k) = 1^ka^1 + 2^ka^2 + 3^ka^3 + \cdots + n^ka^n又 aT_n(k) = 1^ka^2 + 2^ka^3 + \cdots + (n-1)^ka^n + n^ka^{n+1} \therefore (a-1)T_n(k) = n^ka^{n+1} - a + \sum_{i=2}^{n} \left( (i-1)^k-i^k \right) a^i \because (i-1)^k = \sum_{j=0}^{k} \textrm{C}_ {k}^{j} \cdot i^j \cdot (-1)^{k-j} \therefore (i-1)^k-i^k = \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot i^j \cdot (-1)^{k-j} \therefore \sum_{i=2}^{n} \left( (i-1)^k-i^k \right) a^i = \sum_{i=2}^{n} \left( \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot i^j \cdot (-1)^{k-j} \right) a^i = \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot (-1)^{k-j} \left( \sum_{i=2}^{n} i^j \cdot a^i \right) \because \sum_{i=2}^{n} i^j \cdot a^i = \left( \sum_{i=1}^{n} i^j \cdot a^i \right) -a = T_n(j)-a \therefore (a-1)T_n(k) = n^ka^{n+1} - a + \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot (-1)^{k-j} \left( T_n(j)-a \right) \therefore T_n(k) = \frac{n^ka^{n+1} - a + \sum_{j=0}^{k-1} \textrm{C}_ {k}^{j} \cdot (-1)^{k-j} \left( T_n(j)-a \right)}{a-1}注意到 j &lt; kj&lt;k 可以 O(k^2)递推 特殊地， T_n(0) = a^1 + a^2 + a^3 + \cdots + a^n = \frac{a \left( a^n - 1 \right)}{a-1} 中间无非是二项式定理展开后利用定比a错位相减，最后再错位相减一次即可 最短距离题目描述给出一个 {N}N 个点 {N}N 条边的无向连通图。 你需要支持两种操作： 修改 第 {x}x 条边的长度为 {y}y ； 查询 点 {x}x 到点 {y}y 的最短距离。 共有 {M}M 次操作。 输入输出格式输入格式： 输入共 N + M + 1 行： 第 1 行，包含 2 个正整数 N，M，表示点数即边数，操作次数。 第 2 行到第 N + 1 行，每行包含 3 个正整数 x，y，z，表示 x 与 y 间有一条长度 为 z 的边。 第 N + 2 到 N + M + 1 行，每行包含 3 个正整数 opt，x，y，表示操作种类，操作的参数（含义见【题目描述】）。 输出格式： 对于每次操作 2 输出查询的结果。 输入输出样例输入样例#1： 123456789104 51 2 111 3 122 3 131 4 152 2 31 2 12 2 32 2 42 3 4 输出样例#1： 123413122616 说明 题解：一开始以为有神器做法。结果发现就是找环后用线段树/树状数组维护环，对每颗以还上点为根的树用HPD（也可以用树状数组实现HPD。。），然后查询修改就好了。。 [USACO5.3]校园网Network of Schools题目描述一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使 B 在 A 学校的分发列表中， A 也不一定在 B 学校的列表中。 你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务 A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务 B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。 输入输出格式输入格式： 输入文件的第一行包括一个整数 N：网络中的学校数目（2 &lt;= N &lt;= 100）。学校用前 N 个正整数标识。 接下来 N 行中每行都表示一个接收学校列表（分发列表）。第 i+1 行包括学校 i 的接收学校的标识符。每个列表用 0 结束。空列表只用一个 0 表示。 输出格式： 你的程序应该在输出文件中输出两行。 第一行应该包括一个正整数：子任务 A 的解。 第二行应该包括子任务 B 的解。 输入输出样例12345652 4 3 04 5 0001 0 输出样例#1： 1212 说明题目翻译来自NOCOW。 USACO Training Section 5.3 题解读了半天题才看明白它想让你求什么。。 缩点后入度为0的点数和出度为0与入度为0的点数的较大值 Tarjan缩点 Code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#define maxn 205#define maxm maxn * maxnstd::stack&lt;int&gt; st;int head[maxn] , cnt , scc[maxn] , n , m , dfn[maxn] , low[maxn] , tot , idx , rbz , ans1 , ans2 ,t[maxn] , d[maxn];bool vis[maxn][maxn] , ins[maxn];struct edge&#123; int next , to;&#125;e[maxm*2];struct use&#123; int from , to;&#125;er[maxm*2];inline void add(int x, int y)&#123; e[++cnt].next = head[x]; e[cnt].to =y; head[x] = cnt; ++t[x]; ++d[y];&#125;void Tarjan(int x)&#123; dfn[x] = low[x] = ++idx; st.push(x); ins[x] = true; for(int i = head[x] ; i ; i = e[i].next) &#123; if(!dfn[e[i].to]) &#123; Tarjan(e[i].to); low[x] = std::min(low[x] , low[e[i].to]); &#125; else if(ins[e[i].to]) low[x] = std::min(low[x] , dfn[e[i].to]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; scc[st.top()] = tot; ins[st.top()] = false; st.pop(); &#125; scc[st.top()] = tot; ins[st.top()] = false; st.pop(); &#125;&#125;int main()&#123; scanf("%d",&amp;n); int x; for(int i = 1 ; i &lt;= n ; ++i) &#123; while(scanf("%d",&amp;x)) &#123; if(!x) break; add(i,x) , er[++rbz].from = i , er[rbz].to = x; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) if(!dfn[i]) Tarjan(i); std::memset(head,0,sizeof(head)); std::memset(e,0,sizeof(e)); std::memset(t,0,sizeof(t)); std::memset(d,0,sizeof(d)); cnt = 0; for(int i = 1 ; i &lt;= rbz ; ++i) &#123; if(scc[er[i].from] == scc[er[i].to]) continue; add(scc[er[i].from] , scc[er[i].to]);// printf("%d : %d %d\n",i,scc[er[i].from] , scc[er[i].to]); &#125; for(int i = 1 ; i &lt;= tot ; ++i) &#123; if(!d[i]) ++ans1; if(!t[i]) ++ans2; &#125; if(tot == 1) &#123; printf("%d\n",ans1); return 0; &#125; printf("%d\n",ans1);&#125; [USACO14FEB]路障Roadblock题目描述每天早晨，FJ从家中穿过农场走到牛棚。农场由 N 块农田组成，农田通过 M 条双向道路连接，每条路有一定长度。FJ 的房子在 1 号田，牛棚在 N 号田。没有两块田被多条道路连接，以适当的路径顺序总是能在农场任意一对田间行走。当FJ从一块田走到另一块时，总是以总路长最短的道路顺序来走。 FJ 的牛呢，总是不安好心，决定干扰他每天早晨的计划。它们在 M 条路的某一条上安放一叠稻草堆，使这条路的长度加倍。牛希望选择一条路干扰使得FJ 从家到牛棚的路长增加最多。它们请你设计并告诉它们最大增量是多少。 输入输出格式输入格式： 第 1 行：两个整数 N, M。 第 2 到 M+1 行：第 i+1 行包含三个整数 A_i, B_i, L_i，A_i 和 B_i 表示道路 i 连接的田的编号，L_i 表示路长。 输出格式： 第 1 行：一个整数，表示通过使某条路加倍而得到的最大增量。 输入输出样例输入样例#1： 123456785 72 1 51 3 13 2 83 5 73 4 32 4 74 5 2 输出样例#1： 12 说明【样例说明】 若使 3 和 4 之间的道路长加倍，最短路将由 1-3-4-5 变为 1-3-5。 【数据规模和约定】 对于 30%的数据，N &lt;= 70，M &lt;= 1,500。 对于 100%的数据，1 &lt;= N &lt;= 100，1 &lt;= M &lt;= 5,000，1 &lt;= L_i &lt;= 1,000,000。 题解这道简单的最短路+路径记录做了不少时间，不过有所收获。 首先对结构体运用的更灵活了，在结构体里的重载运算符终于能写对了。感谢UOJ大佬告诉我括号后面加const就可以了。 显然有个小结论，对于1~n的最短路，设n的前驱为x，则1~n的最短路一定包括了1~x的最短路（可以反证法）。 这样我们就让优先队列的元素多记录个前驱即可。每个点第一次出队时即为最短路，记录前驱。 最后枚举最短路上的每条边处理后最短路。 可以证明一个没有负环的图单源最短路最多有n-1条边。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define maxn 105#define maxm 5050int n , m , head[maxn] , cnt = 1 , d[maxn] , next[maxn] , tot , ans = -0x7fffffff , minn , edge[maxm*2] , way[maxm*2];bool vis[maxn];struct Node&#123; int val , ver , pre , edge; bool operator &gt; (const Node &amp;x)const&#123; return val &gt; x.val; &#125; bool operator &lt; (const Node &amp;x)const&#123; return val &lt; x.val; &#125;&#125;;struct edge&#123; int next , to , dis;&#125;e[maxm * 2];inline void add(int x , int y , int dis)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;inline void SPDIJ(int s , int rec)&#123; std::memset(d,0x7f,sizeof(d)); std::memset(vis,false,sizeof(vis)); d[s] = 0; std::priority_queue&lt;Node , std::vector&lt;Node&gt; , std::greater&lt;Node&gt; &gt; q; q.push((Node)&#123;d[s],s,0,0&#125;); while(!q.empty()) &#123; int k = q.top().ver , x = q.top().pre , y = q.top().edge; q.pop(); if(vis[k]) continue; if(rec)&#123; next[k] = x; edge[k] = y; &#125; vis[k] = true; for(int i = head[k] ; i ; i = e[i].next) if(d[k] + e[i].dis &lt; d[e[i].to]) d[e[i].to] = d[k] + e[i].dis , q.push((Node)&#123;d[e[i].to] , e[i].to , k , i&#125;); &#125; if(rec) &#123; int k = n; while(k != s)&#123; way[++tot] = edge[k]; k = next[k]; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y, dis; for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;dis) , add(x,y,dis) , add(y,x,dis); SPDIJ(1,1); minn = d[n]; for(int i = 1 ; i &lt;= tot ; ++i) &#123; if(way[i] == 0) continue; e[way[i]].dis = e[way[i]^1].dis = 2 * e[way[i]].dis; SPDIJ(1,0);// printf("%d\n",d[n]-minn); ans = std::max(ans , d[n] - minn); e[way[i]].dis = e[way[i]^1].dis = e[way[i]].dis / 2; &#125; printf("%d",ans);&#125; 今天感觉到了深深的危机感啊。。 论代码能力，时间复杂度写了1小时最后交上去也就20多分。 论思维能力，POI的题可以说不会几道（联赛过后必刷POI，联赛前复习基础）。 还需要努力啊。 [NOI2001]炮兵阵地题目描述司令部的将军们打算在NM的网格地图上部署他们的炮兵部队。一个NM的地图由N行M列组成，地图的每一格可能是山地（用“H” 表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示： 如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。 输入输出格式输入格式： 第一行包含两个由空格分割开的正整数，分别表示N和M； 接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。N≤100；M≤10。 输出格式： 仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。 输入输出样例输入样例#1： 1234565 4PHPPPPHHPPPPPHPPPHHP 输出样例#1： 16 题解又独立切掉了状态压缩dp，嘤。 感觉不难啊为什么他们都说难写，找回一点自信 首先看一眼数据范围对行压缩 然后由于当前行会被前两行影响，因此状态保存两行 而且要不是最后的check忘了取反就一遍AC啦！ 设 f(i,S_{cur},S_{las})表示当前为第i行，当前状态是 S_{cur}上一行是 S_{las} f(i,S_{cur},S_{las}) = max\{f(i-1,S_{las},S_k) + count(S_{cur})\}由上面的转移可以看出这样做的时间复杂度是 O(n*8^m)但是我们把每行的最基本的不冲突的合法状态处理出来就大大减少转移状态数，加上此题限制条件多，实际上跑的飞快。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 105#define maxm 12int f[3][1&lt;&lt;maxm][1&lt;&lt;maxm] , n , m , g[1&lt;&lt;maxm] , tot , s[maxn];inline int count(int x)&#123; int ans = 0; for(int i = x ; i ; i -= i &amp; -i) ++ans; return ans;&#125;inline bool check(int sta , int rst)&#123; return sta &amp; rst;&#125;void write(int x)&#123; if(!x)return; write(x/2); putchar((x&amp;1)+48);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) &#123; char ch ; std::cin&gt;&gt;ch; s[i] &lt;&lt;= 1; s[i] += (ch == 'P') ? 0 : 1; &#125; int S = (1&lt;&lt;m)-1; for(int i = 0 ; i &lt;= S ; ++i) &#123; if((i &amp; (i &lt;&lt; 1)) || (i &amp; (i &lt;&lt; 2)) || (i &amp; (i &gt;&gt; 1)) || (i &amp; (i &gt;&gt; 2)) ) continue; g[++tot] = i;//prepare the basic valid status &#125; for(int i = 1 ; i &lt;= tot ; ++i) f[1][g[i]][0] = count(g[i]); for(int i = 2 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= tot ; ++j) for(int k = 1 ; k &lt;= tot ; ++k) &#123; if(check(g[j] , g[k])) continue; if(check(g[j] , s[i])) continue; if(check(g[k] , s[i-1])) continue; for(int p = 1 ; p &lt;= tot ; ++p) &#123; if(check(g[k] , g[p]) || check(g[j],g[p])) continue; if(check(g[p] , s[i-2])) continue; f[i%3][g[j]][g[k]] = std::max(f[i%3][g[j]][g[k]] , f[(i-1)%3][g[k]][g[p]] + count(g[j])); &#125; &#125; int ans = -0x7fffff; for(int i = 1 ; i &lt;= tot ; ++i) for(int j = 1 ; j &lt;= tot ; ++j) if(!check(g[i],g[j])) ans = std::max(ans , f[n%3][g[i]][g[j]]); printf("%d",ans);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.33]]></title>
    <url>%2F2018%2F11%2F17%2FNo-33%2F</url>
    <content type="text"><![CDATA[[USACO4.1]麦香牛块Beef McNuggets题目描述农夫布朗的奶牛们正在进行斗争，因为它们听说麦当劳正在考虑引进一种新产品：麦香牛块。奶牛们正在想尽一切办法让这种可怕的设想泡汤。奶牛们进行斗争的策略之一是“劣质的包装”。“看，”奶牛们说，“如果你只用一次能装3块、6块或者10块的三种包装盒包装麦香牛块，你就不可能满足一次只想买1、2、4、5、7、8、11、14或者17块麦香牛块的顾客了。劣质的包装意味着劣质的产品。” 你的任务是帮助这些奶牛。给出包装盒的种类数N(1&lt;=N&lt;=10)和N个代表不同种类包装盒容纳麦香牛块个数的正整数(1&lt;=i&lt;=256)，输出顾客不能用上述包装盒(每种盒子数量无限)买到麦香牛块的最大块数。如果所有购买方案都能得到满足或者不存在不能买到块数的上限，则输出0。 不能买到的最大块数（倘它存在）不超过2,000,000,000。 输入输出格式输入格式： 第1行: 包装盒的种类数N 第2行到N+1行: 每个种类包装盒容纳麦香牛块的个数 输出格式： 输出文件只有一行数字：顾客不能用包装盒买到麦香牛块的最大块数或0(如果所有购买方案都能得到满足或者顾客不能买到的块数没有上限)。 输入输出样例输入样例#1： 123433610 输出样例#1： 117 说明题目翻译来自NOCOW。 USACO Training Section 4.1 题解同余最短路瞎跑，也不知怎么就对了 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define maxn 1005struct Node&#123; int v , k; bool operator &lt; (const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;;int p[maxn] , n , d[maxn];inline void SPDIJ(int s)&#123; std::priority_queue&lt;Node&gt; q; std::memset(d,-1,sizeof(d)); d[s] = 0; q.push((Node)&#123;d[s],s&#125;); while(!q.empty()) &#123; int k = q.top().k; q.pop(); for(int i = 2 ; i &lt;= n ; ++i)&#123; int v = (k + p[i]) % p[1]; if(d[v] &gt; d[k] + p[i] || d[v] == -1)&#123; d[v] = d[k] + p[i]; q.push((Node)&#123;d[v],v&#125;); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); std::sort(p+1,p+n+1); SPDIJ(0); for(int i = 0 ; i &lt; p[1] ; ++i) if(d[i] == -1)&#123; puts("0"); return 0; &#125; int ans = 0; for(int i = 0 ; i &lt; p[1] ; ++i) ans = std::max(ans , d[i] - p[1]); if(!ans)&#123; puts("0"); return 0; &#125; printf("%d\n",ans);&#125; 今天可能以结论题，数学/数论题为主 上午对着LNOI那道黑题想了一上午，血亏的感觉。。下午做做NOIp剩下的原题和USACO的题吧（天天爱跑步这种也属于神题，考场出了暴力都不一定对） [USACO15DEC]最大流Max Flow题目描述Farmer John has installed a new system of N-1N−1 pipes to transport milk between the NN stalls in his barn (2 \leq N \leq 50,0002≤N≤50,000), conveniently numbered 1 \ldots N1…N. Each pipe connects a pair of stalls, and all stalls are connected to each-other via paths of pipes. FJ is pumping milk between KK pairs of stalls (1 \leq K \leq 100,0001≤K≤100,000). For the iith such pair, you are told two stalls s_isi and t_iti, endpoints of a path along which milk is being pumped at a unit rate. FJ is concerned that some stalls might end up overwhelmed with all the milk being pumped through them, since a stall can serve as a waypoint along many of the KK paths along which milk is being pumped. Please help him determine the maximum amount of milk being pumped through any stall. If milk is being pumped along a path from s_isi to t_iti, then it counts as being pumped through the endpoint stalls s_isi and t_iti, as well as through every stall along the path between them. FJ给他的牛棚的N(2≤N≤50,000)个隔间之间安装了N-1根管道，隔间编号从1到N。所有隔间都被管道连通了。 FJ有K(1≤K≤100,000)条运输牛奶的路线，第i条路线从隔间si运输到隔间ti。一条运输路线会给它的两个端点处的隔间以及中间途径的所有隔间带来一个单位的运输压力，你需要计算压力最大的隔间的压力是多少。 输入输出格式输入格式： The first line of the input contains NN and KK. The next N-1N−1 lines each contain two integers xx and yy (x \ne yx≠y) describing a pipe between stalls xx and yy. The next KK lines each contain two integers ss and tt describing the endpoint stalls of a path through which milk is being pumped. 输出格式： An integer specifying the maximum amount of milk pumped through any stall in the barn. 输入输出样例1234567891011121314155 103 41 54 25 45 45 43 54 34 31 33 55 41 53 4 19 题解随手花20分钟写了个树上差分来弥补今天上午的败局 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int head[maxn] , cnt , n , c[maxn] , x , y , k , f[maxn] , top[maxn] , sz[maxn] , hs[maxn] , dep[maxn];struct edge&#123; int next , to;&#125;e[maxn*2];void dfs1(int x , int fx)&#123; f[x] = fx; dep[x] = dep[fx] + 1; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == fx) continue; dfs1(v , x); sz[x] += sz[v]; if(sz[v] &gt; sz[hs[x]]) hs[x] = v; &#125;&#125;void dfs2(int x , int topv)&#123; top[x] = topv; if(!hs[x]) return ; dfs2(hs[x] , topv); for(int i = head[x] ; i ; i = e[i].next)&#123; int v = e[i].to; if(v == f[x] || v == hs[x]) continue; dfs2(v , v); &#125;&#125;int LCA(int x , int y)&#123; while(top[x] != top[y])&#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); x = f[top[x]]; &#125; if(dep[x] &gt; dep[y]) std::swap(x,y); return x;&#125;void getDif(int x , int fx)&#123; for(int i = head[x] ; i ; i = e[i].next)&#123; if(e[i].to != fx) getDif(e[i].to , x) , c[x] += c[e[i].to]; &#125;&#125;inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i = 1 ; i &lt;= n -1 ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , add(y,x); dfs1(1,1); dfs2(1,1); int x , y; for(int i = 1 ; i &lt;= k ; ++i)&#123; scanf("%d%d",&amp;x,&amp;y); ++c[x] , ++c[y] , --c[LCA(x,y)] , --c[f[LCA(x,y)]]; &#125; getDif(1,1); int ans = -0x7ffffff; for(int i = 1 ; i &lt;= n ; ++i) ans = std::max(ans , c[i]); printf("%d",ans);&#125; [AHOI2005]航线规划题目描述对Samuel星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了Samuel星球所在的星系——一个巨大的由千百万星球构成的Samuel星系。 星际空间站的Samuel II巨型计算机经过长期探测，已经锁定了Samuel星系中许多星球的空间坐标，并对这些星球从1开始编号1、2、3……。 一些先遣飞船已经出发，在星球之间开辟探险航线。 探险航线是双向的，例如从1号星球到3号星球开辟探险航线，那么从3号星球到1号星球也可以使用这条航线。 例如下图所示： 在5个星球之间，有5条探险航线。 A、B两星球之间，如果某条航线不存在，就无法从A星球抵达B星球，我们则称这条航线为关键航线。 显然上图中，1号与5号星球之间的关键航线有1条：即为4-5航线。 然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时回复这些航线，可见两个星球之间的关键航线会越来越多。 假设在上图中，航线4-2（从4号星球到2号星球）被破坏。此时，1号与5号星球之间的关键航线就有3条：1-3，3-4，4-5。 小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。 输入输出格式输入格式： 第一行有两个整数N，M。表示有N个星球（1&lt; N &lt; 30000），初始时已经有M条航线（1 &lt; M &lt; 100000）。随后有M行，每行有两个不相同的整数A、B表示在星球A与B之间存在一条航线。接下来每行有三个整数C、A、B。C为1表示询问当前星球A和星球B之间有多少条关键航线；C为0表示在星球A和星球B之间的航线被破坏，当后面再遇到C为1的情况时，表示询问航线被破坏后，关键路径的情况，且航线破坏后不可恢复； C为-1表示输入文件结束，这时该行没有A,B的值。被破坏的航线数目与询问的次数总和不超过40000。 输出格式： 对每个C为1的询问，输出一行一个整数表示关键航线数目。 输入输出样例输入样例#1： 123456789105 51 21 33 44 54 21 1 50 4 21 5 1-1 输出样例#1： 1213 说明我们保证无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。在整个数据中，任意两个星球之间最多只可能存在一条直接的航线。 题解思维难度较高，实现复杂度很大，适合作为NOIp D2T3，这里说下思路。 由于太菜不会LCT，显然动态删边不会，因此就倒着来做。 将需要被删除的边先标记下 Tarjan求出所有边双连通分量，然后将图缩点成树 树链剖分。边对应点。初始点权均为1表示都是割边 开始倒着查询，到了修改只需要将边两边的点在树上的链全变成0，表示不再是割边，查询只需要查询两点间的值 这道题就做完了，由于时间关系，考虑我现在的水平做这题考场出了也做不出来。 [USACO13DEC]最优挤奶Optimal Milking题目描述Farmer John has recently purchased a new barn containing N milking machines (1 &lt;= N &lt;= 40,000), conveniently numbered 1..N and arranged in a row. Milking machine i is capable of extracting M(i) units of milk per day (1 &lt;= M(i) &lt;= 100,000). Unfortunately, the machines were installed so close together that if a machine i is in use on a particular day, its two neighboring machines cannot be used that day (endpoint machines have only one neighbor, of course). Farmer John is free to select different subsets of machines to operate on different days. Farmer John is interested in computing the maximum amount of milk he can extract over a series of D days (1 &lt;= D &lt;= 50,000). At the beginning of each day, he has enough time to perform maintenance on one selected milking machine i, thereby changing its daily milk output M(i) from that day forward. Given a list of these daily modifications, please tell Farmer John how much milk he can produce over D days (note that this number might not fit into a 32-bit integer). FJ最近买了1个新仓库, 内含N 个挤奶机,1 到N 编号并排成一行。 挤奶机i 每天能产出M(i) 单位的奶。不幸的是, 机器装得太近以至于如果一台机器i 在某天被使用, 那与它相邻的两台机器那一天不能被使用 (当然, 两端点处的机器分别只有一个与之相邻的机器)。 FJ 可自由选择不同的机器在不同的日子工作。 FJ感兴趣于计算在D 天内他能产出奶的最大值。在每天开始时, 他有足够的时间维护一个选中的挤奶机i, 从而改变它从那天起的每日产奶量M(i)。 给出这些每日的修改,请告诉FJ他D 天中能产多少奶。 输入输出格式输入格式： * Line 1: The values of N and D. * Lines 2..1+N: Line i+1 contains the initial value of M(i). * Lines 2+N..1+N+D: Line 1+N+d contains two integers i and m, indicating that Farmer John updates the value of M(i) to m at the beginning of day d. 输出格式： * Line 1: The maximum total amount of milk FJ can produce over D days. 输入输出样例输入样例#1： 1234567895 3 1 2 3 4 5 5 2 2 7 1 10 输出样例#1： 132 说明There are 5 machines, with initial milk outputs 1,2,3,4,5. On day 1, machine 5 is updated to output 2 unit of milk, and so on. On day one, the optimal amount of milk is 2+4 = 6 (also achievable as 1+3+2). On day two, the optimal amount is 7+4 = 11. On day three, the optimal amount is 10+3+2=15. 题意简述：给定n个点排成一排，每个点有一个点权，多次改变某个点的点权并将最大点独立集计入答案，输出最终的答案 题解想到了线段树但是一开始没想出来怎么维护。。。一开始只维护左边选右边不选和右边选左边不选，结果pushup发现有些情况不对，然后又加上两边都不选和两边都选就行了。 这个题最重要的有这么几点 所有数非负，本题最重要的条件之一，这意味着我们可以贪心地选取尽量长的，能带上端点就带上。 假如有时候我们发现子问题无法很好的转移或合并，牺牲一定的时间复杂度附加维护更多的信息也许是很正确的选择，本题中仅仅增加了一点常数。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long long#define max(a,b) (a) &gt; (b) ? (a) : (b)int n , p[maxn] , d;ll ans;struct SegmentTree&#123; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) ll f[maxn&lt;&lt;2] , g[maxn&lt;&lt;2] , h[maxn&lt;&lt;2] , t[maxn&lt;&lt;2];//both , left , right , none inline void pushup(int Node)&#123; t[Node] = max(h[ls(Node)] + t[rs(Node)] , g[rs(Node)] + t[ls(Node)]); h[Node] = max(f[rs(Node)] + t[ls(Node)] , h[rs(Node)] + h[ls(Node)]); g[Node] = max(f[ls(Node)] + t[rs(Node)] , g[ls(Node)] + g[rs(Node)]); f[Node] = max(f[ls(Node)] + h[rs(Node)] , f[rs(Node)] + g[ls(Node)]); &#125; void build(int l , int r , int Node) &#123; if(l == r)&#123; f[Node] = p[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(l , mid , ls(Node)); build(mid + 1 , r , rs(Node)); pushup(Node); &#125; void update(int pos , int l , int r , int Node , int v) &#123; if(l == r)&#123; f[Node] = v; p[l] = v; return; &#125; int mid = l + r &gt;&gt; 1; if(pos &lt;= mid) update(pos , l , mid , ls(Node) , v); if(pos &gt; mid) update(pos , mid + 1 , r , rs(Node) , v); pushup(Node); &#125; ll query()&#123; ll ans = 0;// printf("%lld %lld %lld %lld\n",f[1],g[1],h[1],t[1]); ans = max(ans , max(f[1],g[1])); ans = max(ans , max(h[1],t[1])); return ans; &#125;&#125;tr;int main()&#123; scanf("%d%d",&amp;n,&amp;d); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); tr.build(1,n,1); for(int i = 1 ; i &lt;= d ; ++i)&#123; int x , y; scanf("%d%d",&amp;x,&amp;y); tr.update(x,1,n,1,y); ans += tr.query(); &#125; printf("%lld",ans);&#125; [TJOI2007]线段题目描述在一个 n*n 的平面上，在每一行中有一条线段，第 i 行的线段的左端点是(i, L(i))，右端点是(i, R(i))，其中 1 ≤ L(i) ≤ R(i) ≤ n。 你从(1, 1)点出发，要求沿途走过所有的线段，最终到达(n, n)点，且所走的路程长度要尽量短。 更具体一些说，你在任何时候只能选择向下走一步（行数增加 1）、向左走一步（列数减少 1）或是向右走一步（列数增加 1）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。 输入输出格式输入格式： 输入文件的第一行有一个整数 n，以下 n 行，在第 i 行（总第(i+1)行）的两个整数表示 L(i)和 R(i)。 输出格式： 输出文件仅包含一个整数，你选择的最短路程的长度。 输入输出样例输入样例#1： 123456762 63 41 31 23 64 5 输出样例#1： 124 说明我们选择的路线是 123456(1,1) (1,6) (2,6) (2, 3) (3, 3) (3, 1) (4, 1) (4, 2) (5, 2) (5, 6) (6, 6) (6, 4) (6, 6) 不难计算得到，路程的总长度是 24。 100%的数据中，n ≤ 20 000。 题解这种是最套路的dp了。。然后我一开始还WA了。。。 一开始我设的 f(i,0/1)表示前i行到左/右端点最小值，然后转移加上上一条线段的长度什么的，结果挂了。 然后换成包括当前行就好转移了一点，就过了。。 难度低于D1T2 Code： 12345678910111213141516171819202122232425#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 500005int l[maxn] , r[maxn] , n , f[maxn][2];int abs(int x)&#123; return x &gt;= 0 ? x : (-x);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;l[i],&amp;r[i]); std::memset(f,0x7f,sizeof(f)); f[1][0] = r[1] - 1 + r[1] - l[1] , f[1][1] = r[1] - 1; for(int i = 2 ; i &lt;= n ; ++i)&#123; f[i][0] = std::min(f[i-1][0] + abs(l[i-1] - r[i]) + r[i] - l[i] + 1, f[i-1][1] + abs(r[i-1] - r[i]) + r[i] - l[i] + 1), f[i][1] = std::min(f[i-1][0] + abs(l[i-1] - l[i]) + r[i] - l[i] + 1, f[i-1][1] + abs(r[i-1] - l[i]) + r[i] - l[i] + 1); &#125; printf("%d",std::min(f[n][0] + abs(n - l[n]), f[n][1] + abs(n - r[n]))); &#125; [USACO08DEC]在农场万圣节Trick or Treat on the Farm题目描述每年，在威斯康星州，奶牛们都会穿上衣服，收集农夫约翰在N(1&lt;=N&lt;=100，000)个牛棚隔间中留下的糖果，以此来庆祝美国秋天的万圣节。 由于牛棚不太大，FJ通过指定奶牛必须遵循的穿越路线来确保奶牛的乐趣。为了实现这个让奶牛在牛棚里来回穿梭的方案，FJ在第i号隔间上张贴了一个“下一个隔间”Next_i(1&lt;=Next_i&lt;=N)，告诉奶牛要去的下一个隔间；这样，为了收集它们的糖果，奶牛就会在牛棚里来回穿梭了。 FJ命令奶牛i应该从i号隔间开始收集糖果。如果一只奶牛回到某一个她已经去过的隔间，她就会停止收集糖果。 在被迫停止收集糖果之前，计算一下每头奶牛要前往的隔间数（包含起点）。 输入格式第1行 整数n。 第2行到n+1行 每行包含一个整数 next_i 。 输出格式n行，第i行包含一个整数，表示第i只奶牛要前往的隔间数。 样例解释有4个隔间 隔间1要求牛到隔间1 隔间2要求牛到隔间3 隔间3要求牛到隔间2 隔间4要求牛到隔间3 牛1，从1号隔间出发，总共访问1个隔间； 牛2，从2号隔间出发，然后到三号隔间，然后到2号隔间，终止，总共访问2个隔间； 牛3，从3号隔间出发，然后到2号隔间，然后到3号隔间，终止，总共访问2个隔间； 牛4，从4号隔间出发，然后到3号隔间，然后到2号隔间，然后到3号隔间，终止，总共访问3个隔间。 翻译提供者：吃葡萄吐糖 题目描述Every year in Wisconsin the cows celebrate the USA autumn holiday of Halloween by dressing up in costumes and collecting candy that Farmer John leaves in the N (1 &lt;= N &lt;= 100,000) stalls conveniently numbered 1..N. Because the barn is not so large, FJ makes sure the cows extend their fun by specifying a traversal route the cows must follow. To implement this scheme for traveling back and forth through the barn, FJ has posted a ‘next stall number’ next_i (1 &lt;= next_i &lt;= N) on stall i that tells the cows which stall to visit next; the cows thus might travel the length of the barn many times in order to collect their candy. FJ mandates that cow i should start collecting candy at stall i. A cow stops her candy collection if she arrives back at any stall she has already visited. Calculate the number of unique stalls each cow visits before being forced to stop her candy collection. POINTS: 100 每年万圣节，威斯康星的奶牛们都要打扮一番，出门在农场的N个牛棚里转 悠，来采集糖果.她们每走到一个未曾经过的牛棚，就会采集这个棚里的1颗糖果. 农场不大，所以约翰要想尽法子让奶牛们得到快乐.他给每一个牛棚设置了一个“后继牛 棚”.牛棚i的后继牛棚是next_i 他告诉奶牛们，她们到了一个牛棚之后，只要再往后继牛棚走去， 就可以搜集到很多糖果.事实上这是一种有点欺骗意味的手段，来节约他的糖果. 第i只奶牛从牛棚i开始她的旅程．请你计算，每一只奶牛可以采集到多少糖果． 输入输出格式输入格式： * Line 1: A single integer: N * Lines 2..N+1: Line i+1 contains a single integer: next_i 输出格式： * Lines 1..N: Line i contains a single integer that is the total number of unique stalls visited by cow i before she returns to a stall she has previously visited. 输入输出样例输入样例#1： 123454 1 3 2 3 输出样例#1： 12341 2 2 3 说明 Four stalls. * Stall 1 directs the cow back to stall 1. * Stall 2 directs the cow to stall 3 * Stall 3 directs the cow to stall 2 * Stall 4 directs the cow to stall 3 Cow 1: Start at 1, next is 1. Total stalls visited: 1. Cow 2: Start at 2, next is 3, next is 2. Total stalls visited: 2. Cow 3: Start at 3, next is 2, next is 3. Total stalls visited: 2. Cow 4: Start at 4, next is 3, next is 2, next is 3. Total stalls visited: 3. 题解D1T2难度。 由于这个有向图非常简单，每个点均初度为一，一开始感觉记忆化搜索就能解决，后来发现环和链返回值不一样，又不好分类讨论。 于是这题我写的标算是 Tarjan+记忆化搜索显然记录每个点最多能获得多少糖果，初始每个点的值由Tarjan缩点后的强联通分量大小得到。 显然一个点连的出边的点的SCC糖果可以被它得到。记忆化搜索当前的点所在强联通分量的值是否已经最大，否则递归获得更多糖果。 时间复杂度 O(n+m)Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define maxn 100005int f[maxn] , n , next[maxn] , dfn[maxn] , low[maxn] , tot , scc[maxn] , idx;bool vis[maxn] , ins[maxn];std::stack&lt;int&gt; st;int dfs(int x)&#123; if(vis[scc[x]]) return f[scc[x]]; if(scc[x] == scc[next[x]])&#123; vis[scc[x]] = true; return f[scc[x]]; &#125; else&#123; vis[scc[x]] = true; return f[scc[x]] = f[scc[x]] + dfs(next[x]); &#125;&#125;void Tarjan(int x)&#123; dfn[x] = low[x] = ++idx ; st.push(x); ins[x] = true; if(!dfn[next[x]])&#123; Tarjan(next[x]); low[x] = std::min(low[x] , low[next[x]]); &#125; else if(ins[next[x]])&#123; low[x] = std::min(low[x] , dfn[next[x]]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x)&#123; scc[st.top()] = tot; ++f[tot]; ins[st.top()] = false; st.pop(); &#125; ++f[tot]; scc[st.top()] = tot; ins[st.top()] = false; st.pop(); &#125;&#125; int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i)&#123; scanf("%d",&amp;next[i]); &#125; for(int i = 1 ; i &lt;= n ; ++i)&#123; if(!dfn[i]) Tarjan(i); &#125; for(int i = 1 ; i &lt;= n ; ++i) if(!vis[scc[i]]) dfs(i); for(int i = 1 ; i &lt;= n ; ++i) printf("%d\n",f[scc[i]]);&#125; 比较基础的一道题还写错多次，实在是不应该。 P2661 信息传递题目描述有 nn 个同学（编号为 11 到 nn ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 ii 的同学的信息传递对象是编号为 T_iTi 的同学。 游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自 己的生日时，游戏结束。请问该游戏一共可以进行几轮？ 输入输出格式输入格式： 共22行。 第11行包含1个正整数 nn ，表示 nn 个人。 第22行包含 nn 个用空格隔开的正整数 T_1,T_2,\cdots\cdots,T_nT1,T2,⋯⋯,Tn ，其中第 ii 个整数 T_iTi 表示编号为 ii 的同学的信息传递对象是编号为 T_iTi 的同学， T_i \leq nTi≤n 且 T_i \neq iTi≠i 。 输出格式： 11个整数，表示游戏一共可以进行多少轮。 输入输出样例输入样例#1： 1252 4 2 3 1 输出样例#1： 13 说明样例1解释 游戏的流程如图所示。当进行完第33 轮游戏后， 44号玩家会听到 22 号玩家告诉他自己的生日，所以答案为 33。当然，第 33 轮游戏后，22号玩家、 33 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。 对于 30\%的数据， n ≤ 200； 对于 60\%的数据， n ≤ 2500； 对于100\%的数据， n ≤ 200000。 题解可以Tarjan后求最小环（不包括自环） Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#define maxn 200005int n , p[maxn] , dfn[maxn] , low[maxn] , idx , sz[maxn] , tot , scc[maxn];std::stack&lt;int&gt; st;bool ins[maxn];void Tarjan(int x)&#123; dfn[x] = low[x] = ++idx; st.push(x); ins[x] = true; if(!dfn[p[x]])&#123; Tarjan(p[x]); low[x] = std::min(low[x] , low[p[x]]); &#125; else if(ins[p[x]])&#123; low[x] = std::min(low[x] , dfn[p[x]]); &#125; if(dfn[x] == low[x])&#123; ++tot; while(st.top() != x) &#123; scc[st.top()] = tot; ins[st.top()] = false; ++sz[tot]; st.pop(); &#125; ++sz[tot]; ins[x] = false; scc[x] = tot; st.pop(); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); for(int i = 1 ; i &lt;= n ; ++i) if(!dfn[i]) Tarjan(i); int ans = 0x7fffff; for(int i = 1 ; i &lt;= tot ; ++i) if(sz[i] &gt; 1) ans = std::min(ans , sz[i]); printf("%d",ans);&#125; P1627 [CQOI2009]中位数]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.23]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-23%2F</url>
    <content type="text"><![CDATA[[USACO13NOV]没有找零No Change题目描述Farmer John is at the market to purchase supplies for his farm. He has in his pocket K coins (1 &lt;= K &lt;= 16), each with value in the range 1..100,000,000. FJ would like to make a sequence of N purchases (1 &lt;= N &lt;= 100,000), where the ith purchase costs c(i) units of money (1 &lt;= c(i) &lt;= 10,000). As he makes this sequence of purchases, he can periodically stop and pay, with a single coin, for all the purchases made since his last payment (of course, the single coin he uses must be large enough to pay for all of these). Unfortunately, the vendors at the market are completely out of change, so whenever FJ uses a coin that is larger than the amount of money he owes, he sadly receives no changes in return! Please compute the maximum amount of money FJ can end up with after making his N purchases in sequence. Output -1 if it is impossible for FJ to make all of his purchases. 约翰到商场购物，他的钱包里有K(1 &lt;= K &lt;= 16)个硬币，面值的范围是1..100,000,000。 约翰想按顺序买 N个物品(1 &lt;= N &lt;= 100,000)，第i个物品需要花费c(i)块钱，(1 &lt;= c(i) &lt;= 10,000)。 在依次进行的购买N个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。 请计算出在购买完N个物品后，约翰最多剩下多少钱。如果无法完成购买，输出-1 输入输出格式输入格式： * Line 1: Two integers, K and N. * Lines 2..1+K: Each line contains the amount of money of one of FJ’s coins. * Lines 2+K..1+N+K: These N lines contain the costs of FJ’s intended purchases. 输出格式： * Line 1: The maximum amount of money FJ can end up with, or -1 if FJ cannot complete all of his purchases. 输入输出样例输入样例#1： 123456789103 6 12 15 10 6 3 3 2 3 7 输出样例#1： 112 说明FJ has 3 coins of values 12, 15, and 10. He must make purchases in sequence of value 6, 3, 3, 2, 3, and 7. FJ spends his 10-unit coin on the first two purchases, then the 15-unit coin on the remaining purchases. This leaves him with the 12-unit coin. 题解一开始傻了写了个二进制搜索，直接枚举选的集合然后顺着买，这肯定不对因为改变顺序可能更优。 这个错误做法的时间复杂度是 O(2^kklogn)然后我们想假如我们要带上顺序，可以状态压缩dp!对于每个状态，我们只需要枚举最后一个加入的，让其最优，显然是个最优子结构。 恰好时间复杂度也是 O(2^kklogn)完美通过了本题。 顺便说下， logn是在前缀和上二分，由于价格都为正，因此前缀和满足单调性。（假如为负似乎就不可做了） Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005#define maxk 18int c[maxn] , p[maxn] , n , k , f[1&lt;&lt;maxk] , ans , s[maxn] , sum;int find(int x)&#123; int l = 0 , r = n , ans = 0; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if(s[mid] &lt;= x) ans = mid , l = mid + 1; else r = mid - 1; &#125; return ans;&#125;inline int calc(int Sta)&#123; int ans = sum; for(int i = 1 ; i &lt;= k ; ++i) if(Sta &amp; (1 &lt;&lt; (i-1) )) ans -= c[i]; return ans;&#125;int main()&#123; scanf("%d%d",&amp;k,&amp;n); for(int i = 1 ; i &lt;= k ; ++i) scanf("%d",&amp;c[i]) , sum += c[i]; for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); for(int i = 1 ; i &lt;= n ; ++i) s[i] = s[i-1] + p[i]; std::memset(f,-1,sizeof(f)); f[0] = 0; int Sets = (1&lt;&lt;k)-1; for(int i = 1 ; i &lt;= Sets ; ++i) for(int j = 1 ; j &lt;= k ; ++j) &#123; if(!(i &amp; (1&lt;&lt;(j-1)))) continue; f[i] = std::max(f[i] , find(s[f[i ^ (1 &lt;&lt; (j-1))]] + c[j])); &#125; ans = -1; for(int i = 1 ; i &lt;= Sets ; ++i) if(f[i] == n) ans = std::max(ans , calc(i)); if(ans &lt; 0) ans = -1; printf("%d",ans);&#125; 最后我也不知道我为什么傻逼的把ans写个极小值，结果输出错了3个点。。ans=-1即可。 感觉似乎又对状压dp运用的更好了呢 [NOI2011]道路修建题目描述在 W 星球上有 n 个国家。为了各自国家的经济发展，他们决定在各个国家 之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿 意修建恰好 n – 1 条双向道路。 每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 2 个、4 个国家，如果该道路长度为 1，则费用为 1×|2 – 4|=2。图中圆圈里的数字表示国 家的编号。 由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建 费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计 算出所需要的费用。请你帮助国王们设计一个这样的软件。 输入输出格式输入格式： 输入的第一行包含一个整数 n，表示 W 星球上的国家的数量，国家从 1 到 n 编号。 接下来 n – 1 行描述道路建设情况，其中第 i 行包含三个整数 ai、bi和 ci，表 示第 i 条双向道路修建在 ai与 bi两个国家之间，长度为 ci。 输出格式： 输出一个整数，表示修建所有道路所需要的总费用。 输入输出样例输入样例#1： 12345661 2 11 3 11 4 26 3 15 2 1 输出样例#1： 120 说明1≤ai, bi≤n 0≤ci≤10^6 2≤n≤10^6 题解充其量D2T1的难度。 任意选取点为根，dfs一个点子树大小，两部分城市数目即为子树大小和剩余部分。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 1000005#define ll long longll n , head[maxn] , sz[maxn], cnt , ans;struct edge&#123; ll next , to , dis;&#125;e[maxn * 2];void dfs(ll x , ll fx)&#123; sz[x] = 1; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs(e[i].to , x) , sz[x] += sz[e[i].to];&#125;inline int abs(ll x)&#123;return x &gt; 0 ? x : -x;&#125;void calc(ll x , ll fx , ll dis)&#123; ans += abs(sz[x] - (n - sz[x])) * dis; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) calc(e[i].to , x , e[i].dis);&#125;inline void add(ll x, ll y, ll dis)&#123; e[++cnt].next = head[x] ; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;int main()&#123; scanf("%lld",&amp;n); ll x , y, d; for(int i = 1 ; i &lt;= n-1 ; ++i) scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;d) , add(x,y,d) , add(y,x,d); dfs(1,0); calc(1,0,0); printf("%lld",ans);&#125; 求解线性同余方程组（任意模数）题目描述给定 n组非负整数 a_i, b_i，求解关于 x的方程组 \begin{cases} x \equiv b_1\ ({\rm mod}\ a_1) \\ x\equiv b_2\ ({\rm mod}\ a_2) \\ ... \\ x \equiv b_n\ ({\rm mod}\ a_n)\end{cases}的最小非负整数解。 输入输出格式输入格式： 输入第一行包含整数 n。 接下来 n行，每行两个非负整数 a_i, b_i。 输出格式： 输出一行，为满足条件的最小非负整数 xx。 输入输出样例输入样例#1： 1234311 625 933 17 输出样例#1： 1809 说明说明 n \leq 10^5, 1 \leq a_i \leq 10^{12}, 0 \leq b_i \leq 10^{12}, b_i < a_i，保证答案不超过 10^{18}。 请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。 数据保证有解 题解其实原理很简单，就是exgcd的合并。 对于第一个方程显然初始解 x = A_1 , p = B_1像数学归纳法一样，假如我们知道前k-1个方程的合并解 x_{k-1}和合并的模数 p_{k-1}，如何合并第k个方程呢？ p_{k-1} * x + (-y) * B_{k-1} = A_k - x_{k-1}将x解出后处理成非负（这时右边的解y也同样是非负）合并答案 x_k = x_{k-1} + x * p_{k-1}合并的新模数 p_k = p_{k-1} * B_{k-1} / gcd(p_{k-1} , B_{k-1})就是这么简单，却花了我1.5个小时。。 变菜了好多啊。。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long longll A[maxn] , B[maxn] , n;ll exgcd(ll a , ll b , ll&amp; x, ll&amp; y)&#123; if(!b) &#123; x = 1 , y = 0; return a; &#125; ll g = exgcd(b , a % b , y, x); y -= a/b * x; return g;&#125;inline ll mul(ll x , ll y , ll mod)&#123; ll ans = 0 , base = x; while(y) &#123; if(y &amp; 1) ans = (ans + base) % mod; (base &lt;&lt;= 1 ) %= mod; y &gt;&gt;= 1; &#125; return ans;&#125;ll EXCRT()&#123; ll ans = (A[1] % B[1] + B[1]) % B[1] , P1 = B[1] , x , y;//init first equation for(int i = 2 ; i &lt;= n ; ++i) &#123; ll a = P1 , b = B[i] , c = (A[i] - ans % b + b) % b , gcd = exgcd(a,b,x,y) , poc = b / gcd; x = mul(x , c / gcd , poc); x = (x + poc) % poc; // make sure x is a positive integer if(c % gcd) return -1; ans += x * P1; P1 *= poc; ans = (ans % P1 + P1) % P1; &#125; return ans;&#125;int main()&#123; scanf("%lld",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld%lld",&amp;B[i],&amp;A[i]); printf("%lld",EXCRT());&#125; 注意模数相乘有可能爆long long，在它们的lcm大于long long时，那可能只能用高精度了。。。 [TJOI2009]猜数字题目描述现有两组数字，每组k个，第一组中的数字分别为：a1，a2，…，ak表示，第二组中的数字分别用b1，b2，…，bk表示。其中第二组中的数字是两两互素的。求最小的非负整数n，满足对于任意的i，n - ai能被bi整除。 输入输出格式输入格式： 输入数据的第一行是一个整数k，（1 ≤ k ≤ 10）。接下来有两行，第一行是：a1，a2，…，ak，第二行是b1，b2，…，bk 输出格式： 输出所求的整数n。 输入输出样例输入样例#1： 12331 2 32 3 5 输出样例#1： 123 说明所有数据中，第一组数字的绝对值不超过109（可能为负数），第二组数字均为不超过6000的正整数，且第二组里所有数的乘积不超过1018 每个测试点时限1秒 注意：对于C/C++语言，对64位整型数应声明为long long，如使用scanf, printf函数（以及fscanf, fprintf等），应采用%lld标识符。 题解这道题的意义在于要注意A_i可以是负数。一开始就全处理成正的就好。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ll long longll A[maxn] , B[maxn] , n;ll exgcd(ll a , ll b , ll&amp; x, ll&amp; y)&#123; if(!b) &#123; x = 1 , y = 0; return a; &#125; ll g = exgcd(b , a % b , y, x); y -= a/b * x; return g;&#125;inline ll mul(ll x , ll y , ll mod)&#123; ll ans = 0 , base = x; while(y) &#123; if(y &amp; 1) ans = (ans + base) % mod; (base &lt;&lt;= 1 ) %= mod; y &gt;&gt;= 1; &#125; return ans;&#125;ll EXCRT()&#123; for(int i = 1 ; i &lt;= n ; ++i) A[i] = (A[i] % B[i] + B[i]) % B[i]; ll ans = A[1], P1 = B[1] , x , y;//init first equation for(int i = 2 ; i &lt;= n ; ++i) &#123; ll a = P1 , b = B[i] , c = (A[i] - ans % b + b) % b , gcd = exgcd(a,b,x,y) , poc = b / gcd; x = mul(x , c / gcd , poc); x = (x + poc) % poc; // make sure x is a positive integer if(c % gcd) return -1; ans += x * P1; P1 *= poc; ans = (ans % P1 + P1) % P1; &#125; return ans;&#125;int main()&#123; scanf("%lld",&amp;n); ll x; for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;A[i]); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;B[i]); printf("%lld",EXCRT());&#125; 「一本通 5.4 练习 1」涂抹果酱题目描述Tyvj 两周年庆典要到了，Sam 想为 Tyvj 做一个大蛋糕。蛋糕俯视图是一个 N×M 的矩形，它被划分成 N×M 个边长为 1×1 的小正方形区域（可以把蛋糕当成 NNN 行 MMM 列的矩阵）。蛋糕很快做好了，但光秃秃的蛋糕肯定不好看！所以，Sam 要在蛋糕的上表面涂抹果酱。果酱有三种，分别是红果酱、绿果酱、蓝果酱，三种果酱的编号分别为 1,2,31,2,31,2,3。为了保证蛋糕的视觉效果，Admin 下达了死命令：相邻的区域严禁使用同种果酱。但 Sam 在接到这条命令之前，已经涂好了蛋糕第 KKK 行的果酱，且无法修改。现在 Sam 想知道：能令 Admin 满意的涂果酱方案有多少种。请输出方案数%1e6。若不存在满足条件的方案，请输出 000。 输入格式输入共三行。第一行：N,MN, MN,M；第二行：KKK；第三行：MMM 个整数，表示第 KKK 行的方案。字母的详细含义见题目描述，其他参见样例。 输出格式输出仅一行，为可行的方案总数。 样例样例输入1232 2 1 2 3 样例输出13 样例说明 方案一 方案二 方案三 2 3 1 2 2 3 3 1 2 3 3 2 数据范围与提示对于 30% 的数据，1≤N×M≤20；对于 60% 的数据，1≤N≤1000,1≤M≤3；对于 100% 的数据，1≤N≤10000,1≤M≤5。 题解成功被一道傻逼题坑了2小时。 一看就知道是 O(n6^m)然后写完一交WA，然后逐渐失去意识没完没了调这破题了。 总结教训：心急吃不了热豆腐！勤于输出！ 想好了在写！（我是不会说今天下午我刚写了200行基环树HPD结果发现算法错了） 好吧上代码吧（就是把行压成三进制状态就可以了。。） 然后我又改成了位运算。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define maxn 10005#define mod 1000000#define maxm 6int f[maxn][1&lt;&lt;((maxm&lt;&lt;1)-1)] , cnt , g[1&lt;&lt;maxm&lt;&lt;1] , ks , k , n , m , x , mar;inline bool check(int x , int y)&#123; for(int i = 1 ; i &lt;= m ; ++i) &#123; if(x % 4 == y % 4) return false; x /= 4 , y /= 4; &#125; return true;&#125;void dfs(int tot , int cur , int las)&#123; cur &lt;&lt;= 2; if(tot == m + 1) &#123; cur &gt;&gt;= 2; g[++cnt] = cur; return; &#125; for(int i = 1 ; i &lt;= 3 ; ++i) if(las != i) dfs(tot + 1 , cur + i , i);&#125;void dp()&#123; bool flag = false; if(k == 1) &#123; f[1][ks] = 1; for(int i = 2 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= cnt ; ++j) for(int k = 1 ; k &lt;= cnt ; ++k) if(check(g[j],g[k])) (f[i][g[j]] += f[i-1][g[k]]) %= mod; &#125; else &#123; for(int i = 1 ; i &lt;= cnt ; ++i) f[1][g[i]] = 1; for(int i = 2 ; i &lt;= n ; ++i) &#123; if(i == k) &#123; for(int j = 1 ; j &lt;= cnt ; ++j) if(check(ks , g[j])) (f[i][ks] += f[i-1][g[j]]) %= mod; &#125; else&#123; for(int j = 1 ; j &lt;= cnt ; ++j) for(int k = 1 ; k &lt;= cnt ; ++k) if(check(g[j] , g[k])) (f[i][g[j]] += f[i-1][g[k]]) %= mod; &#125; &#125; &#125;&#125;void write(int x)&#123; if(!x)return; write(x/3); putchar(x%3+48);&#125;signed main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1 ; i &lt;= m ; ++i) scanf("%d",&amp;x) , ks &lt;&lt;= 2 , ks |= x; dfs(1,0,-1); dp(); // printf("%d",cnt); int ans = 0; for(int i = 1 ; i &lt;= cnt ; ++i) (ans += f[n][g[i]]) %= mod; printf("%d",ans);&#125; 注意保证每一位不冲突，假设最低位可以是1,2,3的话必须*4才行 P4932 浏览器题目背景__stdcall在用Edge玩slay的时候，鼠标会经常失灵，这让她十分痛苦，因此她决定也要让你们感受一下Edge制造的痛苦。 题目描述stdcall给了你n个点，第i个点有权值x[i]，对于两个点u和v，如果x[u] xor x[v]的结果在二进制表示下有奇数个1，那么在u和v之间连接一个Edge，现在stdcall想让你求出一共有多少个Edge。 如果你没能成功完成任务，那么__stdcall会让你痛苦一下，你这个测试点就没分了。 输入输出格式输入格式： 一行六个整数，n，a，b，c，d，x[0]。 n是点的个数，每个点的权值需要用如下的方式生成。 你需要使用a，b，c，d和x[0]生成一个数组x，生成方式是这样的。 x_i = (ax_{i-1}^2 + bx_{i-1} + c) \mod dxi=(axi−12+bxi−1+c)modd x[i]就是第i个点的权值，点的标号是1到n。 输出格式： 输出一个整数，表示一共有多少个Edge。 输入输出样例输入样例#1： 18 98 24 20 100 44 输出样例#1： 112 输入样例#2： 11000 952537 601907 686180 1000000 673601 输出样例#2： 1249711 说明我们用v表示权值中的最大值。 对于前20%的数据，n&lt;=10。 对于前40%的数据，n&lt;=100。 对于前60%的数据，n&lt;=1000。 对于前80%的数据，n&lt;=1e6。 对于前90%的数据，v&lt;=1e6。 对于100%的数据，n&lt;=1e7，v&lt;=1e9。 保证a，b，c，d，x[0]都是int内的非负整数。 题解感觉非常不好。 经过了10分钟的推理后我以为是道神题，一看题解刚看到奇偶性吓得我赶紧关掉题解。 我一下子想到我前面推理用的自反性(只是联想，并不是自反性) 两个1异或会同时消失，这不就是按照每个数里1的个数奇偶分类，然后乘法原理吗？？ 考试的时候一定要沉得住气，多写几个数试试，说不定能推出规律。平时常用的性质也要多积累。 往往位运算是按位统计，当然也要灵活看待。 Code： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define lowbit(x) (x &amp; -x)#define maxn 10000005long long ans , v[maxn] , n , a , b , c , d , tot[2];//bool isOdd[maxn];inline int bit(long long x)&#123; int ans; for(ans = 0 ; x ; x -= lowbit(x)) ++ans; return ans;&#125;int main()&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;a,&amp;b,&amp;c,&amp;d,&amp;v[0]); for(int i = 1 ; i &lt;= n ; ++i) v[i] = (a * v[i-1] % d* v[i-1] % d + b * v[i-1] % d + c) % d , ++tot[bit(v[i])&amp;1]; ans = tot[0] * tot[1]; printf("%lld",ans); &#125; 今天晚上同时看了zyf学姐关于Splay讲解的blog和luogu某课关于线段树的讲解（甚至包括主席树初步），感觉都听懂了。 Splay我终于查到将每次查询或者新建的节点旋转到根的原因了，是因为让查询频繁的节点尽量靠近跟。基本双旋和Splay操作的实现也都明白了，删除插入什么的就不用说的，只不过把Treap的回溯时旋转保证堆序变成了Splay操作来保证复杂度。 以前看某谷劣质题解一直没大听懂主席树原理（貌似没有讲原理的），今天听懂了233，顺便看懂了很不错的数组版主席树，先发下别人的模板，有空自己写吧（NOIp前可能不会写的吧。。） 总结下关于函数式线段树变种： 类似算法总结 1、静态整体Kth 滑稽吧…sort一遍就好了。 时间复杂度O(nlogn) 空间复杂度O(n) 2、动态整体Kth 离散化后开一棵权值线段树，每个位置的值表示这个位置对应的那个数（离散化后的）有多少个，向上维护和； 查询时先查询左子树和sum，比较k和sum的大小：若k&lt;=sum则说明第k小数在左子树中，递归查询左子树； 否则，这个数对应的就是右子树中第k-sum小的数，k-=sum，递归查询右子树。 时间复杂度 O(nlogn)空间复杂度O(n) 平衡树诸如Treap或Splay也都能胜任。 3、静态区间Kth 对每个点以其前缀开一棵权值线段树，那么任意一段区间均可以表示成为两棵权值线段树作差，即R位置的线段树减去L-1位置上的线段树 每个点开一棵线段树空间复杂度 O(n^2)，MLE，考虑到后一个位置相比于前一个位置的更改只有 logn个节点，所以使用主席树 时间复杂度 O(nlogn) 空间复杂度 O(nlogn)4、动态区间Kth(就是本题辣) 还是要想办法维护前缀和。如果只是同3、的前缀和的话，就要对前缀和进行 O(nlogn)的单次修改，显然TLE。 这里考虑用树状数组维护前缀和。修改时，可以只修改 logn个位置，复杂度 O(log^2n)； 查询时，依旧是R位置减去L-1位置，这时候不再是两棵线段树作差，而是log棵线段树与log棵线段树作差；跳的时候，log个节点一起跳到左子树/右子树 时间复杂度 O(nlog^2n) 空间复杂度 O(nlogn)Splay模板（非区间翻转的按权值建树）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;#define MAXN 1000000int ch[MAXN][2],f[MAXN],size[MAXN],cnt[MAXN],key[MAXN];int sz,root;inline void clear(int x)&#123; ch[x][0]=ch[x][1]=f[x]=size[x]=cnt[x]=key[x]=0;&#125;inline bool get(int x)&#123; return ch[f[x]][1]==x;&#125;inline void update(int x)&#123; if (x)&#123; size[x]=cnt[x]; if (ch[x][0]) size[x]+=size[ch[x][0]]; if (ch[x][1]) size[x]+=size[ch[x][1]]; &#125;&#125;inline void rotate(int x)&#123; int old=f[x],oldf=f[old],whichx=get(x); ch[old][whichx]=ch[x][whichx^1]; f[ch[old][whichx]]=old; ch[x][whichx^1]=old; f[old]=x; f[x]=oldf; if (oldf) ch[oldf][ch[oldf][1]==old]=x; update(old); update(x);&#125;inline void splay(int x)&#123; for (int fa;fa=f[x];rotate(x)) if (f[fa]) rotate((get(x)==get(fa))?fa:x); root=x;&#125;inline void insert(int x)&#123; if (root==0)&#123;sz++; ch[sz][0]=ch[sz][1]=f[sz]=0; root=sz; size[sz]=cnt[sz]=1; key[sz]=x; return;&#125; int now=root,fa=0; while(1)&#123; if (x==key[now])&#123; cnt[now]++; update(now); update(fa); splay(now); break; &#125; fa=now; now=ch[now][key[now]&lt;x]; if (now==0)&#123; sz++; ch[sz][0]=ch[sz][1]=0; f[sz]=fa; size[sz]=cnt[sz]=1; ch[fa][key[fa]&lt;x]=sz; key[sz]=x; update(fa); splay(sz); break; &#125; &#125;&#125;inline int find(int x)&#123; int now=root,ans=0; while(1)&#123; if (x&lt;key[now]) now=ch[now][0]; else&#123; ans+=(ch[now][0]?size[ch[now][0]]:0); if (x==key[now])&#123; splay(now); return ans+1; &#125; ans+=cnt[now]; now=ch[now][1]; &#125; &#125;&#125;inline int findx(int x)&#123; int now=root; while(1)&#123; if (ch[now][0]&amp;&amp;x&lt;=size[ch[now][0]]) now=ch[now][0]; else&#123; int temp=(ch[now][0]?size[ch[now][0]]:0)+cnt[now]; if (x&lt;=temp) return key[now]; x-=temp; now=ch[now][1]; &#125; &#125;&#125;inline int pre()&#123; int now=ch[root][0]; while (ch[now][1]) now=ch[now][1]; return now;&#125;inline int next()&#123; int now=ch[root][1]; while (ch[now][0]) now=ch[now][0]; return now;&#125;inline void del(int x)&#123; int whatever=find(x); if (cnt[root]&gt;1)&#123;cnt[root]--; update(root); return;&#125; if (!ch[root][0]&amp;&amp;!ch[root][1]) &#123;clear(root); root=0; return;&#125; if (!ch[root][0])&#123; int oldroot=root; root=ch[root][1]; f[root]=0; clear(oldroot); return; &#125; else if (!ch[root][1])&#123; int oldroot=root; root=ch[root][0]; f[root]=0; clear(oldroot); return; &#125; int leftbig=pre(),oldroot=root; splay(leftbig); ch[root][1]=ch[oldroot][1]; f[ch[oldroot][1]]=root; clear(oldroot); update(root); &#125;int main()&#123; int n,opt,x; scanf("%d",&amp;n); for (int i=1;i&lt;=n;++i)&#123; scanf("%d%d",&amp;opt,&amp;x); switch(opt)&#123; case 1: insert(x); break; case 2: del(x); break; case 3: printf("%d\n",find(x)); break; case 4: printf("%d\n",findx(x)); break; case 5: insert(x); printf("%d\n",key[pre()]); del(x); break; case 6: insert(x); printf("%d\n",key[next()]); del(x); break; &#125; &#125;&#125; 主席树（静态区间第k大） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;queue&gt;#define rep(i, x, y) for (int i = (x); i &lt;= (y); i ++)#define down(i, x, y) for (int i = (x); i &gt;= (y); i --)#define mid (l+r)/2#define lc o&lt;&lt;1#define rc o&lt;&lt;1|1#define pb push_back#define mp make_pair#define Pair pair&lt;int, int&gt;#define F first#define S second#define B begin()#define E end()using namespace std;typedef long long LL;//head const int N = 100010, LOG = 20;int n, m, q, tot = 0;int a[N], b[N];int T[N], sum[N*LOG], L[N*LOG], R[N*LOG]; inline int build(int l, int r)&#123; int rt = ++ tot; if (l &lt; r)&#123; L[rt] = build(l, mid); R[rt] = build(mid+1, r); &#125; return rt;&#125; inline int update(int pre, int l, int r, int x)&#123; int rt = ++ tot; L[rt] = L[pre]; R[rt] = R[pre]; sum[rt] = sum[pre] + 1; if (l &lt; r)&#123; if (x &lt;= mid) L[rt] = update(L[pre], l, mid, x); else R[rt] = update(R[pre], mid+1, r, x); &#125; return rt;&#125; inline int query(int u, int v, int l, int r, int k)&#123; if (l == r) return l; int x = sum[L[v]] - sum[L[u]]; if (x &gt;= k) return query(L[u], L[v], l, mid, k); else return query(R[u], R[v], mid+1, r, k-x);&#125; int main()&#123; int Test; scanf("%d", &amp;Test); while (Test --)&#123; tot = 0; memset(T, 0, sizeof T); memset(sum, 0, sizeof sum); memset(L, 0, sizeof L); memset(R, 0, sizeof R); scanf("%d%d", &amp;n, &amp;q); rep(i, 1, n) scanf("%d", &amp;a[i]), b[i] = a[i]; sort(b+1, b+1+n); m = unique(b+1, b+1+n)-b-1; T[0] = build(1, m); rep(i, 1, n)&#123; a[i] = lower_bound(b+1, b+1+m, a[i]) - b; T[i] = update(T[i-1], 1, m, a[i]); &#125; while (q --)&#123; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); int p = query(T[x-1], T[y], 1, m, z); printf("%d\n", b[p]); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.26]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-26%2F</url>
    <content type="text"><![CDATA[[USACO11NOV]高于中位数Above the Median题目描述Farmer John has lined up his N (1 &lt;= N &lt;= 100,000) cows in a row to measure their heights; cow i has height H_i (1 &lt;= H_i &lt;= 1,000,000,000) nanometers—FJ believes in precise measurements! He wants to take a picture of some contiguous subsequence of the cows to submit to a bovine photography contest at the county fair. The fair has a very strange rule about all submitted photos: a photograph is only valid to submit if it depicts a group of cows whose median height is at least a certain threshold X (1 &lt;= X &lt;= 1,000,000,000). For purposes of this problem, we define the median of an array A[0…K] to be A[ceiling(K/2)] after A is sorted, where ceiling(K/2) gives K/2 rounded up to the nearest integer (or K/2 itself, it K/2 is an integer to begin with). For example the median of {7, 3, 2, 6} is 6, and the median of {5, 4, 8} is 5. Please help FJ count the number of different contiguous subsequences of his cows that he could potentially submit to the photography contest. 给出一串数字，问中位数大于等于X的连续子串有几个。（这里如果有偶数个数，定义为偏大的那一个而非中间取平均） 输入输出格式输入格式： * Line 1: Two space-separated integers: N and X. * Lines 2..N+1: Line i+1 contains the single integer H_i. 输出格式： * Line 1: The number of subsequences of FJ’s cows that have median at least X. Note this may not fit into a 32-bit integer. 输入输出样例输入样例#1： 123454 6 10 5 6 2 输出样例#1： 17 说明FJ’s four cows have heights 10, 5, 6, 2. We want to know how many contiguous subsequences have median at least 6. There are 10 possible contiguous subsequences to consider. Of these, only 7 have median at least 6. They are {10}, {6}, {10, 5}, {5, 6}, {6, 2}, {10, 5, 6}, {10, 5, 6, 2}. 题解这道题放到D1T2我就GG了。 对于中位数我们得牢牢抓住一个相对关系。 假如一个区间内， 那么这个区间的中位数就会大于等于x。 所以让前缀和记录i之前有多少个（大于等于x的数 - 小于x的数 ） 然后问题就变成了顺序对，扫描线+树状数组可以完成，时间复杂度为 O(nlogn)但是！！别忘了可能出现0，所以权值的位置+上n，而且别忘了1~i整个区间! Code： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int bit[maxn&lt;&lt;1] , n , s[maxn] , k;long long ans;inline int query(int x)&#123; int ans = 0; for(int i = x ; i ; i -= (i &amp; -i)) ans += bit[i]; return ans;&#125;inline void update(int x , int v)&#123; for(int i = x ; i &lt;= 2 * n; i += (i &amp; -i)) bit[i] += v;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); int x; for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%d",&amp;x); if(x &gt;= k) s[i] = s[i-1] + 1; else s[i] = s[i-1] - 1; &#125; for(int i = 1 ; i &lt;= n ; ++i) &#123; ans += query(s[i]+n); if(s[i] &gt;= 0) ++ans; update(s[i]+n,1); &#125; printf("%lld",ans);&#125; [USACO08NOV]光开关Light Switching题目描述Farmer John tries to keep the cows sharp by letting them play with intellectual toys. One of the larger toys is the lights in the barn. Each of the N (2 &lt;= N &lt;= 100,000) cow stalls conveniently numbered 1..N has a colorful light above it. At the beginning of the evening, all the lights are off. The cows control the lights with a set of N pushbutton switches that toggle the lights; pushing switch i changes the state of light i from off to on or from on to off. The cows read and execute a list of M (1 &lt;= M &lt;= 100,000) operations expressed as one of two integers (0 &lt;= operation &lt;= 1). The first kind of operation (denoted by a 0 command) includes two subsequent integers S_i and E_i (1 &lt;= S_i &lt;= E_i &lt;= N) that indicate a starting switch and ending switch. They execute the operation by pushing each pushbutton from S_i through E_i inclusive exactly once. The second kind of operation (denoted by a 1 command) asks the cows to count how many lights are on in the range given by two integers S_i and E_i (1 &lt;= S_i &lt;= E_i &lt;= N) which specify the inclusive range in which the cows should count the number of lights that are on. Help FJ ensure the cows are getting the correct answer by processing the list and producing the proper counts. 灯是由高科技——外星人鼠标操控的。你只要左击两个灯所连的鼠标， 这两个灯，以及之间的灯都会由暗变亮，或由亮变暗。右击两个灯所连的鼠 标，你就可以知道这两个灯，以及之间的灯有多少灯是亮的。起初所有灯都是暗的，你的任务是在LZ之前算出灯的亮灭。 输入输出格式输入格式： 第1 行: 用空格隔开的两个整数N 和M，n 是灯数 第2..M+1 行: 每行表示一个操作, 有三个用空格分开的整数: 指令号, S_i 和E_i 第1 种指令(用0 表示)包含两个数字S_i 和E_i (1 &lt;= S_i &lt;= E_i &lt;= N), 它们表示起 始开关和终止开关. 表示左击 第2 种指令(用1 表示)同样包含两个数字S_i 和E_i (1 &lt;= S_i &lt;= E_i &lt;= N), 不过这 种指令是询问从S_i 到E_i 之间的灯有多少是亮着的. 输出格式： 输入输出样例输入样例#1： 1234564 50 1 20 2 41 2 30 2 41 1 4 输出样例#1： 1212 说明 原题时间限制为2s，内存限制为16M 题解一道线段树基础题，标记维护什么的不难。 除了把pushup写成+=一切都好 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005#define ls(x) (x&lt;&lt;1)#define rs(x) (x&lt;&lt;1|1)int sum[maxn&lt;&lt;2] , xr[maxn&lt;&lt;2] , n , m , x , y , op;inline void pushup(int Node)&#123; sum[Node] = sum[ls(Node)] + sum[rs(Node)];&#125;inline void pushdown(int Node , int ln , int rn)&#123; if(xr[Node])&#123; sum[ls(Node)] = ln - sum[ls(Node)]; sum[rs(Node)] = rn - sum[rs(Node)]; xr[ls(Node)] ^= xr[Node]; xr[rs(Node)] ^= xr[Node]; xr[Node] ^= 1; &#125;&#125;inline void update(int L , int R , int l , int r , int Node)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; xr[Node] ^= 1; sum[Node] = (r-l+1) - sum[Node]; return; &#125; int mid = l + r &gt;&gt; 1; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) update(L , R , l , mid , ls(Node)); if(R &gt; mid) update(L , R , mid + 1 , r , rs(Node)); pushup(Node);&#125;int query(int L , int R , int l , int r , int Node)&#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; return sum[Node]; &#125; int mid = l + r &gt;&gt; 1 , ans = 0; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) ans += query(L , R , l , mid , ls(Node)); if(R &gt; mid) ans += query(L , R , mid + 1 , r , rs(Node)); return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= m ; ++i) &#123; scanf("%d",&amp;op); if(!op)&#123; scanf("%d%d",&amp;x,&amp;y); update(x,y,1,n,1); &#125; else&#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",query(x,y,1,n,1)); &#125; &#125;&#125; [USACO10OCT]汽水机Soda Machine题意翻译为了满足fj所有的N(1&lt;=n&lt;=50000)头奶牛的需求，fj新买了一台汽水机。他想找到一个最完美的位置来安放它。 奶牛的牧场可以被表示为一个一维数轴，第i个奶牛被放牧的区间是[Ai…Bi]（包含端点），fj可以把汽水机放在[1..1,000,000,000]。 因为奶牛们都懒得要死，她们想尽可能的少移动。她们希望汽水机被放在自己的放牧区间内。 遗憾的是，fj并不总能满足所有奶牛的要求，所以他想请你帮忙算出他能满足的奶牛数目 题目描述To meet the ever-growing demands of his N (1 &lt;= N &lt;= 50,000) cows, Farmer John has bought them a new soda machine. He wants to figure out the perfect place to install the machine. The field in which the cows graze can be represented as a one-dimensional number line. Cow i grazes in the range A_i..B_i (1 &lt;= A_i &lt;= B_i; A_i &lt;= B_i &lt;= 1,000,000,000) (a range that includes its endpoints), and FJ can place the soda machine at any integer point in the range 1..1,000,000,000. Since cows are extremely lazy and try to move as little as possible, each cow would like to have the soda machine installed within her grazing range. Sadly, it is not always possible to satisfy every cow’s desires. Thus FJ would like to know the largest number of cows that can be satisfied. To demonstrate the issue, consider four cows with grazing ranges 3..5, 4..8, 1..2, and 5..10; below is a schematic of their grazing ranges: 123451 2 3 4 5 6 7 8 9 10 11 12 13|---|---|---|---|---|---|---|---|---|---|---|---|-... aaaaaaaaa bbbbbbbbbbbbbbbbbccccc ddddddddddddddddddddd As can be seen, the first, second and fourth cows share the point 5, but the third cow’s grazing range is disjoint. Thus, a maximum of 3 cows can have the soda machine within their grazing range. 输入输出格式输入格式： * Line 1: A single integer: N * Lines 2..N+1: Line i+1 contains two space-separated integers: A_i and B_i 输出格式： * Line 1: A single integer representing the largest number of cows whose grazing intervals can all contain the soda machine. 输入输出样例输入样例#1： 123454 3 5 4 8 1 2 5 10 输出样例#1： 13 说明If the soda machine is placed at location 5, cows 1, 2, and 4 can be satisfied. It is impossible to satisfy all four cows. 题解显然由于坐标太大，需要离散化。 那怎么找数轴上被覆盖次数最多的点呢？这就是一个扫描线的思想，显然被覆盖次数最多的点一定由两个离散化的端点构成。 因此我们把点记录左右端点属性按照大小离散化 然后还原线段在线段树上做区间覆盖， 之后对每个离散化的点查询被覆盖次数即可，正确性已经说明：被覆盖次数最多的区间必定由两个端点构成，否则反证易知这个区间内还有其他点和左端点构成被覆盖次数最多的区间，由扫描线的原理可知这是不会出现的。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ls(x) (x&lt;&lt;1)#define rs(x) (x&lt;&lt;1|1)#define maxn 100005struct Node&#123; int v , type , k; bool operator &lt;(const Node&amp; x)const&#123; return v &lt; x.v; &#125;&#125;p[maxn];int L[maxn] , R[maxn] , sum[maxn&lt;&lt;2] , add[maxn&lt;&lt;2] , ans , n , cnt , tot;inline void pushup(int Node)&#123; sum[Node] = sum[ls(Node)] + sum[rs(Node)];&#125;inline void pushdown(int Node , int ln , int rn)&#123; if(add[Node])&#123; sum[ls(Node)] += ln * add[Node]; sum[rs(Node)] += rn * add[Node]; add[ls(Node)] += add[Node]; add[rs(Node)] += add[Node]; add[Node] = 0; &#125;&#125;void update(int L , int R , int l , int r , int Node , int v)&#123; if(L &lt;= l &amp;&amp; r &lt;= R)&#123; sum[Node] += (r-l+1) * v; add[Node] += v; return; &#125; int mid = l + r &gt;&gt; 1; if(L &lt;= mid) update(L , R , l , mid , ls(Node) , v); if(R &gt; mid) update(L , R , mid + 1 , r , rs(Node) , v); pushup(Node);&#125;int query(int L , int R , int l , int r , int Node)&#123; if(l == r)&#123; return sum[Node]; &#125; int mid = l + r &gt;&gt; 1 , ans = 0; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) ans += query(L , R , l , mid, ls(Node)); if(R &gt; mid) ans += query(L , R , mid + 1 , r , rs(Node)); return ans;&#125;int main()&#123; scanf("%d",&amp;n); int x , y; for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); p[++cnt].v = x , p[cnt].type = 0 , p[cnt].k = i; p[++cnt].v = y , p[cnt].type = 1 , p[cnt].k = i; &#125; std::sort(p+1,p+cnt+1); for(int i = 1 ; i &lt;= cnt ; ++i) &#123; if(p[i].type)&#123; if(p[i].v == p[i-1].v) R[p[i].k] = tot; else R[p[i].k] = ++tot; &#125; else&#123; if(p[i].v == p[i-1].v) L[p[i].k] = tot; else L[p[i].k] = ++tot; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) update(L[i] , R[i] , 1 , tot , 1 , 1); for(int i = 1; i &lt;= tot ; ++i) ans = std::max(ans , query(i,i,1,tot,1)); printf("%d",ans);&#125; P2345 奶牛集会题目背景MooFest, 2004 Open 题目描述约翰的N 头奶牛每年都会参加“哞哞大会”。哞哞大会是奶牛界的盛事。集会上的活动很 多，比如堆干草，跨栅栏，摸牛仔的屁股等等。它们参加活动时会聚在一起，第i 头奶牛的坐标为Xi，没有两头奶牛的坐标是相同的。奶牛们的叫声很大，第i 头和第j 头奶牛交流，会发出max{Vi; Vj}×|Xi − Xj | 的音量，其中Vi 和Vj 分别是第i 头和第j 头奶牛的听力。假设每对奶牛之间同时都在说话，请计算所有奶牛产生的音量之和是多少。 输入输出格式输入格式： • 第一行：单个整数N，1 ≤ N ≤ 20000 • 第二行到第N + 1 行：第i + 1 行有两个整数Vi 和Xi，1 ≤ Vi ≤ 20000; 1 ≤ Xi ≤ 20000 输出格式： • 单个整数：表示所有奶牛产生的音量之和 输入输出样例输入样例#1： 1234543 12 52 64 3 输出样例#1： 157 题解独立切题的感觉真好。 这道题分析了一波，感觉数据真弱emmmm ， 要我出数据 n]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.15]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-25%2F</url>
    <content type="text"><![CDATA[高斯消元法感觉这个算法没什么可说的，其实就是将每个未知数系数绝对值最大那一行将这个未知数当成主元，按顺序消去其他行，最后得到上三角矩阵后不断回带即可。 不过似乎还有点问题，以后再调先这样用着吧（原理肯定是对的了） Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define maxn 555const double eps = 1e-8;double A[maxn][maxn];bool flag;int n ;void Gauss() &#123; for(int i = 0; i &lt; n; i ++) &#123;//for each row(varieble) int r = i; for(int j = i + 1; j &lt; n; j ++) if(fabs(A[j][i]) &gt; fabs(A[r][i])) r = j; if(r != i) for(int j = 0; j &lt;= n; j ++) std :: swap(A[r][j], A[i][j]); for(int j = n; j &gt;= i; j --) &#123; for(int k = i + 1; k &lt; n; k ++) A[k][j] -= A[k][i] / A[i][i] * A[i][j]; &#125; &#125; for(int i = n - 1; i &gt;= 0; i --) &#123; for(int j = i + 1; j &lt; n; j ++)&#123; A[i][n] -= A[j][n] * A[i][j]; &#125; if(fabs(A[i][i]) &lt; eps &amp;&amp; fabs(A[i][n]) &gt; eps)&#123; puts("-1") ; flag = true; return; &#125; else if(fabs(A[i][n]) &lt; eps)&#123; puts("0"); flag = true; return; &#125; A[i][n] /= A[i][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 0 ; i &lt; n ; ++i) for(int j = 0 ; j &lt;= n ; ++j) scanf("%lf",&amp;A[i][j]); Gauss(); if(flag) return 0; for(int i = 0 ; i &lt; n ; ++i) printf("x%d=%.2lf\n",i+1,A[i][n]);&#125; 判断无穷解和负解还有点问题。 注意如果当前主元系数为0，就要跳过，否则会出错！ Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define maxn 555const double eps = 1e-8;double A[maxn][maxn];bool flag;int n ;void Gauss() &#123; for(int i = 0; i &lt; n; i ++) &#123;//for each row(varieble) int r = i; for(int j = i + 1; j &lt; n; j ++) if(fabs(A[j][i]) &gt; fabs(A[r][i])) r = j; if(r != i) for(int j = 0; j &lt;= n; j ++) std :: swap(A[r][j], A[i][j]); if(fabs(A[i][i]) &lt; eps) continue; for(int j = n; j &gt;= i; j --) &#123; for(int k = i + 1; k &lt; n; k ++) A[k][j] -= A[k][i] / A[i][i] * A[i][j]; &#125; &#125; puts("The Matrix now :"); for(int i = 0 ; i &lt; n ; ++i) &#123; for(int j = 0 ; j &lt;= n ; ++j) printf("%.2lf " , A[i][j]); putchar(10); &#125; for(int i = n - 1; i &gt;= 0; i --) &#123; for(int j = i + 1; j &lt; n; j ++)&#123; A[i][n] -= A[j][n] * A[i][j]; &#125; if(fabs(A[i][i]) &lt; eps &amp;&amp; fabs(A[i][n]) &gt; eps)&#123; puts("-1") ; flag = true; return; &#125; if(fabs(A[i][n]) &lt; eps &amp;&amp; fabs(A[i][i]) &lt; eps)&#123; puts("0"); flag = true; return; &#125; A[i][n] /= A[i][i]; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 0 ; i &lt; n ; ++i) for(int j = 0 ; j &lt;= n ; ++j) scanf("%lf",&amp;A[i][j]); Gauss(); if(flag) return 0; for(int i = 0 ; i &lt; n ; ++i) printf("x%d=%.2lf\n",i+1,A[i][n]);&#125; 90分代码 在回带之前加了奇怪的判断就过了，不过一般情况下似乎不用吧 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// luogu-judger-enable-o2#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define maxn 555const double eps = 1e-8;double A[maxn][maxn];bool flag;int n ;void Gauss() &#123; for(int i = 0; i &lt; n; i ++) &#123;//for each row(varieble) int r = i; for(int j = i + 1; j &lt; n; j ++) if(fabs(A[j][i]) &gt; fabs(A[r][i])) r = j; if(r != i) for(int j = 0; j &lt;= n; j ++) std :: swap(A[r][j], A[i][j]); if(fabs(A[i][i]) &lt; eps) continue; for(int j = n; j &gt;= i; j --) &#123; for(int k = i + 1; k &lt; n; k ++) A[k][j] -= A[k][i] / A[i][i] * A[i][j]; &#125; &#125; for(int i = 0 ; i &lt; n ; ++i) &#123; bool IF = false , ALL = false; for(int j = 0 ; j &lt; n ; ++j) if(fabs(A[i][j]) &gt; eps) IF = true; if(fabs(A[i][n]) &gt; eps) ALL = true; if(!IF)&#123; if(!ALL) &#123; puts("0"); flag = true; return; &#125; else &#123; puts("-1") ; flag = true ; return; &#125; &#125; &#125; for(int i = n - 1; i &gt;= 0; i --) &#123; for(int j = i + 1; j &lt; n; j ++)&#123; A[i][n] -= A[j][n] * A[i][j]; &#125; if(fabs(A[i][i]) &lt; eps)&#123; if(fabs(A[i][n]) &lt; eps)&#123; puts("0") , flag = true; return; &#125; else if(fabs(A[i][n]) &gt; eps)&#123;//ax = b puts("-1") , flag = true; return; &#125; &#125; A[i][n] /= A[i][i]; &#125; &#125;int main()&#123; scanf("%d",&amp;n); for(int i = 0 ; i &lt; n ; ++i) for(int j = 0 ; j &lt;= n ; ++j) scanf("%lf",&amp;A[i][j]); Gauss(); if(flag) return 0; for(int i = 0 ; i &lt; n ; ++i) printf("x%d=%.2lf\n",i+1,A[i][n]);&#125; [USACO08OCT]牧场散步Pasture Walking题目描述The N cows (2 &lt;= N &lt;= 1,000) conveniently numbered 1..N are grazing among the N pastures also conveniently numbered 1..N. Most conveniently of all, cow i is grazing in pasture i. Some pairs of pastures are connected by one of N-1 bidirectional walkways that the cows can traverse. Walkway i connects pastures A_i and B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N) and has a length of L_i (1 &lt;= L_i &lt;= 10,000). The walkways are set up in such a way that between any two distinct pastures, there is exactly one path of walkways that travels between them. Thus, the walkways form a tree. The cows are very social and wish to visit each other often. Ever in a hurry, they want you to help them schedule their visits by computing the lengths of the paths between 1 &lt;= L_i &lt;= 10,000 pairs of pastures (each pair given as a query p1,p2 (1 &lt;= p1 &lt;= N; 1 &lt;= p2 &lt;= N). POINTS: 200 有N(2&lt;=N&lt;=1000)头奶牛，编号为1到W，它们正在同样编号为1到N的牧场上行走.为了方 便，我们假设编号为i的牛恰好在第i号牧场上. 有一些牧场间每两个牧场用一条双向道路相连，道路总共有N - 1条，奶牛可以在这些道路 上行走.第i条道路把第Ai个牧场和第Bi个牧场连了起来(1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N)，而它的长度 是 1 &lt;= L_i &lt;= 10,000.在任意两个牧场间，有且仅有一条由若干道路组成的路径相连.也就是说，所有的道路构成了一棵树. 奶牛们十分希望经常互相见面.它们十分着急，所以希望你帮助它们计划它们的行程，你只 需要计算出Q(1 &lt; Q &lt; 1000)对点之间的路径长度•每对点以一个询问p1,p2 (1 &lt;= p1 &lt;= N; 1 &lt;= p2 &lt;= N). 的形式给出. 输入输出格式输入格式： * Line 1: Two space-separated integers: N and Q * Lines 2..N: Line i+1 contains three space-separated integers: A_i, B_i, and L_i * Lines N+1..N+Q: Each line contains two space-separated integers representing two distinct pastures between which the cows wish to travel: p1 and p2 输出格式： * Lines 1..Q: Line i contains the length of the path between the two pastures in query i. 输入输出样例输入样例#1： 1234564 2 2 1 2 4 3 2 1 4 3 1 2 3 2 输出样例#1： 122 7 说明Query 1: The walkway between pastures 1 and 2 has length 2. Query 2: Travel through the walkway between pastures 3 and 4, then the one between 4 and 1, and finally the one between 1 and 2, for a total length of 7. 题解按照HPD的原理自己试着写了写HPD LCA，发现特别好用！简短还快！ Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int head[maxn] , cnt , n , m , s[maxn];struct edge&#123; int next , to , dis;&#125;e[maxn*2];inline void add(int x , int y , int d)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;struct HPD&#123; int f[maxn] , top[maxn] , dep[maxn] , hs[maxn], sz[maxn]; void dfs1(int x , int fx) &#123; dep[x] = dep[fx] + 1; f[x] = fx; sz[x] = 1; int hson = 0; for(int i = head[x] ; i ; i = e[i].next) &#123; if(e[i].to == fx) continue; dfs1(e[i].to , x); sz[x] += sz[e[i].to]; if(sz[e[i].to] &gt; sz[hson]) hson = e[i].to; &#125; hs[x] = hson; &#125; void dfs2(int x , int tp) &#123; top[x] = tp; if(!hs[x]) return; dfs2(hs[x], tp); for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != f[x] &amp;&amp; e[i].to != hs[x]) dfs2(e[i].to , e[i].to); &#125; inline int LCA(int x , int y) &#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); x = f[top[x]]; &#125; return dep[x] &gt; dep[y] ? y : x; &#125;&#125; tr;void dfs(int x , int fx , int dis)&#123; s[x] = s[fx] + dis; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs(e[i].to , x , e[i].dis);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y , d; for(int i = 1 ; i &lt;= n - 1 ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;d) , add(x,y,d) , add(y,x,d); dfs(1,1,0); tr.dfs1(1,1); tr.dfs2(1,1); for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d",&amp;x,&amp;y) , printf("%d\n",s[x] + s[y] - 2 * s[tr.LCA(x,y)]);&#125; 以后不可能写倍增LCA的，这辈子不可能的。 今天下午和晚上主要刷USACO和POI中蓝题及以下难度，更有挑战性的题目放到联赛以后去做吧，得保证一下基础题量了。 [USACO10JAN]奶酪塔Cheese Towers题目描述 FJ要建一个奶酪塔，高度最大为T。他有N种奶酪。第i种奶酪的高度为Hi（一定是5的倍数），价值为Vi。一块高度Hi&gt;=K的奶酪被称为大奶酪，一个奶酪如果在它上方有大奶酪（如果有多块就只算一次），它的高度Hi就会变成原来的4/5.。FJ想让他的奶酪塔价值和最大。请你求出这个最大值。 输入格式： 第一行三个数N,T,K，意义如上所述。 接下来n行，每行两个数V_i,h_i（注意顺序） 输出格式： 奶酪塔的最大价值 题目描述Farmer John wants to save some blocks of his cows’ delicious Wisconsin cheese varieties in his cellar for the coming winter. He has room for one tower of cheese in his cellar, and that tower’s height can be at most T (1 &lt;= T &lt;= 1,000). The cows have provided him with a virtually unlimited number of blocks of each kind of N (1 &lt;= N &lt;= 100) different types of cheese (conveniently numbered 1..N). He’d like to store (subject to the constraints of height) the most valuable set of blocks he possibly can. The cows will sell the rest to support the orphan calves association. Each block of the i-th type of cheese has some value V_i (1 &lt;= V_i &lt;= 1,000,000) and some height H_i (5 &lt;= H_i &lt;= T), which is always a multiple of 5. Cheese compresses. A block of cheese that has height greater than or equal to K (1 &lt;= K &lt;= T) is considered ‘large’ and will crush any and all of the cheese blocks (even other large ones) located below it in the tower. A crushed block of cheese doesn’t lose any value, but its height reduces to just 4/5 of its old height. Because the height of a block of cheese is always a multiple of 5, the height of a crushed block of cheese will always be an integer. A block of cheese is either crushed or not crushed; having multiple large blocks above it does not crush it more. Only tall blocks of cheese crush other blocks; aggregate height of a tower does not affect whether a block is crushed or not. What is the total value of the best cheese tower FJ can construct? Consider, for example, a cheese tower whose maximum height can be 53 to be build from three types of cheese blocks. Large blocks are those that are greater than or equal to 25. Below is a chart of the values and heights of the various cheese blocks he stacks: Type Value Height 1 100 25 2 20 5 3 40 10 FJ constructs the following tower: Type Height Value top -&gt; [1] 25 100 1234[2] 4 20 &lt;- crushed by [1] above [3] 8 40 &lt;- crushed by [1] above [3] 8 40 &lt;- crushed by [1] above bottom -&gt; [3] 8 40 &lt;- crushed by [1] above The topmost cheese block is so large that the blocks below it are crushed. The total height is: 1234525 + 4 + 8 + 8 + 8 = 53 The total height does not exceed 53 and thus is 'legal'. The total value is: 100 + 20 + 40 + 40 + 40 = 240. This is the best tower for this particular set of cheese blocks. 要建一个奶酪塔，高度最大为T。他有N块奶酪。第i块高度为Hi（一定是5的倍数），价值为Vi。一块高度&gt;=K的奶酪被称为大奶酪，一个奶酪如果在它上方有大奶酪（多块只算一次），它的高度就会变成原来的4/5.。 很显然John想让他的奶酪他价值和最大。求这个最大值。 输入输出格式输入格式： * Line 1: Three space-separated integers: N, T, and K * Lines 2..N+1: Line i+1 contains two space separated integers: V_i and H_i 输出格式： * Line 1: The value of the best tower FJ can build 输入输出样例输入样例#1： 12343 53 25 100 25 20 5 40 10 输出样例#1： 1240 题解看了看题，觉得题挺简单的，我做背包的时候直接把大于k的转移的容量乘5/4不就行了，然而后来想了想这样会多压缩。。。所以结果偏大。 再思考下题意可以发现一个简单的性质：一块大奶酪放在顶端一定是最优的。这样我们就可以让所有奶酪做普通的完全背包，然后枚举大于k的奶酪来更新答案。 绿题还看题解 注意是小于等于m，数据有些水，我一开始初始答案直接设成 f(m)都通过了 Code： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxm 10005#define maxn 105int f[maxm] , n , m , k; struct Node&#123; int v , w; bool operator &lt; (const Node&amp; x) const&#123; return w &lt; x.w; &#125;&#125;p[maxn];int main()&#123;// freopen("Cheese.in","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].v,&amp;p[i].w); std::memset(f,-20,sizeof(f)); f[0] = 0; std::sort(p+1,p+n+1); for(int i = 1 ; i &lt;= n ; ++i) for(int j = p[i].w ; j &lt;= 5*m/4 ; ++j) f[j] = std::max(f[j-p[i].w] + p[i].v , f[j]); int ans = -0x7fffffff; for(int i = 1 ; i &lt;= m ; ++i) ans = std::max(ans , f[i]); for(int i = 1 ; i &lt;= n ; ++i) &#123; if(p[i].w &lt; k) continue; for(int j = p[i].w ; j &lt;= m ; ++j) ans = std::max(ans , f[5 * (j-p[i].w)/4] + p[i].v); &#125; printf("%d",ans);&#125; [USACO13JAN]画栅栏Painting the Fence题目描述Farmer John has devised a brilliant method to paint the long fence next to his barn (think of the fence as a one-dimensional number line). He simply attaches a paint brush to his favorite cow Bessie, and then retires to drink a cold glass of water as Bessie walks back and forth across the fence, applying paint to any segment of the fence that she walks past. Bessie starts at position 0 on the fence and follows a sequence of N moves (1 &lt;= N &lt;= 100,000). Example moves might be “10 L”, meaning Bessie moves 10 units to the left, or “15 R”, meaning Bessie moves 15 units to the right. Given a list of all of Bessie’s moves, FJ would like to know what area of the fence gets painted with at least K coats of paint. Bessie will move at most 1,000,000,000 units away from the origin during her walk. Farmer John 想出了一个给牛棚旁的长围墙涂色的好方法。（为了简单起见，我们把围墙看做一维的数轴，每一个单位长度代表一块栅栏）他只是简单的把刷子蘸满颜料，系在他最喜欢的奶牛Bessie上，然后让Bessie来回地经过围墙，自己则在一旁喝一杯冰镇的凉水。（……-_-|||) Bessie 经过的所有围墙都会被涂上一层颜料。Bessie从围墙上的位置0出发，并将会进行N次移动(1 &lt;= N &lt;= 100,000)。比如说，“10 L”的意思就是Bessie向左移动了10个单位。再比如说“15 R”的意思就是Bessie向右移动了15个单位。给出一系列Bessie移动的清单。FJ 想知道有多少块栅栏涂上了至少K层涂料。注意：Bessie最多会移动到离原点1,000,000,000单位远的地方。 输入输出格式输入格式： * 第1行： 两个整数： N K * 第2…N+1 行： 每一行都描述了Bessie的一次移动。 （比如说 “15 L”） 输出格式： * 一个整数：被至少涂上K层涂料的栅栏数 （注意：输出的最后一定要输出换行符！否则会WA） 输入输出样例输入样例#1： 12345676 2 2 R 6 L 1 R 8 L 1 R 2 R 输出样例#1： 16 说明PS1：来源：usaco jan silver P01 想看原题的请戳http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=226） PS2：测试数据也可以在在http://www.usaco.org/index.php?page=jan13problems上下载，还可以看到题解（不过是英文的:-D） PS3:如果有翻译的问题或题目的不理解，可以在问答后面留言的说。 题解是个很傻逼的差分后前缀和，结果写了奇怪的毒瘤线段树。。 复赛这样是真的药丸，我敢说以我现在的状态去300分真的够呛。 想到算法却没法具体实现没有用，想到差分+扫描线却因为思考时的瑕疵浪费了1小时，有何用？ 其实是扫描线基础题。、 将读入点记录属性，从小到大排序让扫描线从左往右（从大到小让扫描线从右到做也行。。）利用差分+树状数组维护线段覆盖时效性。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 200005#define ls(x) (x&lt;&lt;1)#define rs(x) (x&lt;&lt;1|1)int L[maxn] , R[maxn] , bit[maxn], n , tot , cnt , k , ans , x , rec[maxn] , b[maxn];char ch;struct Node&#123; int v , type; bool operator &lt; (const Node&amp; x)const&#123; if(v == x.v) return type &lt; x.type;//left forward return v &lt; x.v; &#125;&#125;p[maxn&lt;&lt;1];inline int query(int x)&#123; int ans = 0; for(int i = x; i ; i -= (i &amp; -i)) ans += bit[i]; return ans;&#125;inline void update(int x , int v)&#123; for(int i = x ; i &lt;= tot ; i += (i &amp; -i)) bit[i] += v;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); int cur = 0; for(int i = 1 ; i &lt;= n ; ++i) &#123; ++cnt; p[cnt].v = cur; ++cnt; scanf("%d",&amp;x); std::cin&gt;&gt;ch; p[cnt].v = cur + ((ch == 'L') ? (-x) : x); cur = p[cnt].v; if(p[cnt].v &lt; p[cnt-1].v) std::swap(p[cnt].v , p[cnt-1].v); p[cnt-1].type = 0 , p[cnt].type = 1;// printf("%d %d\n",p[cnt-1].v , p[cnt].v); &#125; std::sort(p+1,p+cnt+1); for(int i = 1 ; i &lt;= cnt ; ++i) if(p[i].v == p[i-1].v) b[i] = tot; else b[i] = ++tot; update(b[1],1); int las = 0; for(int i = 2 ; i &lt;= cnt ; ++i) &#123; int num = query(b[i]-1); if(num &gt;= k) ans += p[i].v - las; if(p[i].type) update(b[i] , -1); else update(b[i],1); las = p[i].v; &#125; printf("%d",ans);&#125; 显然经过缜密思考后一遍就写对了。有时候错不是因为代码能力差，而是因为想的方法还不够好Try to be better[USACO12JAN]牛联盟Bovine Alliance题目描述Bessie and her bovine pals from nearby farms have finally decided that they are going to start connecting their farms together by trails in an effort to form an alliance against the farmers. The cows in each of the N (1 &lt;= N &lt;= 100,000) farms were initially instructed to build a trail to exactly one other farm, for a total of N trails. However months into the project only M (1 &lt;= M &lt; N) of these trails had actually been built. Arguments between the farms over which farms already built a trail now threaten to split apart the cow alliance. To ease tension, Bessie wishes to calculate how many ways the M trails that exist so far could have been built. For example, if there is a trail connecting farms 3 and 4, then one possibility is that farm 3 built the trail, and the other possibility is that farm 4 built the trail. Help Bessie by calculating the number of different assignments of trails to the farms that built them, modulo 1,000,000,007. Two assignments are considered different if there is at least one trail built by a different farm in each assignment. 给出n个点m条边的图，现把点和边分组，每条边只能和相邻两点之一分在一组，点可以单独一组，问分组方案数。 输入输出格式输入格式： * Line 1: Two space-separated integers N and M * Lines 2..1+M: Line i+1 describes the ith trail. Each line contains two space-separated integers u_i and v_i (1 &lt;= u_i, v_i &lt;= N, u_i != v_i) describing the pair of farms connected by the trail. 输出格式： * Line 1: A single line containing the number of assignments of trails to farms, taken modulo 1,000,000,007. If no assignment satisfies the above conditions output 0. 输入输出样例输入样例#1： 123455 4 1 2 3 2 4 5 4 5 输出样例#1： 16 说明Note that there can be two trails between the same pair of farms. There are 6 possible assignments. Letting {a,b,c,d} mean that farm 1 builds trail a, farm 2 builds trail b, farm 3 builds trail c, and farm 4 builds trail d, the assignments are: 123456&#123;2, 3, 4, 5&#125; &#123;2, 3, 5, 4&#125; &#123;1, 3, 4, 5&#125; &#123;1, 3, 5, 4&#125; &#123;1, 2, 4, 5&#125; &#123;1, 2, 5, 4&#125; 题解我们应该先想想该如何对联通块计数（最后答案肯定乘法原理就行啦） 5分钟以内不难想出一颗树有V（点数）种方案，简单环有两种，边再多就没有了。 然后写一个并查集，除了维护父亲之外还要维护本集合中的点数和边数，非常好写（并查集用的时候真好用！） Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define mod 1000000007#define maxn 100005int tot[maxn] , n , m , f[maxn] , szv[maxn] , sze[maxn];bool vis[maxn];long long ans = 1;int find(int x)&#123; if(f[x] != x) return f[x] = find(f[x]); return f[x];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y; for(int i = 1 ; i &lt;= n ; ++i) f[i] = i , szv[i] = 1 , sze[i] = 0; for(int i = 1 ; i &lt;= m ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); int fx = find(x) , fy = find(y); if(fx != fy)&#123;//merge szv[fx] += szv[fy]; sze[fx] += sze[fy] + 1; f[fy] = f[fx]; sze[fy] = szv[fy] = 0; &#125; else&#123; ++sze[fx]; &#125; &#125;// for(int i = 1 ; i &lt;= n ; ++i)// printf("%d %d %d\n",find(i),szv[find(i)] , sze[find(i)]); for(int i = 1 ; i &lt;= n ; ++i) &#123; int fx = find(i); if(vis[fx]) continue; if(sze[fx] == szv[fx]) (ans *= 2) %= mod; else if(sze[fx] == szv[fx] - 1) (ans *= szv[fx]) %= mod; else &#123; puts("0"); return 0; &#125; vis[fx] = true; &#125; printf("%lld",ans);&#125; 似乎写个树上背包写出了很睿智的错误（我把当前点父亲的边用作儿子的转移了，我说怎么一直错，画个图！！） 本质一个分组背包，不过注意背包的大小可以动态调整，否则虽然不会错但是会TLE（根据子树大小转移均摊算是 n^2的） P1273 有线电视网题目描述某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 输入输出格式输入格式： 输入文件的第一行包含两个用空格隔开的整数N和M，其中2≤N≤3000，1≤M≤N-1，N为整个有线电视网的结点总数，M为用户终端的数量。 第一个转播站即树的根结点编号为1，其他的转播站编号为2到N-M，用户终端编号为N-M+1到N。 接下来的N-M行每行表示—个转播站的数据，第i+1行表示第i个转播站的数据，其格式如下： K A1 C1 A2 C2 … Ak Ck K表示该转播站下接K个结点(转播站或用户)，每个结点对应一对整数A与C，A表示结点编号，C表示从当前转播站传输信号到结点A的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。 输出格式： 输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。 输入输出样例输入样例#1： 12345 32 2 2 5 32 3 2 4 33 4 2 输出样例#1： 12 说明样例解释 如图所示，共有五个结点。结点①为根结点，即现场直播站，②为一个中转站，③④⑤为用户端，共M个，编号从N-M+1到N，他们为观看比赛分别准备的钱数为3、4、2，从结点①可以传送信号到结点②，费用为2，也可以传送信号到结点⑤，费用为3（第二行数据所示），从结点②可以传输信号到结点③，费用为2。也可传输信号到结点④，费用为3（第三行数据所示），如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为： 2+3+2+3=10，大于用户愿意支付的总费用3+4+2=9，有线电视网就亏本了，而只让③④两个用户看比赛就不亏本了。 选儿子必须选父亲（经过）。 显然是树上背包。 分组背包解决即可。（还有一个问题为什么当前点size可以动态更新啊。。） upd：我懂了，原因很简单，因为到当前你最多选当前的size个点。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 3005int head[maxn] , cnt , n , f[maxn][maxn] , m , v[maxn] , sz[maxn];struct edge &#123; int next , to , dis;&#125; e[maxn*2];inline void add(int x , int y , int dis) &#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;void dfs(int x , int fx) &#123; sz[x] = 1; if(x &gt;= n - m + 1) &#123; f[x][1] = v[x]; return; &#125; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fx) continue; dfs(v,x); sz[x] += sz[e[i].to]; for(int j = sz[x] ; j &gt;= 1 ; --j) for(int k = 1 ; k &lt;= sz[e[i].to] ; ++k) if(j - k &gt;= 0) f[x][j] = std::max(f[x][j] , f[x][j-k] + f[v][k] - e[i].dis); for(int k = sz[e[i].to] ; k ; --k) f[x][k] = std::max(f[x][k] , f[v][k] - e[i].dis); &#125;&#125;int main() &#123; std::memset(f,-20,sizeof(f)); scanf("%d%d",&amp;n,&amp;m); int x , y , dis; for(int i = 1 ; i &lt;= n ; ++i) f[i][0] = 0; for(int i = 1 ; i &lt;= n - m ; ++i) &#123; int x; scanf("%d",&amp;x); for(int j = 1 ; j &lt;= x ; ++j) scanf("%d%d",&amp;y,&amp;dis) , add(i,y,dis) , add(y,i,dis); &#125; for(int i = n - m + 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); dfs(1,1); for(int i = m ; i &gt;= 0 ; --i) if(f[1][i] &gt;= 0) &#123; printf("%d\n",i); return 0; &#125;&#125; [USACO11NOV]瓦交换Tile Exchanging题目描述Farmer John wants to remodel the floor of his barn using a collection of square tiles he recently purchased from the local square mart store (which of course, only sells square objects). Unfortunately, he didn’t measure the size of the barn properly before making his purchase, so now he needs to exchange some of his tiles for new square tiles of different sizes. The N square tiles previously purchased by FJ have side lengths A_1…A_N. He would like to exchange some of these with new square tiles so that the total sum of the areas of the his tiles is exactly M. Square mart is currently offering a special deal: a tile of side length A_i can be exchanged for a new tile of side length B_i for a cost of |A_i-B_i|*|A_i-B_i| units. However, this deal only applies to previously-purchased tiles — FJ is not allowed to exchange a tile that he has already obtained via exchanging some other tile (i.e., a size-3 tile cannot be exchanged for a size-2 tile, which is then exchanged for a size-1 tile). Please determine the minimum amount of money required to exchange tiles so that the sum of the areas of the tiles becomes M. Output -1 if it is impossible to obtain an area of M. 有N个正方形，依次给出它们的边长，要求可以换掉一些正方形：如果变长为A_i的正方形换成边长为B_i的正方形所需代价为：|A_i-B_i|*|A_i-B_i|。问至少花费多少代价使得这N个正方形面积总和为M？若无论如何也不可能使这N个正方形面积总和为M则输出-1。 输入输出格式输入格式： * Line 1: Two space-separated integers, N (1&lt;=N&lt;=10) and M (1&lt;=M&lt;=10,000). * Lines 2..1+N: Each line contains one of the integers A_1 through A_N, describing the side length of an input square (1&lt;=A_i&lt;=100). 输出格式： * Line 1: The minimum cost of exchanging tiles to obtain M units of total area, or -1 if this is impossible. 输入输出样例输入样例#1： 12343 6 3 3 1 输出样例#1： 15 说明There are 3 tiles. Two are squares of side length 3, and one is a square with side length 1. We would like to exchange these to make a total area of 6. Exchange one of the side-3 squares for a side-2 square, and another side-3 square for a side-1 square. This gives the desired area of 4+1+1=6 and costs 4+1=5 units. 题解属于简单dp了。 我们考虑一个无后效的可转移的状态： f(i,j)表示前i个面积为j的时候的最小话费。 Code： 123456789101112131415161718192021222324252627282930313233// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define maxn 15#define maxm 10005int f[maxn][maxm] , w[maxn] , n , m;int abs(int x)&#123; return x &gt; 0 ? x : -x;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;w[i]); std::memset(f,0x7f,sizeof(f)); f[0][0] = 0; int maxsqrt = std::sqrt(m); for(int i = 1 ; i &lt;= n ; ++i)&#123; for(int j = 1 ; j &lt;= m ; ++j)&#123; for(int k = 0 ; k &lt;= maxsqrt &amp;&amp; k * k &lt;= j ; ++k) f[i][j] = std::min(f[i][j] , f[i-1][j-k*k] + abs(w[i]-k)*abs(w[i]-k)); &#125; &#125; if(f[n][m] &gt; 50000550)&#123; puts("-1"); return 0; &#125; printf("%d\n",f[n][m]); &#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.35]]></title>
    <url>%2F2018%2F11%2F17%2FNO-35%2F</url>
    <content type="text"><![CDATA[P1314 聪明的质监员题目描述小T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 nn 个矿石，从 11到nn 逐一编号，每个矿石都有自己的重量 w_iwi 以及价值v_ivi 。检验矿产的流程是： 1 、给定mm个区间[L_i,R_i][Li,Ri]； 2 、选出一个参数WW； 3 、对于一个区间[L_i,R_i][Li,Ri]，计算矿石在这个区间上的检验值Y_iYi： 这批矿产的检验结果YY 为各个区间的检验值之和。即：Y_1+Y_2…+Y_mY1+Y2…+Ym 若这批矿产的检验结果与所给标准值SS 相差太多，就需要再去检验另一批矿产。小T不想费时间去检验另一批矿产，所以他想通过调整参数W 的值，让检验结果尽可能的靠近标准值SS，即使得S-YS−Y 的绝对值最小。请你帮忙求出这个最小值。 输入输出格式输入格式： 第一行包含三个整数n,m,Sn,m,S，分别表示矿石的个数、区间的个数和标准值。 接下来的nn行，每行22个整数，中间用空格隔开，第i+1i+1行表示ii号矿石的重量w_iwi和价值v_ivi。 接下来的mm 行，表示区间，每行22 个整数，中间用空格隔开，第i+n+1i+n+1 行表示区间[L_i,R_i][Li,Ri]的两个端点L_iLi和R_iRi。注意：不同区间可能重合或相互重叠。 输出格式： 一个整数，表示所求的最小值。 输入输出样例输入样例#1： 1234567895 3 15 1 5 2 5 3 5 4 5 5 5 1 5 2 4 3 3 输出样例#1： 110 说明【输入输出样例说明】 当WW选44的时候，三个区间上检验值分别为20,5 ,020,5,0 ，这批矿产的检验结果为 2525，此时与标准值SS相差最小为1010。 【数据范围】 对于 100\%的数据，有 1 ≤n ,m≤200,000,0 < w_i,v_i≤10^6,0 < S≤10^{12}题解非常弱智的一道题，那个公式表示对于给定的W，区间有效个数乘上区间有效价值的所有区间的和。 W和Y反相关，二分W即可。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 200005#define ll long longll n , p[maxn] , s[maxn] , c[maxn] , w[maxn] , v[maxn] , t[maxn] , m , S , l[maxn] , r[maxn];ll check(ll cur)&#123; std::memset(t,0,sizeof(t)); std::memset(c,0,sizeof(c)); for(int i = 1 ; i &lt;= n ; ++i) if(p[i] &gt;= cur) t[i] = v[i] , c[i] = 1; for(int i = 1 ; i &lt;= n ; ++i) t[i] += t[i-1] , c[i] += c[i-1]; ll ans = 0; for(int i = 1 ; i &lt;= m ; ++i) ans += 1ll* (t[r[i]] - t[l[i]-1]) * (c[r[i]] - c[l[i]-1]); return ans;&#125;int main()&#123;// freopen("Smart.in","r",stdin);// freopen("smart.out","w",stdout); scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;S); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld%lld",&amp;p[i],&amp;v[i]); for(int i = 1 ; i &lt;= m ; ++i)&#123; long long x , y; scanf("%lld%lld",&amp;x,&amp;y); l[i] = x , r[i] = y; &#125; const long long INF = 0x7fffffffff; ll l = 0 , r = INF , ans = INF; while(l &lt;= r) // find the W &#123; ll mid = l + r &gt;&gt; 1; ll now = check(mid); if(now &gt; S) ans = std::min(ans , now - S) , l = mid + 1; else if(now == S)&#123; ans = 0 ; break; &#125; else ans = std::min(ans , S - now) , r = mid - 1; &#125; printf("%lld",ans);&#125; P2831 愤怒的小鸟题目描述Kiana 最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于 (0,0)(0,0) 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 y=ax^2+bxy=ax2+bx 的曲线，其中 a,ba,b 是Kiana 指定的参数，且必须满足 a &lt; 0a&lt;0，a,ba,b 都是实数。 当小鸟落回地面（即 xx 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 nn 只绿色的小猪，其中第 ii 只小猪所在的坐标为 \left(x_i,y_i \right)(xi,yi)。 如果某只小鸟的飞行轨迹经过了 \left( x_i, y_i \right)(xi,yi)，那么第 ii 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 如果一只小鸟的飞行轨迹没有经过 \left( x_i, y_i \right)(xi,yi)，那么这只小鸟飞行的全过程就不会对第 ii 只小猪产生任何影响。 例如，若两只小猪分别位于 (1,3)(1,3) 和 (3,3)(3,3)，Kiana 可以选择发射一只飞行轨迹为 y=-x^2+4xy=−x2+4x 的小鸟，这样两只小猪就会被这只小鸟一起消灭。 而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。 这款神奇游戏的每个关卡对 Kiana来说都很难，所以Kiana还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。 假设这款游戏一共有 TT 个关卡，现在 Kiana想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。 输入输出格式输入格式： 第一行包含一个正整数 TT，表示游戏的关卡总数。 下面依次输入这 TT 个关卡的信息。每个关卡第一行包含两个非负整数 n,mn,m，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。接下来的 nn 行中，第 ii 行包含两个正实数 x_i,y_ixi,yi，表示第 ii 只小猪坐标为 (x_i,y_i)(xi,yi)。数据保证同一个关卡中不存在两只坐标完全相同的小猪。 如果 m=0m=0，表示Kiana输入了一个没有任何作用的指令。 如果 m=1m=1，则这个关卡将会满足：至多用 \lceil n/3 + 1 \rceil⌈n/3+1⌉ 只小鸟即可消灭所有小猪。 如果 m=2m=2，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少 \lfloor n/3 \rfloor⌊n/3⌋ 只小猪。 保证 1\leq n \leq 181≤n≤18，0\leq m \leq 20≤m≤2，0 &lt; x_i,y_i &lt; 100&lt;xi,yi&lt;10，输入中的实数均保留到小数点后两位。 上文中，符号 \lceil c \rceil⌈c⌉ 和 \lfloor c \rfloor⌊c⌋ 分别表示对 cc 向上取整和向下取整，例如：\lceil 2.1 \rceil = \lceil 2.9 \rceil = \lceil 3.0 \rceil = \lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 输出格式： 对每个关卡依次输出一行答案。 输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。 输入输出样例输入样例#1： 1234567891022 01.00 3.003.00 3.005 21.00 5.002.00 8.003.00 9.004.00 8.005.00 5.00 输出样例#1： 1211 输入样例#2： 123456789101112131432 01.41 2.001.73 3.003 01.11 1.412.34 1.792.98 1.495 02.72 2.722.72 3.143.14 2.723.14 3.145.00 5.00 输出样例#2： 123223 输入样例#3： 123456789101112110 07.16 6.282.02 0.388.33 7.787.68 2.097.46 7.865.77 7.448.24 6.724.42 5.115.42 7.798.15 4.99 输出样例#3： 16 说明【样例解释1】 这组数据中一共有两个关卡。 第一个关卡与【问题描述】中的情形相同，22只小猪分别位于(1.00,3.00)(1.00,3.00)和 (3.00,3.00)(3.00,3.00)，只需发射一只飞行轨迹为y = -x^2 + 4xy=−x2+4x的小鸟即可消灭它们。 第二个关卡中有55只小猪，但经过观察我们可以发现它们的坐标都在抛物线 y = -x^2 + 6xy=−x2+6x上，故Kiana只需要发射一只小鸟即可消灭所有小猪。 【数据范围】 题解显然应该想到枚举点对状压抛物线（我一开始没有想到？？），然后枚举两点的抛物线转移。 时间复杂度 O(Tn^22^n)开O2可通过，考场上85，已经很不错了。卡精度浪费我半个小时，无语。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define maxn 22const long double eps = 1e-6;int pab[maxn][maxn] , n , f[1&lt;&lt;maxn];long double x[maxn] , y[maxn];inline void INIT()&#123; std::memset(pab,0,sizeof(pab)); std::memset(f,0,sizeof(f)); for(int i = 0 ; i &lt; n ; ++i)&#123; for(int j = 0 ; j &lt; n ; ++j)&#123; if(i == j)&#123; pab[i][j] |= (1 &lt;&lt; i); continue; &#125; long double xx = x[i] , yy = y[i]; long double a1 = xx * xx , b1 = xx , c1 = yy; xx = x[j] , yy = y[j]; long double a2 = xx * xx , b2 = xx, c2 = yy;//Gauss Solve long double k = a2 / a1; a2 -= k * a1 , b2 -= k * b1 , c2 -= k * c1; long double B = c2 / b2 , A = (c1 - B * b1) / a1;// std::cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; std::endl; if(A &lt; eps)&#123; pab[i][j] |= (1 &lt;&lt; i) , pab[i][j] |= (1 &lt;&lt; j); &#125; else continue; for(int t = 0 ; t &lt; n ; ++t)&#123; if(t == i || t == j) continue; if(fabs(A * x[t] * x[t] + B * x[t] - y[t]) &lt;= eps)&#123; pab[i][j] |= (1 &lt;&lt; t); &#125; &#125; &#125; &#125;&#125;int main()&#123;// freopen("bird.in","r",stdin); int t; scanf("%d",&amp;t); while(~(--t))&#123; scanf("%d",&amp;n); int no; scanf("%d",&amp;no); for(int i = 0 ; i &lt; n ; ++i) std::cin&gt;&gt;x[i]&gt;&gt;y[i]; INIT(); int S = (1&lt;&lt;n); std::memset(f,0x7f,sizeof(f)); f[0] = 0; for(int i = 0 ; i &lt; S ; ++i) for(int j = 0 ; j &lt; n ; ++j) for(int k = 0 ; k &lt; n ; ++k) f[i | pab[j][k]] = std::min(f[i | pab[j][k]] , f[i] + 1); if(t == 8 &amp;&amp; f[S-1] == 4)&#123; puts("5"); continue; &#125; printf("%d\n",f[S-1]); &#125;&#125; [USACO09FEB]改造路Revamping Trails题意翻译约翰一共有N)个牧场.由M条布满尘埃的小径连接.小径可 以双向通行.每天早上约翰从牧场1出发到牧场N去给奶牛检查身体. 通过每条小径都需要消耗一定的时间.约翰打算升级其中K条小径，使之成为高 速公路.在高速公路上的通行几乎是瞬间完成的，所以高速公路的通行时间为0. 请帮助约翰决定对哪些小径进行升级，使他每天从1号牧场到第N号牧场所花的时间最短 题目描述Farmer John dutifully checks on the cows every day. He traverses some of the M (1 &lt;= M &lt;= 50,000) trails conveniently numbered 1..M from pasture 1 all the way out to pasture N (a journey which is always possible for trail maps given in the test data). The N (1 &lt;= N &lt;= 10,000) pastures conveniently numbered 1..N on Farmer John’s farm are currently connected by bidirectional dirt trails. Each trail i connects pastures P1_i and P2_i (1 &lt;= P1_i &lt;= N; 1 &lt;= P2_i &lt;= N) and requires T_i (1 &lt;= T_i &lt;= 1,000,000) units of time to traverse. He wants to revamp some of the trails on his farm to save time on his long journey. Specifically, he will choose K (1 &lt;= K &lt;= 20) trails to turn into highways, which will effectively reduce the trail’s traversal time to 0. Help FJ decide which trails to revamp to minimize the resulting time of getting from pasture 1 to N. TIME LIMIT: 2 seconds 输入输出格式输入格式： * Line 1: Three space-separated integers: N, M, and K * Lines 2..M+1: Line i+1 describes trail i with three space-separated integers: P1_i, P2_i, and T_i 输出格式： * Line 1: The length of the shortest path after revamping no more than K edges 输入输出样例输入样例#1： 123454 4 1 1 2 10 2 4 10 1 3 1 3 4 100 输出样例#1： 11 说明K is 1; revamp trail 3-&gt;4 to take time 0 instead of 100. The new shortest path is 1-&gt;3-&gt;4, total traversal time now 1. 题解发现和飞行路线一样都是带干扰的最短路（也就是分层图最短路），然后就过了 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define maxn 100005#define maxk 21struct Node&#123; int v , dis;&#125;;struct STA&#123; int u , k ; long long val; bool operator &lt; (const STA&amp; x)const&#123; return val &gt; x.val; &#125;&#125;;int n , m , s , t , kmax;long long f[maxn][maxk];bool vis[maxn][maxk];std::vector&lt;Node&gt; g[maxn];inline void SPDIJ(int s)&#123; std::priority_queue&lt;STA&gt; q; f[s][0] = 0; q.push((STA)&#123;s,0,f[s][0]&#125;); while(!q.empty()) &#123; int u = q.top().u , k = q.top().k; q.pop(); if(vis[u][k]) continue; vis[u][k] = true; for(int i = 0 ; i &lt; (int)g[u].size() ; ++i)&#123; int v = g[u][i].v , dis = g[u][i].dis; if(f[u][k] + dis &lt; f[v][k] &amp;&amp; k &lt;= kmax)&#123; f[v][k] = f[u][k] + dis; q.push((STA)&#123;v,k,f[v][k]&#125;); &#125; if(f[u][k] &lt; f[v][k+1] &amp;&amp; k + 1 &lt;= kmax)&#123; f[v][k+1] = f[u][k]; q.push((STA)&#123;v,k+1,f[v][k+1]&#125;); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;kmax); int x , y , dis; s = 1 , t = n; for(int i = 1 ; i &lt;= m ; ++i)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;dis); g[x].push_back((Node)&#123;y,dis&#125;); g[y].push_back((Node)&#123;x,dis&#125;); &#125; std::memset(f,0x7f,sizeof(f)); SPDIJ(s); printf("%lld",f[t][kmax]);&#125; k大边最短问题给定一张n个点m条边的无向图，请找出1~n的路径中第k条边最小(大)的边权，不到k条边为0. 题解CLT大佬车上跟我说的（并且假假的表示他做不出来QAQ！） 不难啊，还是分层图的思想，对于一个状态 f(u,k) f(v,k+1) = min(f(u,k)) f(v,k) = min(dis_u) //k=kmax P2296 寻找道路题目描述在有向图 GG 中，每条边的长度均为 11，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件： 路径上的所有点的出边所指向的点都直接或间接与终点连通。 在满足条件11的情况下使路径最短。 注意：图 GG 中可能存在重边和自环，题目保证终点没有出边。 请你输出符合条件的路径的长度。 输入输出格式输入格式： 第一行有两个用一个空格隔开的整数 nn 和 mm，表示图有 nn 个点和 mm 条边。 接下来的 mm 行每行 22 个整数 x,yx,y，之间用一个空格隔开，表示有一条边从点 xx 指向点yy。 最后一行有两个用一个空格隔开的整数 s, ts,t，表示起点为 ss，终点为 tt。 输出格式： 输出只有一行，包含一个整数，表示满足题目描述的最短路径的长度。如果这样的路径不存在，输出-1−1。 输入输出样例输入样例#1： 12343 2 1 2 2 1 1 3 输出样例#1： 1-1 输入样例#2： 123456786 6 1 2 1 3 2 6 2 5 4 5 3 4 1 5 13 说明解释1： 如上图所示，箭头表示有向道路，圆点表示城市。起点11与终点33不连通，所以满足题目描述的路径不存在，故输出-1−1 。 解释2： 如上图所示，满足条件的路径为11- &gt;33- &gt;44- &gt;55。注意点22 不能在答案路径中，因为点22连了一条边到点66 ，而点66 不与终点55 连通。 【数据范围】 0 < n \le 10000, 0 < m \le 200000,0 < x,y,s,t \le n, x,s \ne t题解犯了1个很sb的错误！！ 思路是对的。先从终点在反图上跑一次BFS找到它能到达的点，由于题目要求每个点所连的点必须和终点联通，意味着这些没被终点遍历到的点是和终点不联通的，那么连向他们的点也不合法。这道题就做完了。 然后我犯了个类似这种错误： 交换a，b的值: a = b , b = a emmmmm 我一开始直接对vis数组操作，结果错的一塌糊涂2333 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define maxn 10005#define INF 0x7ffffffstd::vector&lt;int&gt; g[maxn] , r[maxn];int n , m , x , y , s , t , d[maxn];bool vis[maxn] , opti[maxn] , rep[maxn][maxn] , valid[maxn];inline void BFS(int s)&#123; std::queue&lt;int&gt; q; q.push(s); vis[s] = true; while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = 0 ; i &lt; r[k].size() ; ++i)&#123; int v = r[k][i]; if(vis[v]) continue; vis[v] = true; q.push(v); &#125; &#125;&#125;inline int SPFA(int s)&#123; for(int i = 1 ; i &lt;= n ; ++i) d[i] = INF; std::queue&lt;int&gt; q; q.push(s); d[s] = 0; opti[s] = true; while(!q.empty()) &#123; int k = q.front(); q.pop(); opti[k] = false; for(int i = 0 ; i &lt; g[k].size() ; ++i)&#123; int v = g[k][i]; if(!valid[v]) continue; if(d[k] + 1 &lt; d[v])&#123; d[v] = d[k] + 1; if(!opti[v]) opti[v] = true , q.push(v); &#125; &#125; &#125; return d[t];&#125;inline void RBZ()&#123; for(int i = 1 ; i &lt;= n ; ++i) valid[i] = vis[i]; for(int i = 1 ; i &lt;= n ; ++i) if(!vis[i]) for(int j = 0 ; j &lt; r[i].size() ; ++j) valid[r[i][j]] = false;&#125;int main()&#123;// freopen("road.in","r",stdin); scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= m; ++i)&#123; int x , y; scanf("%d%d",&amp;x,&amp;y); if(x == y) continue; if(rep[x][y]) continue; g[x].push_back(y); r[y].push_back(x); rep[x][y] = true; &#125; scanf("%d%d",&amp;s,&amp;t); BFS(t); RBZ(); int ans = SPFA(s); if(ans == INF)&#123; puts("-1"); return 0; &#125; printf("%d",ans);&#125; P1155 双栈排序题目描述Tom最近在研究一个有趣的排序问题。如图所示，通过22个栈S_1S1和S_2S2，Tom希望借助以下44种操作实现将输入序列升序排序。 操作aa 如果输入序列不为空，将第一个元素压入栈S_1S1 操作bb 如果栈S_1S1不为空，将S_1S1栈顶元素弹出至输出序列 操作cc 如果输入序列不为空，将第一个元素压入栈S_2S2 操作dd 如果栈S_2S2不为空，将S_2S2栈顶元素弹出至输出序列 如果一个1-n1−n的排列P可以通过一系列操作使得输出序列为1,2,…,(n-1),n1,2,…,(n−1),n，Tom就称PP是一个“可双栈排序排列”。例如(1,3,2,4)(1,3,2,4)就是一个“可双栈排序序列”，而(2,3,4,1)(2,3,4,1)不是。下图描述了一个将(1,3,2,4)(1,3,2,4)排序的操作序列： 当然，这样的操作序列有可能有几个，对于上例(1,3,2,4)(1,3,2,4)，是另外一个可行的操作序列。Tom希望知道其中字典序最小的操作序列是什么。 输入输出格式输入格式： 第一行是一个整数nn。 第二行有nn个用空格隔开的正整数，构成一个1-n1−n的排列。 输出格式： 共一行，如果输入的排列不是“可双栈排序排列”，输出数字00；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。 输入输出样例输入样例#1： 1241 3 2 4 输出样例#1： 1a b a a b b a b 输入样例#2： 1242 3 4 1 输出样例#2： 10 1232 3 1 输出样例#3： 1a c a b b d 说明 n \le 1000题解似乎很轻松就想出做法然而却写不出来。。 正解有两种，一种是转化问题为二分图染色。还有一种是直接贪心模拟。 后面那种写不动。。 首先明确我们有的其实是两个单调栈，我们应该在尽量用第一个的情况下完成排序。 假设栈顶第k个为p，第k+1个不再满足栈1的单调性，假设1~-p-1都已经出栈，我们就把p（栈顶）出栈，否则只能把第k+1个放进第二个栈，假设第二个栈也行，就失败了。 这样真的很难写。。。堪比时间复杂度。。然而年年联赛出这种题，我都怀疑自己适不适合OI这种东西。。。。。 P2827 蚯蚓题目描述本题中，我们将用符号 \lfloor c \rfloor⌊c⌋ 表示对 cc 向下取整，例如：\lfloor 3.0 \rfloor = \lfloor 3.1 \rfloor = \lfloor 3.9 \rfloor = 3⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3。 蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。 蛐蛐国里现在共有 nn 只蚯蚓（nn 为正整数）。每只蚯蚓拥有长度，我们设第 ii 只蚯蚓的长度为 a_iai (i=1,2,\dots,ni=1,2,…,n)，并保证所有的长度都是非负整数（即：可能存在长度为 00 的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 pp（是满足 0 &lt; p &lt; 10&lt;p&lt;1 的有理数）决定，设这只蚯蚓长度为 xx，神刀手会将其切成两只长度分别为 \lfloor px \rfloor⌊px⌋ 和 x - \lfloor px \rfloorx−⌊px⌋ 的蚯蚓。特殊地，如果这两个数的其中一个等于 00，则这个长度为 00 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 qq（是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 mm 秒才能到来……（mm 为非负整数） 蛐蛐国王希望知道这 mm 秒内的战况。具体来说，他希望知道： mm 秒内，每一秒被切断的蚯蚓被切断前的长度（有 mm 个数）； mm 秒后，所有蚯蚓的长度（有 n + mn+m 个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你…… 输入输出格式输入格式： 第一行包含六个整数 n,m,q,u,v,tn,m,q,u,v,t，其中：n,m,qn,m,q 的意义见【问题描述】；u,v,tu,v,t 均为正整数；你需要自己计算 p=u / vp=u/v（保证 0 &lt; u &lt; v0&lt;u&lt;v）；tt 是输出参数，其含义将会在【输出格式】中解释。 第二行包含 nn 个非负整数，为 a_1, a_2, \dots, a_na1,a2,…,an，即初始时 nn 只蚯蚓的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。 保证 1 \leq n \leq 10^51≤n≤105，0 \leq m \leq 7 \times 10^6，0 < u < v \leq 10^9 0 \leq q \leq 2000≤q≤200，1 \leq t \leq 71，0 \leq a_i \leq 10^8输出格式： 第一行输出 \left \lfloor \frac{m}{t} \right \rfloor⌊tm⌋ 个整数，按时间顺序，依次输出第 tt 秒，第 2t2t 秒，第 3t3t 秒，……被切断蚯蚓（在被切断前）的长度。 第二行输出 \left \lfloor \frac{n+m}{t} \right \rfloor⌊tn+m⌋ 个整数，输出 mm 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 tt，第 2t2t，第 3t3t，……的长度。 同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要输出，你也应输出一个空行。 请阅读样例来更好地理解这个格式。 输入输出样例输入样例#1： 123 7 1 1 3 13 3 2 输出样例#1： 123 4 4 4 5 5 66 6 6 5 5 4 4 3 2 2 输入样例#2： 123 7 1 1 3 23 3 2 输出样例#2： 124 4 56 5 4 3 2 输入样例#3： 123 7 1 1 3 93 3 2 输出样例#3： 12//空行2 说明【样例解释1】 在神刀手到来前：33只蚯蚓的长度为3,3,23,3,2。 11秒后：一只长度为33的蚯蚓被切成了两只长度分别为11和22的蚯蚓，其余蚯蚓的长度增加了11。最终44只蚯蚓的长度分别为(1,2),4,3(1,2),4,3。括号表示这个位置刚刚有一只蚯蚓被切断 22秒后：一只长度为44的蚯蚓被切成了11和33。55只蚯蚓的长度分别为：2,3,(1,3),42,3,(1,3),4。 3秒后：一只长度为44的蚯蚓被切断。66只蚯蚓的长度分别为：3,4,2,4,(1,3)3,4,2,4,(1,3)。 44秒后：一只长度为44的蚯蚓被切断。77只蚯蚓的长度分别为：4,(1,3),3,5,2,44,(1,3),3,5,2,4。 55秒后：一只长度为55的蚯蚓被切断。88只蚯蚓的长度分别为：5,2,4,4,(1,4),3,55,2,4,4,(1,4),3,5。 66秒后：一只长度为55的蚯蚓被切断。99只蚯蚓的长度分别为：(1,4),3,5,5,2,5,4,6(1,4),3,5,5,2,5,4,6。 77秒后：一只长度为66的蚯蚓被切断。1010只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)2,5,4,6,6,3,6,5,(2,4)。所以，77秒内被切断的蚯蚓的长度依次为3,4,4,4,5,5,63,4,4,4,5,5,6。77秒后，所有蚯蚓长度从大到小排序为6,6,6,5,5,4,4,3,2,26,6,6,5,5,4,4,3,2,2 【样例解释2】 这个数据中只有t=2t=2与上个数据不同。只需在每行都改为每两个数输出一个数即可。 虽然第一行最后有一个66没有被输出，但是第二行仍然要重新从第二个数再开始输出。 【样例解释3】 这个数据中只有t=9t=9与上个数据不同。 注意第一行没有数要输出，但也要输出一个空行。 【数据范围】 题解这不是题解，而是一个暴力。 直接优先队列暴力模拟80，写个屁的正解。 写模拟必须有一定的代码能力和调试技巧，很可惜这些我并没有，只能现在练练了。 这道题尽管对于优先队列暴力思路只有一点：将“把其他蚯蚓加上一个值”转换为“将当前蚯蚓减少一个值”，这样我们就可以做到 O(mlog(n+m))的复杂度。 顺便算下NOIp 2016在正常发挥下的分数 100 + (30~60) + 100 + 100 + 85 + 100 = 545 这个分数相当可观，T2的60还是能写的。 不过据说D2T2卡常得少个20分？D2T3其实考场也只有85分 100 + 60 + 100 + 100 + 65 + 85 = 515 ， 完全OK！ P1563 玩具谜题题目描述小南有一套可爱的玩具小人, 它们各有不同的职业。 有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图: 这时singersinger告诉小南一个谜題: “眼镜藏在我左数第3个玩具小人的右数第11个玩具小人的左数第22个玩具小人那里。 ” 小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。 小南一边艰难地辨认着玩具小人, 一边数着: singersinger朝内, 左数第33个是archerarcher。 archerarcher朝外,右数第11个是thinkerthinker。 thinkerthinker朝外, 左数第22个是writewriter。 所以眼镜藏在writerwriter这里! 虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜題的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜題。 这样的谜題具体可以描述为: 有 nn个玩具小人围成一圈, 已知它们的职业和朝向。现在第11个玩具小人告诉小南一个包含mm条指令的谜題, 其中第 zz条指令形如“左数/右数第ss,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。 输入输出格式输入格式： 输入的第一行包含两个正整数 n,mn,m，表示玩具小人的个数和指令的条数。 接下来 nn 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 00 表示朝向圈内，11 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 1010 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。 接下来 mm 行，其中第 ii 行包含两个整数 a_i,s_iai,si，表示第 ii 条指令。若 a_i=0ai=0，表示向左数 s_isi 个人；若 a_i=1ai=1，表示向右数 s_isi 个人。 保证 a_iai 不会出现其他的数，1 \le s_i &lt; n1≤si&lt;n。 输出格式： 输出一个字符串，表示从第一个读入的小人开始，依次数完 mm 条指令后到达的小人的职业。 输入输出样例输入样例#1： 12345678910117 30 singer0 reader0 mengbier 1 thinker1 archer0 writer1 mogician 0 31 10 2 输出样例#1： 1writer 输入样例#2： 12345678910111213141516171819202110 101 C0 r0 P1 d1 e1 m1 t1 y1 u0 V1 71 11 40 50 30 11 61 20 80 4 输出样例#2： 1y 说明【样例1说明】 这组数据就是【题目描述】 中提到的例子。 【子任务】 子任务会给出部分测试数据的特点。 如果你在解决题目中遇到了困难, 可以尝试只解决一部分测试数据。 每个测试点的数据规模及特点如下表: 其中一些简写的列意义如下: • 全朝内: 若为“√”, 表示该测试点保证所有的玩具小人都朝向圈内; 全左数:若为“√”,表示该测试点保证所有的指令都向左数,即对任意的 1≤z≤m, a_i=01≤z≤m,ai=0; s= 1s=1:若为“√”,表示该测试点保证所有的指令都只数1个,即对任意的 1≤z≤m,s_i=11≤z≤m,si=1; 职业长度为11 :若为“√”,表示该测试点保证所有玩具小人的职业一定是一个 长度为11的字符串。 题解看到2016除了天天爱跑步那道神题就这道水题了，考场上一遍过确实没啥压力。 Code： 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;map&gt;#define maxn 100005std::string s;std::map&lt;int,std::string&gt; vis;int n , d[maxn] , m;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 0 ; i &lt; n ; ++i) scanf("%d",&amp;d[i]) , std::cin&gt;&gt;s , vis[i] = s; int pos = 0; for(int i = 1 ; i &lt;= m ; ++i)&#123; int dir , x; scanf("%d%d",&amp;dir,&amp;x); if(d[pos] == 0)&#123; if(dir == 0) pos -= x; else pos += x; &#125; else if(d[pos] == 1)&#123; if(dir == 0)&#123; pos += x; &#125; else pos -= x; &#125; pos = (pos % n + n) % n; &#125; std::cout&lt;&lt;vis[pos]&lt;&lt;std::endl;&#125; 关于的逛公园解题心得首先对于这类题要对数据敏感，以及有一个算法猜想，假设你看到这道题想到了利用DP子问题的思路并且设出了 F(n,k)这个状态，那么这道题你就做出来了一半。 接下来考虑图上DP所能用的更新方式，对于有向图可以记忆化搜索，对于所有图SPFA的松弛思想应该都可以，明天准备试试SPFA的更新方法能不能过。 本题没有高难度的算法，但是思维难度与综合难度上并不输D2T2和D2T3（尽管这两题的正解我还是不会） 明天大概就是处理完2017,2015的题，能自己写出来的尽量自己写。]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.20]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-20%2F</url>
    <content type="text"><![CDATA[[USACO12OPEN]平衡的奶牛群题目描述Farmer John’s owns N cows (2 &lt;= N &lt;= 20), where cow i produces M(i) units of milk each day (1 &lt;= M(i) &lt;= 100,000,000). FJ wants to streamline the process of milking his cows every day, so he installs a brand new milking machine in his barn. Unfortunately, the machine turns out to be far too sensitive: it only works properly if the cows on the left side of the barn have the exact same total milk output as the cows on the right side of the barn! Let us call a subset of cows “balanced” if it can be partitioned into two groups having equal milk output. Since only a balanced subset of cows can make the milking machine work, FJ wonders how many subsets of his N cows are balanced. Please help him compute this quantity. 给n个数，从中任意选出一些数，使这些数能分成和相等的两组。 求有多少种选数的方案。 输入输出格式输入格式： * Line 1: The integer N. * Lines 2..1+N: Line i+1 contains M(i). 输出格式： * Line 1: The number of balanced subsets of cows. 输入输出样例输入样例#1： 123454 1 2 3 4 输出样例#1： 13 说明There are 4 cows, with milk outputs 1, 2, 3, and 4. There are three balanced subsets: the subset {1,2,3}, which can be partitioned into {1,2} and {3}, the subset {1,3,4}, which can be partitioned into {1,3} and {4}, and the subset {1,2,3,4} which can be partitioned into {1,4} and {2,3}..题解这题用了一种高级的搜索策略叫做meet in the middle. 就是将这些数分成两半，分别算出左右每个状态的值，然后对状态排序后双指针匹配。快的原因就是我们双指针匹配是近似线性的（假如一个和上一个相同那右指针就要跳回上一个最初的地方，但是这个事实上是没法卡的） 这个方法快的原因是避免了很对没有用的状态搜索，让左边小的匹配右边大的是种很合理的策略。 然后我们最后算法的时间复杂度是 O(2*3^{\frac{n}{2}} + nlogn + n )对于本题跑的飞快 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 21struct Node&#123; int sum , Status;&#125;L[1&lt;&lt;maxn] , R[1&lt;&lt;maxn];int n , p[maxn] , cntl , cntr , ans;bool vis[1&lt;&lt;maxn];inline bool cmp(Node x , Node y)&#123;return x.sum &lt; y.sum ;&#125;inline bool cmp2(Node x , Node y)&#123;return x.sum &gt; y.sum;&#125;void dfs(int b , int e , int sum , int Status)&#123; if(b &gt; e) &#123; if(e == n/2) L[++cntl].sum = sum , L[cntl].Status = Status; else R[++cntr].sum = sum , R[cntr].Status = Status; return; &#125; dfs(b+1 , e , sum+p[b] , Status + (1&lt;&lt;b)); dfs(b+1 , e , sum - p[b] , Status + (1&lt;&lt;b)); dfs(b+1 , e , sum , Status);&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;p[i]); dfs(1,n/2,0,0); dfs(n/2+1,n,0,0); std::sort(L+1,L+cntl+1,cmp); std::sort(R+1,R+cntr+1,cmp2); int l = 1 , r = 1; while(l &lt;= cntl &amp;&amp; r &lt;= cntr) &#123; while(L[l].sum + R[r].sum &gt; 0 &amp;&amp; r &lt;= cntr) ++r; int pre = r; while(L[l].sum + R[r].sum == 0 &amp;&amp; r &lt;= cntr) &#123; if(!vis[L[l].Status|R[r].Status]) vis[L[l].Status|R[r].Status] = true , ++ans; ++r; &#125; if(L[l].sum == L[l+1].sum) r = pre; ++l; &#125; printf("%d",ans-1);&#125; [NOI2015]软件包管理器题目描述Linux用户和OSX用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu使用的apt-get，Fedora/CentOS使用的yum，以及OSX下可用的homebrew都是优秀的软件包管理器。 你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包A依赖软件包B，那么安装软件包A以前，必须先安装软件包B。同时，如果想要卸载软件包B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除0号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而0号软件包不依赖任何一个软件包。依赖关系不存在环（若有m(m≥2)个软件包A1,A2,A3,⋯,Am，其中A1依赖A2，A2依赖A3，A3依赖A4，……，A[m-1]依赖Am，而Am依赖A1，则称这m个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。 现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为0。 输入输出格式输入格式： 从文件manager.in中读入数据。 输入文件的第1行包含1个整数n，表示软件包的总数。软件包从0开始编号。 随后一行包含n−1个整数，相邻整数之间用单个空格隔开，分别表示1,2,3,⋯,n−2,n−1号软件包依赖的软件包的编号。 接下来一行包含1个整数q，表示询问的总数。之后q行，每行1个询问。询问分为两种： install x：表示安装软件包x uninstall x：表示卸载软件包x 你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态。 对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）。 输出格式： 输出到文件manager.out中。 输出文件包括q行。 输出文件的第i行输出1个整数，为第i步操作中改变安装状态的软件包数。 输入输出样例输入样例#1： 1234567870 0 0 1 1 55install 5install 6uninstall 1install 4uninstall 0 输出样例#1： 1234531323 输入样例#2： 复制 12345678910111213100 1 2 1 3 0 0 3 210install 0install 3uninstall 2install 7install 5install 9uninstall 9install 4install 1install 9 输出样例#2： 复制 123456789101321311101 说明【样例说明 1】 一开始所有的软件包都处于未安装状态。 安装5号软件包，需要安装0,1,5三个软件包。 之后安装6号软件包，只需要安装6号软件包。此时安装了0,1,5,6四个软件包。 卸载1号软件包需要卸载1,5,6三个软件包。此时只有0号软件包还处于安装状态。 之后安装4号软件包，需要安装1,4两个软件包。此时0,1,4处在安装状态。最后，卸载0号软件包会卸载所有的软件包。` 【数据范围】 【时限1s，内存512M】 题解显然安装一个软件x就是1~x这条链都被安装，卸载是整个子树被卸载。于是树链剖分之后就变成了线段树上的线段覆盖。线段树的线段覆盖就是可以将当前区间覆盖多次，但有新的一条来了就要立刻改成新的值。这样tag和node对于这道题只需要记录是否被覆盖就可以。所以我pushdown判断是否下推用0结果害得我调了5个小时，请注意覆盖0的标记和空标记Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005int head[maxn] , cnt , hs[maxn] , sz[maxn] , id[maxn] , idx , f[maxn] ,top[maxn] ,dep[maxn] , n , m, num[maxn];std::string s;struct edge&#123; int next , to;&#125;e[maxn*2];struct SegmentTree&#123; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) #define pushup(x) sum[x] = sum[ls(x)] + sum[rs(x)] int sum[maxn&lt;&lt;2] , tag[maxn&lt;&lt;2]; inline void pushdown(int Node , int ln , int rn) &#123; if(tag[Node] != -1) &#123; sum[ls(Node)] = tag[Node] * ln; sum[rs(Node)] = tag[Node] * rn; tag[ls(Node)] = tag[Node]; tag[rs(Node)] = tag[Node]; &#125; tag[Node] = -1; &#125; void build(int l , int r , int Node , int s[]) &#123; if(l == r) &#123; sum[Node] = s[l]; tag[Node] = -1; return; &#125; int mid = l + r &gt;&gt; 1; build(l,mid,ls(Node) , s); build(mid + 1, r , rs(Node), s); pushup(Node); &#125; void update(int L , int R , int l , int r , int Node , int v) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; sum[Node] = v * (r-l+1); tag[Node] = v; return; &#125; int mid = l + r &gt;&gt; 1; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) update(L , R , l , mid , ls(Node) , v); if(R &gt; mid) update(L , R , mid + 1, r , rs(Node) , v); pushup(Node); &#125; int query(int L , int R , int l , int r , int Node) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[Node]; int mid = l + r &gt;&gt; 1 , ans = 0; pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) ans += query(L , R , l , mid , ls(Node)); if(R &gt; mid) ans += query(L , R , mid + 1, r , rs(Node)); return ans; &#125;&#125;sgt;void dfs1(int x , int fx)&#123; f[x] = fx; dep[x] = dep[fx] + 1; sz[x] = 1; int maxx = -1 ; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs1(e[i].to,x) , sz[x] += sz[e[i].to];//dfs1(e[i].to,x) not dfs1(e[i].to,fx)!!!!!!!!!!!!!! for(int i = head[x] ; i ; i = e[i].next) if(sz[e[i].to] &gt; maxx &amp;&amp; e[i].to != fx) maxx = sz[e[i].to] , hs[x] = e[i].to;&#125;void dfs2(int x , int topV)&#123; id[x] = ++idx; // v[idx[x]] = val[x]; top[x] = topV; if(!hs[x]) return; dfs2(hs[x],topV); for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != f[x] &amp;&amp; e[i].to != hs[x]) dfs2(e[i].to , e[i].to);&#125;inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;void update(int x , int y , int v)&#123; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); sgt.update(id[top[x]] , id[x] , 1 , n , 1 , v); x = f[top[x]]; &#125; if(dep[x] &lt; dep[y]) std::swap(x,y); sgt.update(id[y] , id[x] , 1 , n , 1 , v);&#125;int query(int x, int y)&#123; int ans = 0; // printf("%d %d\n",x,y); while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); ans += sgt.query(id[top[x]] , id[x] , 1 , n , 1); x = f[top[x]]; &#125; if(dep[x] &lt; dep[y]) std::swap(x,y); ans += sgt.query(id[y] , id[x] , 1 , n , 1); return ans;&#125;void updSt(int x)&#123; // printf("updSt %d\n",x); sgt.update(id[x] , id[x] + sz[x] - 1 , 1 , n , 1 , 0);&#125;int querySt(int x)&#123; int ans = sgt.query(id[x] , id[x] + sz[x] - 1 , 1 , n , 1); // printf("queryST %d (id[%d] = %d): %d\n",x , id[x] , ans); return ans;&#125;int main()&#123; // freopen("SAC.in","r",stdin); // freopen("data.out","w",stdout); // n = 100; // sgt.update(1,9,1,n,1,1); // sgt.update(2,10,1,n,1,1); // sgt.update(3,11,1,n,1,1); // std::cout&lt;&lt;sgt.query(1,11,1,n,1)&lt;&lt;std::endl; // sgt.update(1,11,1,n,1,0); // std::cout&lt;&lt;sgt.query(1,11,1,n,1)&lt;&lt;std::endl; // sgt.update(2,7,1,n,1,1); // sgt.update(2,3,1,n,1,0); // std::cout&lt;&lt;sgt.query(2,7,1,n,1); scanf("%d",&amp;n); int x; for(int i = 2 ; i &lt;= n ; ++i) scanf("%d",&amp;x) , add(1 + x , i) , add(i , x + 1); dfs1(1,1); dfs2(1,1); sgt.build(1,n,1,num); // for(int i = 1 ; i &lt;= n ; ++i) // printf("id[%d] = %d\n",i,id[i]); // puts("OK"); scanf("%d",&amp;m); for(int i = 1 ; i &lt;= m ; ++i) &#123; std::cin&gt;&gt;s; if(s == "install") &#123; scanf("%d",&amp;x); ++x; int ans = query(1,x); // printf("bef %d\n",ans); // int ans = sgt.query(1,n,1,n,1); update(1,x,1); ans = query(1,x) - ans; // printf("now %d\n" , ans); // printf("curSGT : %d\n",sgt.query(1,n,1,n,1)); printf("%d\n",ans); // system("pause"); &#125; else&#123; scanf("%d",&amp;x); ++x; int ans = querySt(x); // printf("bef %d\n",ans); updSt(x); // ans = querySt(x) - ans; // // printf("now %d\n",ans); if(ans &lt; 0) ans = - ans; // printf("curSGT : %d\n",sgt.query(1,n,1,n,1)); printf("%d\n",ans); &#125; &#125;&#125; [ZJOI2008]树的统计题目描述一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。 我们将以下面的形式来要求你对这棵树完成一些操作： I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 III. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身 输入输出格式输入格式： 输入文件的第一行为一个整数n，表示节点的个数。 接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有一条边相连。 接下来一行n个整数，第i个整数wi表示节点i的权值。 接下来1行，为一个整数q，表示操作的总数。 接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。 输出格式： 对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。 输入输出样例输入样例#1： 12345678910111213141516171841 22 34 14 2 1 312QMAX 3 4QMAX 3 3QMAX 3 2QMAX 2 3QSUM 3 4QSUM 2 1CHANGE 1 5QMAX 3 4CHANGE 3 6QMAX 3 4QMAX 2 4QSUM 3 4 输出样例#1： 12345678910412210656516 说明对于100％的数据，保证1&lt;=n&lt;=30000，0&lt;=q&lt;=200000；中途操作中保证每个节点的权值w在-30000到30000之间。 题解HPD的简单题，线段树单点修改即可。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005#define ll long longint head[maxn] , cnt , hs[maxn] , sz[maxn] , id[maxn] , idx , n , m , v[maxn] , val[maxn] , f[maxn] ,top[maxn] , dep[maxn];struct edge&#123; int next , to;&#125;e[maxn*2];struct SegmentTree&#123; int sum[maxn&lt;&lt;2] , add[maxn&lt;&lt;2] , maxx[maxn&lt;&lt;2]; #define ls(x) (x&lt;&lt;1) #define rs(x) (x&lt;&lt;1|1) #define INF 0x7fffffff inline void pushup(int Node) &#123; sum[Node] = sum[ls(Node)] + sum[rs(Node)]; maxx[Node] = std::max(maxx[ls(Node)] , maxx[rs(Node)]); &#125; inline void pushdown(int Node , int ln , int rn) &#123; if(add[Node]) &#123; sum[ls(Node)] += ln * add[Node]; sum[rs(Node)] += rn * add[Node]; maxx[ls(Node)] += add[Node] ; maxx[rs(Node)] += add[Node] ; add[ls(Node)] += add[Node]; add[rs(Node)] += add[Node]; &#125; add[Node] = 0; &#125; void build(int l , int r , int Node , int s[]) &#123; if(l == r) &#123; sum[Node] = maxx[Node] = s[l]; return; &#125; int mid = l + r &gt;&gt; 1; build(l, mid , ls(Node) ,s); build(mid + 1, r , rs(Node) , s); pushup(Node); &#125; void update(int L , int R , int l , int r , int Node , int v) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; sum[Node] += (r - l + 1) * v; maxx[Node] += v; add[Node] += v; return; &#125; int mid = l + r &gt;&gt; 1; if(L &lt;= mid) update(L , R , l , mid , ls(Node) , v); if(R &gt; mid) update(L , R , mid + 1 , r , rs(Node) , v); pushup(Node); &#125; void updOne(int P , int l , int r , int Node , int v)//modify to v &#123; if(l == r) &#123; sum[Node] = maxx[Node] = v; return; &#125; int mid = l + r &gt;&gt; 1; if(P &lt;= mid) updOne(P , l , mid , ls(Node) , v); else updOne(P , mid + 1, r , rs(Node) , v); pushup(Node); &#125; int querySum(int L , int R , int l , int r , int Node) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return sum[Node]; int mid = l + r &gt;&gt; 1 , ans = 0; // pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) ans += querySum(L , R , l , mid , ls(Node)); if(R &gt; mid) ans += querySum(L , R , mid + 1 , r , rs(Node)); return ans; &#125; int queryMax(int L , int R , int l , int r , int Node) &#123; if(L &lt;= l &amp;&amp; r &lt;= R) return maxx[Node]; int mid = l + r &gt;&gt; 1 , ans = -INF; // pushdown(Node , mid - l + 1 , r - mid); if(L &lt;= mid) ans = std::max(ans , queryMax(L , R , l , mid , ls(Node))); if(R &gt; mid) ans = std::max(ans , queryMax(L , R , mid + 1, r , rs(Node))); return ans; &#125;&#125;sgt;void dfs1(int x , int fx)&#123; f[x] = fx; dep[x] = dep[fx] + 1; sz[x] = 1; int hson = 0; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs1(e[i].to , x) , sz[x] += sz[e[i].to]; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx &amp;&amp; sz[e[i].to] &gt; sz[hson]) hson = e[i].to; hs[x] = hson;&#125;void dfs2(int x , int TopV)&#123; id[x] = ++idx; v[id[x]] = val[x]; top[x] = TopV; if(!hs[x]) return; dfs2(hs[x] , TopV); for(int i = head[x] ; i ; i =e[i].next) if(e[i].to != f[x] &amp;&amp; e[i].to != hs[x]) dfs2(e[i].to , e[i].to);&#125;void updNode(int x , int v)&#123; sgt.updOne(id[x] , 1 , n , 1 , v);&#125;int Qmax(int u , int v)&#123; int ans = -0x7fffffff; while(top[u] != top[v]) &#123; if(dep[top[u]] &lt; dep[top[v]]) std::swap(u,v); ans = std::max(ans , sgt.queryMax(id[top[u]] , id[u] , 1 , n , 1)); u = f[top[u]]; &#125; if(dep[u] &lt; dep[v]) std::swap(u,v); ans = std::max(ans , sgt.queryMax(id[v] , id[u] , 1, n , 1)); return ans;&#125;int Qsum(int u , int v)&#123; int ans = 0; while(top[u] != top[v]) &#123; if(dep[top[u]] &lt; dep[top[v]]) std::swap(u,v); ans += sgt.querySum(id[top[u]] , id[u] , 1 , n , 1); u = f[top[u]]; &#125; if(dep[u] &lt; dep[v]) std::swap(u,v); ans += sgt.querySum(id[v] , id[u] , 1 , n , 1); return ans;&#125;inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;int main()&#123; scanf("%d",&amp;n); int x , y , d; for(int i = 1 ; i &lt;= n -1 ; ++i) scanf("%d%d",&amp;x,&amp;y) , add(x,y) , add(y,x); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;val[i]); dfs1(1,1); dfs2(1,1); sgt.build(1,n,1,v); int q; scanf("%d",&amp;q); std::string op; for(int i = 1 ; i &lt;= q ; ++i) &#123; std::cin&gt;&gt;op; if(op == "QSUM") scanf("%d%d",&amp;x,&amp;y) , printf("%d\n",Qsum(x,y)); if(op == "QMAX") scanf("%d%d",&amp;x,&amp;y) , printf("%d\n",Qmax(x,y)); if(op == "CHANGE") scanf("%d%d",&amp;x,&amp;y) , updNode(x,y); &#125;&#125; [USACO06NOV]玉米田Corn Fields题目描述Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. 农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。 John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案） 输入输出格式输入格式： 第一行：两个整数M和N，用空格隔开。 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。 输出格式： 一个整数，即牧场分配总方案数除以100,000,000的余数。 输入输出样例输入样例#1： 1232 31 1 10 1 0 输出样例#1： 19 题解少有的我会做的状态压缩dp 将每个行合法的状态预处理（常数优化），然后每次在当前行与上一行转移的时候只需要判断两个行状态一起合不合法。计数就是加法原理，对于当前行状态之前所有与当前行合法的行状态的方案数都是当前行状态的方案。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 15#define mod 100000000int S , s[maxn][maxn] , n , m , c[maxn] , f[maxn][1&lt;&lt;maxn] , sta[maxn][1&lt;&lt;maxn];inline bool check(int row , int Sta)&#123; for(int i = 1 ; i &lt;= m ; ++i) if(!s[row][i] &amp;&amp; (Sta &amp; (1&lt;&lt;(i-1)))) return false; return true;&#125;void write(int x)&#123; if(!x) return; write(x/2); putchar((x&amp;1)+48);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) scanf("%d",&amp;s[i][j]); S = (1&lt;&lt;m)-1; for(int i = 1 ; i &lt;= n ; ++i)// if(check(j)) continue; if((j &amp; (j&lt;&lt;1)) || (j &amp; (j &gt;&gt; 1))) continue; for(int j = 0 ; j &lt;= S ; ++j) if(check(i,j) &amp;&amp; !(j &amp; (j&lt;&lt;1)) &amp;&amp; !(j &amp; (j&gt;&gt;1))) sta[i][++c[i]] = j; // for(int i = 1 ; i &lt;= n ; ++i) // &#123; // for(int j = 1 ; j &lt;= c[i] ; ++j) // write(sta[i][j]) , putchar(32); // putchar(10); // &#125; for(int i = 1 ; i &lt;= c[1] ; ++i) f[1][sta[1][i]] = 1; for(int i = 2 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= c[i] ; ++j) for(int k = 1 ; k &lt;= c[i-1] ; ++k) &#123; if(sta[i][j] &amp; sta[i-1][k]) continue; (f[i][sta[i][j]] += f[i-1][sta[i-1][k]]) %= mod; &#125; int ans = 0; for(int i = 1 ; i &lt;= c[n] ; ++i) (ans += f[n][sta[n][i]]) %= mod; printf("%d",ans);&#125; 「一本通 5.1 练习 1」括号配对题目描述Hecy 又接了个新任务：BE 处理。BE 中有一类被称为 GBE。 以下是 GBE 的定义： 空表达式是 GBE 如果表达式 A 是 GBE，则 [A] 与 (A) 都是 GBE 如果 A 与 B 都是 GBE，那么 AB 是 GBE 输入格式输入仅一行，为字符串 BE 输出格式输出仅一个整数，表示增加的最少字符数 样例样例输入1[]) 样例输出11 数据范围与提示对于 100%的数据，输入的字符串长度小于 100。 题解区间dp基础练习。 题目似乎已经把如何转移告诉你了。。 设 f(l,r)表示这个区间变成合法区间的最少字符数，对于条件二，有 f(l,r) = min\{f(l,r),f(l+1,r-1)\}对于条件3 f(l,r) = min\{f(l,r) , f(l,k) + f(k+1,r)\}初始状态也就是区间长度是1的时候只需要一个字符匹配。 这题没有恶心的细节，实现起来非常自然qwq！ Code: 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include&lt;iostream&gt;#define maxn 105int f[maxn][maxn] , n;char s[maxn];int main()&#123; scanf("%s",s+1); while(s[++n] != '\0'); // printf("%d",--len); --n; for(int i = 1 ; i &lt;= n ; ++i) f[i][i] = 1; // for(int i = 1 ; i &lt;= n ; ++i) // putchar(s[i]); for(int i = 2 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= n - i + 1 ; ++j) &#123; int to = j + i - 1; f[j][to] = 0x7fffffff; for(int k = j ; k &lt; to ; ++k) f[j][to] = std::min(f[j][k] + f[k+1][to] , f[j][to]); if((s[j] == '[' &amp;&amp; s[to] ==']') || (s[j] == '(' &amp;&amp; s[to] == ')')) f[j][to] = std::min(f[j+1][to-1] , f[j][to]); // printf("f[%d][%d] = %d\n",j,to,f[j][to]); &#125; printf("%d",f[1][n]);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.15]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-15%2F</url>
    <content type="text"><![CDATA[序列sequence题目描述给定一个序列，每次操作可以把某个数+1-1。要求把序列变成非降数列。而且要求修改后的数列只能出现修改前的数。 输入输出格式输入格式： 第一行输入一个n，表示有n (n \leq 5*10^5）个数字。第二行输入n个整数，整数的绝对值不超过 10^9输出格式： 输出一个数，表示最少的操作次数 输入输出样例输入样例#1： 1253 2 -1 2 11 输出样例#1： 14 输入样例#2： 1252 1 1 1 1 输出样例#2： 11 题解这道题的定位是高难度贪心，事实上是我见过的最难的贪心之一。 这道题现在想来分析出来不是很难 不难看出，y减小的越多，后面的序列越容易变成非降，那么只要让yy减小到xx就好了 看到这里，我一直有一个疑问，如果令yy减小到xx之后，序列不满足非降了怎么办？ 仔细想了想，实际上应该是这样的：为了让序列非降，y不能小于y之前的最大值。而由于y是整个序列的最大值，如果它之前的最大值zz小于等于xx，那么将y减小到x仍能保证序列是非降的。否则的话，z大于x小于y，仍是在区间[x,y][x,y]内，那么移动的代价是y-x，所以用于更新答案是没有问题的 那么这里为什么要让y减到最小呢？这是因为x和y不论如何调整，他们的代价之和都已经不变了，但问题是他们目前选的最优方案并不是之后的最优。为了满足他们在之后最优，只有把y减小到x，才能保证之后更有可能非降。 概括一下，对于当前的数，无论最优解如何，对答案的贡献是一定的。而为了保证之后的解也最优，令y减小到x，可以保证之后的解最优，且不会影响当前的最优解 Code: 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int n;long long ans;priority_queue&lt;int&gt; q;int main() &#123; scanf("%d",&amp;n); for(int i = 1; i &lt;= n; i++) &#123; int num; scanf("%d",&amp;num); q.push(num); if(num &lt; q.top()) &#123; ans += q.top() - num; q.pop(); q.push(num); &#125; &#125; printf("%lld\n", ans);&#125; 差分约束系统今天开始刷一遍一本通提高篇，看到了图论的这个东西。 简单来说是求解一系列线性变量差值不等式的方法，因为和最短路的三角形不等式原理一样，我们就可以通过建立图论模型，用最短路求解。 一、何为差分约束系统： 差分约束系统（system of difference constraints），是求解关于一组变数的特殊不等式组之方法。如果一个系统由n个变量和m个约束条件组成，其中每个约束条件形如xj-xi&lt;=bk(i,j∈[1,n],k∈[1,m]),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。 通俗一点地说，差分约束系统就是一些不等式的组，而我们的目标是通过给定的约束不等式组求出最大值或者最小值或者差分约束系统是否有解。 二、差分约束系统的求解： 差分约束系统可以转化为图论来解决，对应于上面的不等式组，如果要求出x3-x0的最大值的话，叠加不等式可以推导出x3-x0&lt;=7,最大值即为7，我们可以通过建立一个图，包含6个顶点，对每个xj-xi&lt;=bk，建立一条i到j的有向边，权值为bk。通过求出这个图的x0到x3的最短路可以知道也为7，这是巧合吗？并不是。 之所以差分约束系统可以通过图论的最短路来解，是因为xj-xi&lt;=bk，会发现它类似最短路中的三角不等式d[v] &lt;=d[u]+w[u,v]，即d[v]-d[u]&lt;=w[u,v]。而求取最大值的过程类似于最短路算法中的松弛过程。 三角不等式：（在此引用大牛的博客） B - A &lt;= c (1) C - B &lt;= a (2) C - A &lt;= b (3) 如果要求C-A的最大值，可以知道max（C-A）= min(b,a+c),而这正对应了下图中C到A的最短路。 因此，对三角不等式加以推广，变量n个，不等式m个，要求xn-x1的最大值，便就是求取建图后的最短路。 同样地，如果要求取差分约束系统中xn-x1的最小值，便是求取建图后的最长路。最长路可以通过spfa求出来，只需要改下松弛的方向即可，即if(d[v] &lt; d[u] + dist(u,v)) d[v] = d[u] + dist(u,v)。当然我们可以把图中所有的边权取负，求取最短路，两者是等价的。 最长路求解算法证明如下： 最后一点，建图后不一定存在最短路/最长路，因为可能存在无限减小/增大的负环/正环，题目一般会对应于不同的输出。判断差分约束系统是否存在解一般判环即可。 注意不能用DIJ算法，只能用死去的SPFA或者Bellman-Ford Interval Time Limit: 2000MS Memory Limit: 65536K Total Submissions: 30524 Accepted: 11834 Description You are given n closed, integer intervals [ai, bi] and n integers c1, …, cn.Write a program that:reads the number of intervals, their end points and integers c1, …, cn from the standard input,computes the minimal size of a set Z of integers which has at least ci common elements with interval [ai, bi], for each i=1,2,…,n,writes the answer to the standard output. Input The first line of the input contains an integer n (1 &lt;= n &lt;= 50000) — the number of intervals. The following n lines describe the intervals. The (i+1)-th line of the input contains three integers ai, bi and ci separated by single spaces and such that 0 &lt;= ai &lt;= bi &lt;= 50000 and 1 &lt;= ci &lt;= bi - ai+1. Output The output contains exactly one integer equal to the minimal size of set Z sharing at least ci elements with interval [ai, bi], for each i=1,2,…,n. Sample Input 12345653 7 38 10 36 8 11 3 110 11 1 Sample Output 16 题解差分约束求解即可，注意隐含条件比如每个数只能选一次或者前i+1个数选的一定比i个多这种。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 50005int head[maxn] , cnt , n , s , t , d[maxn];bool inq[maxn];struct edge&#123; int next ,to , dis;&#125;e[maxn * 10];inline void add(int x , int y , int d)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;inline void SPFA(int s)&#123; std::queue&lt;int&gt; q; for(int i = s ; i &lt;= t ; ++i) d[i] = -0x7ffffff; d[s] = 0; q.push(s); inq[s] = true; while(!q.empty()) &#123; int k = q.front(); q.pop(); inq[k] = false; for(int i = head[k] ; i ; i = e[i].next) &#123; if(d[k] + e[i].dis &gt; d[e[i].to]) &#123; d[e[i].to] = d[k] + e[i].dis; if(!inq[e[i].to]) q.push(e[i].to) , inq[e[i].to] = true; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); int x , y , dd; for(int i = 1; i &lt;= n ; ++i) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;dd); add(x-1,y,dd) , s = std::min(x-1,s) , t = std::max(t,y); &#125; for(int i = s ; i &lt;= t ; ++i) &#123; add(i,i+1,0); add(i+1,i,-1); &#125; SPFA(s); printf("%d",d[t]);&#125; [Wind Festival]Running In The Sky题目背景[Night - 20:02[Night−20:02 P.M.]P.M.] 夜空真美啊……但是……快要结束了呢…… 题目描述一天的活动过后，所有学生都停下来欣赏夜空下点亮的风筝。CurtisCurtis NishikinoNishikino想要以更近的视角感受一下，所以她跑到空中的风筝上去了(这对于一个妹子来说有点匪夷所思)! 每只风筝上的灯光都有一个亮度 k_iki. 由于风的作用，一些风筝缠在了一起。但是这并不会破坏美妙的气氛，缠在一起的风筝会将灯光汇聚起来，形成更亮的光源！ CurtisCurtis NishikinoNishikino已经知道了一些风筝间的关系，比如给出一对风筝(a,b)(a,b), 这意味着她可以从 aa 跑到 bb 上去，但是不能返回。 现在，请帮她找到一条路径(她可以到达一只风筝多次，但只在第一次到达时她会去感受上面的灯光), 使得她可以感受到最多的光亮。同时请告诉她这条路径上单只风筝的最大亮度，如果有多条符合条件的路径，输出能产生最大单只风筝亮度的答案。 输入输出格式输入格式： 第一行两个整数 nn 和 mm. nn 是风筝的数量, mm 是风筝间关系对的数量. 接下来一行 nn 个整数 k_iki. 接下来 mm 行, 每行两个整数 aa 和 bb, 即CurtisCurtis可以从 aa 跑到 bb. 输出格式： 一行两个整数。CurtisCurtis在计算出的路径上感受到的亮度和，这条路径上的单只风筝最大亮度. 输入输出样例输入样例#1： 12345675 58 9 11 6 71 22 32 44 55 2 输出样例#1： 141 11 说明对于 20% 的数据, 0]]></content>
      <tags>
        <tag>贪心 Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef-> NO.19]]></title>
    <url>%2F2018%2F11%2F17%2FNO.-19%2F</url>
    <content type="text"><![CDATA[[ZJOI2005]午餐题目描述上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。 THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。 现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。 假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。 现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。 输入输出格式输入格式： 第一行一个整数N，代表总共有N个人。 以下N行，每行两个整数 Ai，Bi。依次代表第i个人的打饭时间和吃饭时间。 输出格式： 一个整数T，代表所有人吃完饭的最早时刻。 输入输出样例输入样例#1： 12345652 27 71 36 48 5 输出样例#1： 117 说明所有输入数据均为不超过200的正整数。 题解一道贪心+dp的好题（然而我只会贪心qwq） 首先思考一下发现打饭时间不管怎么安排用的时间肯定是不变的，唯一有区别的是吃饭时间结束的早晚。 因此我们贪心的将吃饭时间多的放后面。 然后是dp，我居然看了数据范围没想出状态。。 设 f(i,j)表示前 i个人在一食堂打 j时间饭所用的最小时间。 我们只需要考虑第i个人在1号还是2号食堂。 然后对于一号食堂转移就是 f(i,j) = min\{f(i,j),max\{f(i-1,j-w(i)),j+c(i)\}\}max里的左边表示当前打饭+吃饭时间较短不会对下一人产生影响， 右边表示吃饭时间延续到下一人。 对于二号食堂同理。 这题的dp还是挺难想的。。 Code： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 205struct Node&#123; int v , k;&#125;p[maxn];inline bool operator &lt; (Node x , Node y)&#123; // if(x.v == y.v) return x.v &gt; y.v; return x.k &gt; y.k ;&#125;int ans , n , f[maxn][maxn*maxn] , s[maxn];int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;p[i].v,&amp;p[i].k); std::sort(p+1,p+n+1); for(int i = 1 ; i &lt;= n ; ++i) s[i] = s[i-1] + p[i].v; // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d %d\n",p[i].v,p[i].k); std::memset(f,0x7f,sizeof(f)); f[0][0] = 0; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= s[i] ; ++j) &#123; if(j &gt;= p[i].v) f[i][j] = std::min(f[i][j] , std::max(f[i-1][j-p[i].v] , j + p[i].k)); f[i][j] = std::min(f[i][j] , std::max(f[i-1][j], s[i] - j + p[i].k) ); &#125; int ans = 0x7ffffff ; for(int i = 1 ; i &lt;= s[n] ; ++i) ans = std::min(ans , f[n][i]); printf("%d",ans);&#125; [USACO08NOV]奶牛混合起来Mixed Up Cows题目描述Each of Farmer John’s N (4 &lt;= N &lt;= 16) cows has a unique serial number S_i (1 &lt;= S_i &lt;= 25,000). The cows are so proud of it that each one now wears her number in a gangsta manner engraved in large letters on a gold plate hung around her ample bovine neck. Gangsta cows are rebellious and line up to be milked in an order called ‘Mixed Up’. A cow order is ‘Mixed Up’ if the sequence of serial numbers formed by their milking line is such that the serial numbers of every pair of consecutive cows in line differs by more than K (1 &lt;= K &lt;= 3400). For example, if N = 6 and K = 1 then 1, 3, 5, 2, 6, 4 is a ‘Mixed Up’ lineup but 1, 3, 6, 5, 2, 4 is not (since the consecutive numbers 5 and 6 differ by 1). How many different ways can N cows be Mixed Up? For your first 10 submissions, you will be provided with the results of running your program on a part of the actual test data. POINTS: 200 约翰家有N头奶牛，第i头奶牛的编号是Si，每头奶牛的编号都是唯一的。这些奶牛最近 在闹脾气，为表达不满的情绪，她们在挤奶的时候一定要排成混乱的队伍。在一只混乱的队 伍中，相邻奶牛的编号之差均超过K。比如当K = 1时，1, 3, 5, 2, 6, 4就是一支混乱的队伍， 而1, 3, 6, 5, 2, 4不是，因为6和5只差1。请数一数，有多少种队形是混乱的呢？ 输入输出格式输入格式： * Line 1: Two space-separated integers: N and K * Lines 2..N+1: Line i+1 contains a single integer that is the serial number of cow i: S_i 输出格式： * Line 1: A single integer that is the number of ways that N cows can be ‘Mixed Up’. The answer is guaranteed to fit in a 64 bit integer. 输入输出样例输入样例#1： 123454 1 3 4 2 1 输出样例#1： 12 说明The 2 possible Mixed Up arrangements are: 3 1 4 2 2 4 1 3 题解是一道状态压缩dp的简单题。 理清题意，我们只需要关注最后加进去的一头牛和没加之前有多少方案，最后加的这头牛可以是之前状态没加的任何一头牛，然后之前加的最后一头牛可以是状态中的任何一头牛。 我们设 f(i,S)表示状态为S且最后加入一头牛是i的方案数为多少 初始化对于只有一头牛我们都设成是一种方案（因为后面的状态从它转移当且仅当他们之间的编号&gt;=k，因此不会多算） 然后枚举状态，枚举最后的牛，枚举新加入的牛，刷表转移。 Code: 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 17int S , p[maxn] , n , c;long long f[maxn][1&lt;&lt;maxn] ;int main()&#123; scanf("%d%d",&amp;n,&amp;c); for(int i = 0 ; i &lt; n ; ++i) scanf("%d",&amp;p[i]); for(int i = 0 ; i &lt; n ; ++i) f[i][1&lt;&lt;i] = 1; S = (1&lt;&lt;n)-1; for(int i = 0 ; i &lt;= S ; ++i) for(int j = 0 ; j &lt; n ; ++j)//the last cow join in for(int k = 0 ; k &lt; n ; ++k) if((1&lt;&lt;j)&amp;i) &#123; if((1&lt;&lt;k)&amp;i) continue; if(abs(p[j]-p[k]) &lt;= c) continue; f[k][i|(1&lt;&lt;k)] += f[j][i]; &#125; long long ans = 0; for(int i = 0 ; i &lt; n ; ++i) ans += f[i][S]; printf("%lld",ans);&#125; 「一本通 4.1 例 2」数星星 Stars原题来自：Ural 1028 天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。如果一个星星的左下方（包含正左和正下）有 kkk 颗星星，就说这颗星星是 kkk 级的。 例如，上图中星星 555 是 333 级的（1,2,41,2,41,2,4 在它左下），星星 2,42,42,4 是 111 级的。例图中有 111 个 000 级，222 个 111 级，111 个 222 级，111 个 333 级的星星。 给定星星的位置，输出各级星星的数目。 一句话题意 \ 给定 nnn 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。 输入格式第一行一个整数 NNN，表示星星的数目；接下来 NNN 行给出每颗星星的坐标，坐标用两个整数 x,yx,yx,y 表示；不会有星星重叠。星星按 yyy 坐标增序给出，yyy 坐标相同的按 xxx 坐标增序给出。 输出格式NNN 行，每行一个整数，分别是 000 级，111 级，222 级，……，N−1N-1N−1 级的星星的数目。 样例样例输入12345651 15 17 13 35 5 样例输出1234512110 数据范围与提示对于全部数据， 1≤N≤1.5×104,0≤x,y≤3.2×1041\le N\le 1.5\times 10^4,0\le x,y\le 3.2\times 10^4题解树状数组经典题。 假设题目没有给你按这种顺序，才算有点难度，应考虑如何按顺序加入一维树状数组才能算出个数。 假设我们按x坐标建立树状数组，从左往右将点插入树状数组中。那么y坐标在插入顺序中必须升序。 因为y坐标大的包含所有x坐标小于这个点的点。有点类似于扫描线？ Code： 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 100005int x , y , bit[maxn] , n , ans[maxn], ly;inline int lowbit(int x)&#123;return x &amp; -x;&#125;inline int query(int x)&#123; int ans = 0; for(int i = x ; i ; i -= lowbit(i)) ans += bit[i]; return ans;&#125;inline void update(int x)&#123; for(int i = x ; i &lt;= 32005; i += lowbit(i)) bit[i] += 1;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); ++x,++y; ++ans[query(x)]; update(x); &#125; for(int i = 0 ; i &lt;= n-1 ; ++i) printf("%d\n",ans[i]);&#125; 选课题目描述在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 输入输出格式输入格式： 第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300) 接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。 输出格式： 只有一行，选M门课程的最大得分。 输入输出样例输入样例#1： 123456787 42 20 10 42 17 17 62 2 输出样例#1： 113 题解树上背包。 思路大致是这样的，还是以子树为单位。 由题意可知，每个点被选则它到跟的路径上的所有点都必须选。 设 f(i,j)表示i子树选j个的最大值是多少。 dp[v][k]=dp[u][k]+val~~~~ dp[u][k]=max(dp[u][k],dp[v][k−1])恩，就这样。。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 305#define maxm 305int f[maxn][maxm] , n , head[maxn] , m , val[maxn] , cnt;struct edge&#123; int next , to;&#125;e[maxn*2];void dfs(int x , int cnt , int fx)&#123; if(cnt == 0) return; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fx) continue; for(int k = 0 ; k &lt; cnt ; ++k) f[v][k] = f[x][k] + val[v]; dfs(v , cnt - 1 , x); for(int k = 1 ; k &lt;= cnt ; ++k) f[x][k] = std::max(f[x][k] , f[v][k-1]); &#125;&#125;inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y; for(int i = 1 ; i &lt;= n; ++i) scanf("%d%d",&amp;x,&amp;y) , add(i,x) , add(x,i) , val[i] = y;//the i dfs(0,m,0); printf("%d\n",f[0][m]);&#125; NOIp 2012 D2T3 疫情控制题目描述HH 国有 nn个城市，这 nn 个城市用n-1n−1条双向道路相互连通构成一棵树，11号城市是首都，也是树中的根节点。 HH国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。 现在，在 HH 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。 请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。 输入输出格式输入格式： 第一行一个整数nn，表示城市个数。 接下来的 n-1 行，每行33个整数，u,v,w，每两个整数之间用一个空格隔开，表示从城市 u到城市v 有一条长为 w 的道路。数据保证输入的是一棵树，且根节点编号为 1。 接下来一行一个整数 m，表示军队个数。 接下来一行 m个整数，每两个整数之间用一个空格隔开，分别表示这 m 个军队所驻扎的城市的编号。 输出格式： 一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出-1−1。 输入输出样例输入样例#1： 1234564 1 2 1 1 3 2 3 4 3 2 2 2 输出样例#1： 13 说明【输入输出样例说明】 第一支军队在 22 号点设立检查点，第二支军队从 22 号点移动到33 号点设立检查点，所需时间为 33 个小时。 【数据范围】 保证军队不会驻扎在首都。 对于 20%的数据， 2≤ n≤ 10对于 40%的数据， 2 ≤n≤50,0]]></content>
  </entry>
  <entry>
    <title><![CDATA[树链剖分HPD学习笔记]]></title>
    <url>%2F2018%2F11%2F17%2FBEF%204%2F</url>
    <content type="text"><![CDATA[树链剖分 树链剖分 就是对一棵树分成几条链，把树形变为线性，减少处理难度需要处理的问题： 将树从x到y结点最短路径上所有节点的值都加上z 求树从x到y结点最短路径上所有节点的值之和 将以x为根节点的子树内所有节点值都加上z 求以x为根节点的子树内所有节点值之和 概念 重儿子：对于每一个非叶子节点，它的儿子中 以那个儿子为根的子树节点数最大的儿子 为该节点的重儿子 (Ps: 感谢@shzr大佬指出我此句话的表达不严谨qwq, 已修改) 轻儿子：对于每一个非叶子节点，它的儿子中 非重儿子 的剩下所有儿子即为轻儿子 叶子节点没有重儿子也没有轻儿子（因为它没有儿子。。） 重边：连接任意两个重儿子的边叫做重边 轻边：剩下的即为轻边 重链：相邻重边连起来的 连接一条重儿子 的链叫重链对于叶子节点，若其为轻儿子，则有一条以自己为起点的长度为1的链每一条重链以轻儿子为起点 dfs1() 这个dfs要处理几件事情： 标记每个点的深度dep[] 标记每个点的父亲fa[] 标记每个非叶子节点的子树大小(含它自己) 标记每个非叶子节点的重儿子编号son[] 12345678910111213inline void dfs1(int x,int f,int deep)&#123;//x当前节点，f父亲，deep深度 dep[x]=deep;//标记每个点的深度 fa[x]=f;//标记每个点的父亲 siz[x]=1;//标记每个非叶子节点的子树大小 int maxson=-1;//记录重儿子的儿子数 for(Rint i=beg[x];i;i=nex[i])&#123; int y=to[i]; if(y==f)continue;//若为父亲则continue dfs1(y,x,deep+1);//dfs其儿子 siz[x]+=siz[y];//把它的儿子数加到它身上 if(siz[y]&gt;maxson)son[x]=y,maxson=siz[y];//标记每个非叶子节点的重儿子编号 &#125;&#125;//变量解释见最下面 dfs2() 这个dfs2也要预处理几件事情 标记每个点的新编号 赋值每个点的初始值到新编号上 处理每个点所在链的顶端 处理每条链 顺序：先处理重儿子再处理轻儿子，理由后面说 123456789101112inline void dfs2(int x,int topf)&#123;//x当前节点，topf当前链的最顶端的节点 id[x]=++cnt;//标记每个点的新编号 wt[cnt]=w[x];//把每个点的初始值赋到新编号上来 top[x]=topf;//这个点所在链的顶端 if(!son[x])return;//如果没有儿子则返回 dfs2(son[x],topf);//按先处理重儿子，再处理轻儿子的顺序递归处理 for(Rint i=beg[x];i;i=nex[i])&#123; int y=to[i]; if(y==fa[x]||y==son[x])continue; dfs2(y,y);//对于每一个轻儿子都有一条从它自己开始的链 &#125;&#125;//变量解释见最下面 处理问题 Attention 重要的来了！！！前面说到dfs2的顺序是先处理重儿子再处理轻儿子我们来模拟一下： 因为顺序是先重再轻，所以每一条重链的新编号是连续的 因为是dfs，所以每一个子树的新编号也是连续的 现在回顾一下我们要处理的问题 处理任意两点间路径上的点权和 处理一点及其子树的点权和 修改任意两点间路径上的点权 修改一点及其子树的点权 1、当我们要处理任意两点间路径时：设所在链顶端的深度更深的那个点为x点 ans加上x点到x所在链顶端 这一段区间的点权和 把x跳到x所在链顶端的那个点的上面一个点 不停执行这两个步骤，直到两个点处于一条链上，这时再加上此时两个点的区间和即可 这时我们注意到，我们所要处理的所有区间均为连续编号(新编号)，于是想到线段树，用线段树处理连续编号区间和每次查询时间复杂度为 O(log^2n)1234567891011121314151617inline int qRange(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123;//当两个点不在同一条链上 if(dep[top[x]]&lt;dep[top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点 res=0; query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和 ans+=res; ans%=mod;//按题意取模 x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点 &#125; //直到两个点处于一条链上 if(dep[x]&gt;dep[y])swap(x,y);//把x点深度更深的那个点 res=0; query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可 ans+=res; return ans%mod;&#125;//变量解释见最下面 2、处理一点及其子树的点权和：想到记录了每个非叶子节点的子树大小(含它自己)，并且每个子树的新编号都是连续的于是直接线段树区间查询即可时间复杂度为O(logn)O(log⁡n) 12345inline int qSon(int x)&#123; res=0; query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 return res;&#125; 当然，区间修改就和区间查询一样的啦~~ 1234567891011121314inline void updRange(int x,int y,int k)&#123; k%=mod; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); update(1,1,n,id[top[x]],id[x],k); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y])swap(x,y); update(1,1,n,id[x],id[y],k);&#125; inline void updSon(int x,int k)&#123; update(1,1,n,id[x],id[x]+siz[x]-1,k);&#125;//变量解释见最下面 MD: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561. #include &lt;cstdio&gt;2. #include &lt;cstdlib&gt;3. #include &lt;algorithm&gt;4. #include &lt;iostream&gt;5. #define maxn 1000056. #define ll long long7. #define ls(x) ((x)&lt;&lt;1)8. #define rs(x) ((x)&lt;&lt;1|1)9. #define pushup(x) tree[(x)] = tree[ls((x))] + tree[rs((x))]10. ll dep[maxn] , f[maxn] , sz[maxn] , n , head[maxn] , idx[maxn] , val[maxn] , hs[maxn] , m , r , p , cnt , tot , v[maxn] , top[maxn] , tree[maxn&lt;&lt;2] , tag[maxn&lt;&lt;2];11. struct edge&#123;12. ll next , to;13. &#125;e[maxn*2];14. void dfs1(ll x , ll fx);//f[],sz[],dep[],hs[]15. void dfs2(ll x , ll topV);16. inline void add(ll x , ll y);17. ll query(ll L , ll R , ll l , ll r , ll node);18. void update(ll L , ll R , ll l , ll r , ll node , ll val);19. inline void pushdown(ll node , ll ln , ll rn);20. ll qLink(ll x , ll y);// problem request21. void updLink(ll x ,ll y , ll v);//preblem request22. ll qST(ll x);//preblem request23. void updST(ll x , ll v);//preblem request24. void build(ll l , ll r , ll node);25. int main()26. &#123;27. scanf("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;r,&amp;p);28. ll x , y , d;29. for(int i = 1 ; i &lt;= n ; ++i)30. scanf("%lld",&amp;val[i]);31. for(int i = 1 ; i &lt;= n-1 ; ++i)32. &#123;33. scanf("%lld%lld",&amp;x,&amp;y);34. add(x,y) , add(y,x);35. &#125;36. // puts("OK");37. dfs1(r,r);38. // puts("OK");39. dfs2(r,r);//root link topv is itself40. // puts("OK");41. build(1,n,1);42. // puts("OK");43. ll op , xx , yy , zz;44. for(int i = 1 ; i &lt;= m ; ++i)45. &#123;46. scanf("%lld",&amp;op);47. if(op == 1) scanf("%lld%lld%lld",&amp;xx,&amp;yy,&amp;zz) , updLink(xx,yy,zz);48. else if(op == 2) scanf("%lld%lld",&amp;xx,&amp;yy) , printf("%lld\n",qLink(xx,yy));49. else if(op == 3) scanf("%lld%lld",&amp;xx,&amp;zz) , updST(xx,zz);50. else scanf("%lld",&amp;xx) , printf("%lld\n",qST(xx));51. &#125;52. &#125;53. inline void add(ll x , ll y)54. &#123;55. e[++cnt].next = head[x];56. e[cnt].to = y;57. head[x] = cnt;58. &#125;59. ll qLink(ll x , ll y)60. &#123;61. ll ans = 0;62. while(top[x] != top[y])63. &#123;64. if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y);65. ans += query(idx[top[x]] , idx[x] , 1 , n , 1) % p , ans %= p;66. x = f[top[x]];67. &#125;68. if(dep[x] &lt; dep[y]) std::swap(x,y);69. ans += query(idx[y],idx[x],1,n,1);70. return ans % p;71. &#125;72. void updLink(ll x , ll y , ll v)73. &#123;74. while(top[x] != top[y])75. &#123;76. if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y);77. update(idx[top[x]] , idx[x] , 1 , n , 1 , v);78. x = f[top[x]];79. &#125;80. if(dep[x] &gt; dep[y]) std::swap(x,y);81. update(idx[x] , idx[y] , 1 , n , 1 , v);82. &#125;83. ll qST(ll x)84. &#123;85. ll ans = query(idx[x] , idx[x] + sz[x] - 1 , 1 , n , 1) % p;86. return ans;87. &#125;88. void updST(ll x , ll v)89. &#123;90. update(idx[x] , idx[x] + sz[x] - 1 , 1 , n , 1 , v);91. &#125;92. void dfs1(ll x , ll fx)93. &#123;94. f[x] = fx;95. dep[x] = dep[fx] + 1;96. sz[x] = 1;97. ll maxx = -1 ;98. for(ll i = head[x] ; i ; i = e[i].next)99. if(e[i].to != fx)100. dfs1(e[i].to,x) , sz[x] += sz[e[i].to];//dfs1(e[i].to,x) not dfs1(e[i].to,fx)!!!!!!!!!!!!!!101. for(int i = head[x] ; i ; i = e[i].next)102. if(sz[e[i].to] &gt; maxx &amp;&amp; e[i].to != fx)103. maxx = sz[e[i].to] , hs[x] = e[i].to;104. &#125;105. void dfs2(ll x , ll topV)106. &#123;107. idx[x] = ++tot;108. v[idx[x]] = val[x];109. top[x] = topV;110. if(!hs[x]) return;111. dfs2(hs[x],topV);112. for(int i = head[x] ; i ; i = e[i].next)113. if(e[i].to != f[x] &amp;&amp; e[i].to != hs[x])114. dfs2(e[i].to , e[i].to);115. &#125;116. inline void pushdown(ll node , ll ln , ll rn)117. &#123;118. if(tag[node])119. &#123;120. tag[ls(node)] += tag[node] % p , tag[rs(node)] += tag[node] % p;121. tree[ls(node)] += tag[node] * ln % p, tree[rs(node)] += tag[node] * rn % p;122. tree[ls(node)] %= p , tree[rs(node)] %= p;123. tag[node] = 0;124. &#125;125. &#125;126. void build(ll l , ll r , ll node)127. &#123;128. if(l == r) &#123;tree[node] = v[l];return;&#125;129. ll m = l + r &gt;&gt; 1;130. build(l , m , ls(node));131. build(m + 1 , r , rs(node));132. pushup(node);133. &#125;134. ll query(ll L , ll R , ll l , ll r , ll node)135. &#123;136. if(L &lt;= l &amp;&amp; r &lt;= R) return tree[node];137. ll m = l + r &gt;&gt; 1 , ans = 0;138. pushdown(node , m - l + 1 , r - m);139. if(L &lt;= m) ans += query(L , R , l , m , ls(node)) % p , ans %= p;140. if(R &gt; m) ans += query(L , R , m + 1 , r , rs(node)) % p , ans %= p;141. return ans;142. &#125;143. void update(ll L , ll R , ll l , ll r , ll node , ll v)144. &#123;145. if(L &lt;= l &amp;&amp; r &lt;= R)146. &#123;147. tree[node] += (r - l + 1) * v % p , tree[node] %= p;148. tag[node] += v;149. return ;150. &#125;151. ll m = l + r &gt;&gt; 1;152. pushdown(node , m - l + 1 , r - m);153. if(L &lt;= m) update(L , R , l , m , ls(node) , v);154. if(R &gt; m) update(L , R , m + 1 , r , rs(node) , v);155. pushup(node);156. &#125; 简单叙述原理以及对时间复杂度的论述: 原理就是将树划分成重链轻链，然后通过适当的编号将重链接成序列用线段树维护，而由重儿子和轻儿子的定义可知，对于节点u的轻儿子v， sz[v]=size(vi)(i>1) size(vi)+size(vi)=2∗size(vi)vk−>vroot−>...−>v1−>...−>v2−>...−>vk−>...−>v(其中 −>v1,−>v2,...,−>vk−>v1,−>v2,...,−>vk为轻边) size(vk)>=size(v)>=1 size(vk的前趋)>=2∗size(vk)(性质1)>=2同理可得： size(vk−1的前趋)>=2∗size(vk的前趋)>=22size(vk−1的前趋)>=2∗size(vk的前趋)>=2^2所以有： n=size(root)>=size(v1的前趋)>=2kn=size(root)>=size(v1的前趋)>=2^k所以 k=O(logn)从root到v的路径中有k条轻边，那么路径上其他边即为重边，那么重链数=k+1，所以重链数=O(logn)。 从上面的阐述中我们也可以理解到为什么树链剖分的常数那么小，因为很显然每一步放缩都是在2个节点并且是在轻重儿子最接近的情况下得出的结论。 我们看一道树剖的基础题 [HAOI2015]树上操作题目描述有一棵点数为 N 的树，以点 1 为根，且树点有点权。然后有 M 个操作，分为三种：操作 1 ：把某个节点 x 的点权增加 a 。操作 2 ：把某个节点 x 为根的子树中所有点的点权都增加 a 。操作 3 ：询问某个节点 x 到根的路径中所有点的点权和。 输入输出格式输入格式： 第一行包含两个整数 N, M 。表示点数和操作数。接下来一行 N 个整数，表示树中节点的初始权值。接下来 N-1 行每行两个正整数 from, to ， 表示该树中存在一条边 (from, to) 。再接下来 M 行，每行分别表示一次操作。其中第一个数表示该操作的种类（ 1-3 ） ，之后接这个操作的参数（ x 或者 x a ） 。 输出格式： 对于每个询问操作，输出该询问的答案。答案之间用换行隔开。 输入输出样例输入样例#1： 12345678910115 51 2 3 4 51 21 42 32 53 31 2 13 52 1 23 3 输出样例#1： 1236913 说明对于 100% 的数据， N,M&lt;=100000 ，且所有输入数据的绝对值都不 会超过 10^6 。 显然只需要树剖部分功能，并且操作一只需要在线段树上单点修改即可（仅仅是常数优化）。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ls(x) ((x)&lt;&lt;1)#define rs(x) ((x)&lt;&lt;1|1)#define pushup(x) tree[(x)] = tree[ls((x))] + tree[rs((x))]#define maxn 100005#define ll long longll n , m , head[maxn] , f[maxn] , cnt , id , idx[maxn] , dep[maxn] , hs[maxn] , sz[maxn] , top[maxn] , val[maxn] , v[maxn] , tree[maxn&lt;&lt;2] , tag[maxn&lt;&lt;2] ;struct edge&#123; ll next , to;&#125;e[maxn * 2];inline void add(ll x , ll y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;void dfs1(ll x , ll fx)&#123; f[x] = fx; sz[x] = 1; dep[x] = dep[fx] + 1; ll maxx = -1; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) dfs1(e[i].to , x) , sz[x] += sz[e[i].to]; for(int i = head[x] ; i ; i = e[i].next) if(sz[e[i].to] &gt; maxx &amp;&amp; e[i].to != fx)//attention : e[i].to != fx maxx = sz[e[i].to] , hs[x] = e[i].to;&#125;void dfs2(ll x , ll topv)&#123; idx[x] = ++id; // printf("id = %d\n",idx[x]); top[x] = topv ; v[idx[x]] = val[x]; if(!hs[x]) return; dfs2(hs[x],topv); for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != hs[x] &amp;&amp; e[i].to != f[x]) dfs2(e[i].to , e[i].to);&#125;inline void pushdown(ll node , ll ln , ll rn)&#123; if(tag[node]) &#123; tag[ls(node)] += tag[node] , tag[rs(node)] += tag[node]; tree[ls(node)] += tag[node] * ln , tree[rs(node)] += tag[node] * rn; tag[node] = 0; &#125;&#125;void build(ll l , ll r , ll node)&#123; if(l == r) &#123;tree[node] = v[l];return;&#125; ll m = l + r &gt;&gt; 1; build(l , m , ls(node)); build(m + 1 , r , rs(node)); pushup(node);&#125;ll query(ll L , ll R , ll l , ll r , ll node)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) return tree[node]; ll m = l + r &gt;&gt; 1 , ans = 0; pushdown(node , m - l + 1 , r - m); if(L &lt;= m) ans += query(L , R , l , m , ls(node)) ; if(R &gt; m) ans += query(L , R , m + 1 , r , rs(node)); return ans;&#125;void update(ll L , ll R , ll l , ll r , ll node , ll v)&#123; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; tree[node] += (r - l + 1) * v; tag[node] += v; return ; &#125; ll m = l + r &gt;&gt; 1; pushdown(node , m - l + 1 , r - m); if(L &lt;= m) update(L , R , l , m , ls(node) , v); if(R &gt; m) update(L , R , m + 1 , r , rs(node) , v); pushup(node);&#125;ll qLink(ll x , ll y)&#123; ll ans = 0; while(top[x] != top[y]) &#123; if(dep[top[x]] &lt; dep[top[y]]) std::swap(x,y); ans += query(idx[top[x]] , idx[x] , 1 , n , 1) ; x = f[top[x]]; &#125; if(dep[x] &lt; dep[y]) std::swap(x,y); ans += query(idx[y],idx[x],1,n,1); return ans;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m); for(int i = 1; i &lt;= n; ++i) scanf("%lld",&amp;val[i]); ll x , y , d; for(int i = 1 ; i &lt;= n-1; ++i) scanf("%lld%lld",&amp;x,&amp;y) , add(x,y) , add(y,x); dfs1(1,1); // puts("ok"); dfs2(1,1); // puts("ok"); build(1,n,1); // puts("ok"); for(int i = 1 ; i &lt;= m ; ++i) &#123; int op; scanf("%d",&amp;op); if(op == 1) &#123; scanf("%lld%lld",&amp;x,&amp;d); update(idx[x],idx[x],1,n,1,d); &#125; else if(op == 2) &#123; scanf("%lld%lld",&amp;x,&amp;d); update(idx[x] , idx[x] + sz[x] - 1 , 1 , n , 1 , d); &#125; else&#123; scanf("%lld",&amp;x); printf("%lld\n",qLink(1,x)); &#125; &#125;&#125; 上午模拟赛我最后40分钟去还水了100分（雾 貌似300分的题随便拿280 ， 然而剩下20分是什么仙人掌倍增？？ 我们来看看T2与T3 样例输入 15 4 21 2 11 3 12 4 12 5 13 52 1 样例输出 131 样例输入 25 5 21 2 1 2 1 11 3 12 4 12 5 13 52 1 样例输出 231 样例输入 39 10 21 2 11 4 13 4 12 3 13 7 17 8 27 9 21 5 31 6 45 6 11 95 7 样例输出 356 作为一道0.1秒时限的题，显然中间的80分比较好拿。 算法一：用 SPFA 对每个点求一次单源最短路，由于是稀疏图，所以一次 SPFA 的复杂度O(M)。然后 O(1)回答询问。时间复杂度： O(NM)期望得分：10 分。 算法二：树上倍增法求 LCA。这个是经典必备算法，不再赘述。于是再算一下根到每个点的距离，于是就是 dis[x]+dis[y]-2*dis[LCA(x,y)]。啥？这个算法你不知道= =？如果想进省队的话，你赶紧去学吧&gt;_&lt;时间复杂度： O((N+Q)logN)期望得分：40 分。 算法三：内向树上倍增法求 LCA 并计算路径长度。先写个 DFS 找出来环，然后随便找环上一个点 P，顺时针遍历一遍环，求出环上各个点逆时针走到它的距离。还可以顺便求出环长 len。按照算法二的思路，倍增到环上之后，无非就有两种走法：继续走到 LCA、走环上另一边的路径。前者 dfs 找环遍历时求过的，两个点逆时针到 P 的距离之差的绝对值，记为 dis，后者就是 len-dis，这两个取 min 就好了。时间复杂度： O((N+Q)logN)；期望得分：80 分。 *算法四：SPFA+仙人掌上倍增法求 LCA。先 DFS 找环，顺便求环长神马的，这个跟算法三一样。然后找个根节点，跑一遍 SPFA 求单源最短路。。。在得到的单源最短路树上构建倍增数组。。。于是剩下的就跟算法三一样了……倍增时走到最后，如果到了环上类似处理就好了。时间复杂度：O((N+Q)logN)；期望得分：100 分。另外，算法四是去年国家集训队 2011 作业，杨天的题，有详细证明和题解，Bzoj 上也有。前面三个算法都是弱化版，因为作为 noip 题，算法四仅占 10%的分数。]]></content>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef->NO.13]]></title>
    <url>%2F2018%2F10%2F13%2FNO.-13%2F</url>
    <content type="text"><![CDATA[[NOI2012]随机数生成器题目描述栋栋最近迷上了随机算法，而随机数是生成随机算法的基础。栋栋准备使用线性同余法（Linear Congruential Method）来生成一个随机数列，这种方法需要设置四个非负整数参数m,a,c,X[0],按照下面的公式生成出一系列随机数{Xn}： 1X[n+1]=(aX[n]+c) mod m 其中mod m表示前面的数除以m的余数。从这个式子可以看出，这个序列的下一个数总是由上一个数生成的。 用这种方法生成的序列具有随机序列的性质，因此这种方法被广泛地使用，包括常用的C++和Pascal的产生随机数的库函数使用的也是这种方法。 栋栋知道这样产生的序列具有良好的随机性，不过心急的他仍然想尽快知道X[n]是多少。由于栋栋需要的随机数是0,1,…,g-1之间的，他需要将X[n]除以g取余得到他想要的数，即X[n] mod g，你只需要告诉栋栋他想要的数X[n] mod g是多少就可以了。 输入输出格式输入格式： 输入包含6个用空格分割的整数m,a,c,X[0],n和g，其中a,c,X[0]是非负整数，m,n,g是正整数。 输出格式： 输出一个数，即X[n] mod g 输入输出样例输入样例#1： 111 8 7 1 5 3 输出样例#1： 12 说明计算得X[n]=X[5]=8,故 (X[n] mod g) = (8 mod 3) = 2100%的数据中 n,m,a,c,X[0]]]></content>
      <tags>
        <tag>数学 基环树dp 矩阵乘法，邻接矩阵 图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NationalDay3]]></title>
    <url>%2F2018%2F10%2F10%2F2018.10.10%2F</url>
    <content type="text"><![CDATA[关于WQS二分 ， 是用来解决这样一类问题 强制选k个某属性的物品，要求最优方案。 [国家集训队2]Tree I题目描述给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。 题目保证有解。 输入输出格式输入格式： 第一行V,E,need分别表示点数，边数和需要的白色边数。 接下来E行 每行s,t,c,col表示这边的端点(点从0开始标号)，边权，颜色(0白色1黑色)。 输出格式： 一行表示所求生成树的边权和。 输入输出样例输入样例#1： 1232 2 10 1 1 10 1 2 0 输出样例#1： 12 说明0:V&lt;=10 1,2,3:V&lt;=15 0,..,19:V&lt;=50000,E&lt;=100000 所有数据边权为[1,100]中的正整数。 By WJMZBMR 题解这道题是WQS二分的经典题目 我们二分白边边权增量，对于每次二分后排序做Kruskal最小生成树。边权相同优先让白边靠前。 这样显然减少增量白边会多，增加增量白边会少。 我这样写后交上去并不对，代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#define maxn 50500int cnt , x , y , d , n , m , c , need , f[maxn] , tot , Wcol , mst , ans;struct E&#123; int from , to , dis , col;&#125;q[maxn * 4] , p[maxn * 4];int find(int x)&#123; if(f[x] != x) return f[x] = find(f[x]); return f[x];&#125;inline bool cmp(E x , E y)&#123; if(x.dis == y.dis) return x.col &lt; y.col; return x.dis &lt; y.dis;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;need); for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d%d%d",&amp;q[i].from , &amp;q[i].to , &amp;q[i].dis , &amp;q[i].col) , ++ q[i].from , ++ q[i].to; int l = -150 , r = 150; while(l &lt;= r) &#123; // printf("l = %d r = %d\n", l , r); int mid = l + r &gt;&gt; 1;//the addition cnt = 0 , tot = 0 , Wcol = 0 , mst = 0; for(int i = 1 ; i &lt;= n ; ++i) f[i] = i; for(int i = 1 ; i &lt;= m ; ++i) p[i] = q[i]; for(int i = 1 ; i &lt;= m ; ++i) if(!p[i].col) p[i].dis += mid; std::sort(p+1,p+m+1,cmp); for(int i = 1 ; i &lt;= m &amp;&amp; tot &lt; n - 1 ; ++i) &#123; int fx = find(p[i].from) , fy = find(p[i].to); if(fx != fy) &#123; f[fx] = fy; mst += p[i].dis; if(!p[i].col) ++Wcol; ++tot; &#125; &#125; if(Wcol &gt; need) l = mid + 1;// Wcol will decrease else if(Wcol == need) &#123;ans = mst - need * mid ; l = mid + 1;&#125; else r = mid - 1; // Wcol will be larger // putchar(10); &#125; printf("%d\n",ans);&#125; 但是这会有一个问题，白边优先意味着当前状况可能尽管白边数大于黑边数，但是完全可以用黑边替换白边。那么我们可以只要当前白边数够大就更新答案。 为什么这个做法是正确的呢？因为我们在白边数大的时候还会给白边更大的增量，假如依然白边数&gt;=指定边数，那么说明原来那种是不能用黑边替换的或者和原来的情况一样或者比原来的情况更优。不管怎么样都能更新答案，只要一直保证白边数不小于黑边，就能确保最后的答案是正好need条白边（由数据保证）。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#define maxn 50500int cnt , x , y , d , n , m , c , need , f[maxn] , tot , Wcol , mst , ans;struct E&#123; int from , to , dis , col;&#125;q[maxn * 4] , p[maxn * 4];int find(int x)&#123; if(f[x] != x) return f[x] = find(f[x]); return f[x];&#125;inline bool cmp(E x , E y)&#123; if(x.dis == y.dis) return x.col &lt; y.col; return x.dis &lt; y.dis;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;need); for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d%d%d",&amp;q[i].from , &amp;q[i].to , &amp;q[i].dis , &amp;q[i].col) , ++ q[i].from , ++ q[i].to; int l = -150 , r = 150; while(l &lt;= r) &#123; int mid = l + r &gt;&gt; 1;//the addition cnt = 0 , tot = 0 , Wcol = 0 , mst = 0; for(int i = 1 ; i &lt;= n ; ++i) f[i] = i; for(int i = 1 ; i &lt;= m ; ++i) p[i] = q[i]; for(int i = 1 ; i &lt;= m ; ++i) if(!p[i].col) p[i].dis += mid; std::sort(p+1,p+m+1,cmp); for(int i = 1 ; i &lt;= m &amp;&amp; tot &lt; n - 1 ; ++i) &#123; int fx = find(p[i].from) , fy = find(p[i].to); if(fx != fy) &#123; f[fx] = fy; mst += p[i].dis; if(!p[i].col) ++Wcol; ++tot; &#125; &#125; if(Wcol &gt;= need) ans = mst - need * mid , l = mid + 1; else r = mid - 1; // Wcol will be larger // putchar(10); &#125; printf("%d\n",ans);&#125; [SHOI2014]概率充电器题目描述著名的电子产品品牌SHOI 刚刚发布了引领世界潮流的下一代电子产品—— 概率充电器： “采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决 定！SHOI 概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看 吧！” SHOI 概率充电器由n-1 条导线连通了n 个充电元件。进行充电时，每条导 线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率 决定。随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行 间接充电。 作为SHOI 公司的忠实客户，你无法抑制自己购买SHOI 产品的冲动。在排 了一个星期的长队之后终于入手了最新型号的SHOI 概率充电器。你迫不及待 地将SHOI 概率充电器插入电源——这时你突然想知道，进入充电状态的元件 个数的期望是多少呢？ 输入输出格式输入格式： 第一行一个整数：n。概率充电器的充电元件个数。充电元件由1-n 编号。 之后的n-1 行每行三个整数a, b, p，描述了一根导线连接了编号为a 和b 的 充电元件，通电概率为p%。 第n+2 行n 个整数：qi。表示i 号元件直接充电的概率为qi%。 输出格式： 输出一行一个实数，为能进入充电状态的元件个数的期望，四舍五入到小 数点后6 位小数。 输入输出样例输入样例#1： 123431 2 501 3 5050 0 0 输出样例#1： 11.000000 输入样例#2： 12345651 2 901 3 801 4 701 5 60100 10 20 30 40 输出样例#2： 14.300000 说明对于30%的数据，n≤5000。 对于100%的数据，n≤500000，0≤p,qi≤100。 题解这道题是道不错的概率DP入门题 显然对于每个点，我们要考虑它自己亮的概率，被它父亲点亮的概率，被他孩子点亮的概率. 为了高效率，显然我们可以进行树形DP 显然这个题概率不好正着推，WZX大佬说这题随便正着推，真是太强啦！ 我们设 f(x) , g(x)表示x不被子树节点点亮的概率，不被子树外点亮的概率。 f(x)比较好推 f(x) = (1 - p[x])\prod_{s}1-f(s)w(s)其中 w(s)表示子节点连向父亲的导线通电的概率。 对于 g(x)转移,我想了好久，其实十分的简单。 我们先求出父亲不被外部点亮的概率 g(root) = 1 T = f(x) * g(x) / (f(s) + (1-f(s))(1-w(s)))这就是一个点最终对于孩子节点没有电的概率。 因此 g(s) = T + (1 - T) * (1 - w(s))类似刷表法的down过程就结束了 这就是树形dp的 up and down Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 500005int n , head[maxn] , cnt , fa[maxn];double f[maxn] , v[maxn] , g[maxn];struct edge&#123; int next , to ; double dis;&#125;e[maxn * 2];inline void add(int x , int y , double d)&#123; e[++cnt].next = head[x] ; e[cnt].to = y ; e[cnt].dis = d; head[x] = cnt;&#125;void up(int x , int fx)&#123; f[x] = 1 - v[x]; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) up(e[i].to , x) , f[x] *= f[e[i].to] + (1 - f[e[i].to]) * (1 - e[i].dis);&#125;void down(int x , int fx)&#123; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) &#123; double DarkX = g[x] * f[x] / (f[e[i].to] + (1 - f[e[i].to]) * (1 - e[i].dis)); g[e[i].to] = DarkX + (1 - DarkX) * (1 - e[i].dis); down(e[i].to , x); &#125;&#125;int main()&#123; scanf("%d",&amp;n); int x , y ; double d; for(int i = 1 ; i &lt;= n - 1; ++i) scanf("%d%d%lf",&amp;x,&amp;y,&amp;d) , add(x,y,d/100) , add(y,x,d/100); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lf",&amp;v[i]) , v[i] /= 100; up(1 , 1); g[1] = 1;//the down(1 , 1); double ans = 0; for(int i = 1 ; i &lt;= n ; ++i) ans += 1 - f[i] * g[i]; printf("%.6lf",ans);&#125; 多人背包题目描述求01背包前k优解的价值和 输入输出格式输入格式： 第一行三个数K、V、N 接下来每行两个数，表示体积和价值 输出格式： 前k优解的价值和 输入输出样例输入样例#1： 1234562 10 53 127 202 45 61 1 输出样例#1： 157 说明对于100%的数据, K\le 50,V\le 5000,N\le 200K≤50,V≤5000,N≤200题解这是道好题。 对于背包问题，显然每件物品是独立的子问题。 很容易发现,我们需要记录用其他物品来填充背包是否能得到更优解. 因此我们需要记录一个变量c1表示体积为j的时候的第c1优解能否被更新. 再去记录一个变量c2表示体积为j-v[i]的时候的第c2优解. 更新到k就可以的（雾 Code: 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 205#define maxk 55#define maxm 5005int f[maxm][maxk] , n , m , k , ans , w[maxn] , v[maxn] , now[maxn];int main()&#123; scanf("%d%d%d",&amp;k,&amp;m,&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d%d",&amp;w[i],&amp;v[i]); std::memset(f,-70,sizeof(f)); f[0][1] = 0; for(int i = 1 ; i &lt;= n ; ++i) for(int j = m ; j &gt;= w[i] ; --j) &#123; std::memset(now,0,sizeof(now)); int c1 = 1 , c2 = 1 , cnt = 0; while(cnt &lt;= k) &#123; if(f[j - w[i]][c1] + v[i] &gt; f[j][c2]) now[++cnt] = f[j - w[i]][c1] + v[i] , ++c1; else now[++cnt] = f[j][c2] , ++c2; &#125; for(int c = 1 ; c &lt;= k ; ++c) f[j][c] = now[c]; &#125; for(int i = 1 ; i &lt;= k ; ++i) ans += f[m][i]; printf("%d",ans);&#125; [SCOI2003]严格N元树递推的好题 题目描述如果一棵树的所有非叶节点都恰好有n个儿子，那么我们称它为严格n元树。如果该树中最底层的节点深度为d（根的深度为0），那么我们称它为一棵深度为d的严格n元树。例如，深度为２的严格２元树有三个，如下图： 给出n, d，编程数出深度为d的n元树数目。 输入输出格式输入格式： 仅包含两个整数n, d(0&lt;n&lt;=32, 0&lt;=d&lt;=16)。输入数据保证你不需要考虑某一层多于1024个节点的树（即nd&lt;=1024）。提示：答案保证不超过200位十进制数。 输出格式： 仅包含一个数，即深度为d的n元树的数目。 输入输出样例输入样例#1： 12 2 输出样例#1： 13 输入样例#2： 12 3 输出样例#2： 121 输入样例#3： 13 5 输出样例#3： 158871587162270592645034001 题解这个题有巧妙地构造递推方式，也有相当理性的组合数学方法，主要考虑巧妙地构造方式。 很好想的想到深度不超过d的数量设为 f(d), 最后答案是 f(d) - f(d-1)然后很好想到每次深度多一我们只需要在最上面加一个根，那么根上还得有(n-1)颗子树。因此 f(d) = f(d-1) ^ n + 1于是很简单地就AC了 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 55000using namespace std;struct bign&#123; int d[maxn], len; void clean() &#123; while(len &gt; 1 &amp;&amp; !d[len-1]) len--; &#125; bign() &#123; memset(d, 0, sizeof(d)); len = 1; &#125; bign(int num) &#123; *this = num; &#125; bign(char* num) &#123; *this = num; &#125; bign operator = (const char* num)&#123; memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - '0'; clean(); return *this; &#125; bign operator = (int num)&#123; char s[2000]; sprintf(s, "%d", num); *this = s; return *this; &#125; bign operator + (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; &#125; while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; &#125; bign operator - (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; &#125; while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; &#125; bign operator * (const bign&amp; b)const&#123; int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; &#125; bign operator / (const bign&amp; b)&#123; int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; &#125; c.clean(); return c; &#125; bign operator % (const bign&amp; b)&#123; int i, j; bign a = 0; for (i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; &#125; return a; &#125; bign operator += (const bign&amp; b)&#123; *this = *this + b; return *this; &#125; bool operator &lt;(const bign&amp; b) const&#123; if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; &#125; bool operator &gt;(const bign&amp; b) const&#123;return b &lt; *this;&#125; bool operator&lt;=(const bign&amp; b) const&#123;return !(b &lt; *this);&#125; bool operator&gt;=(const bign&amp; b) const&#123;return !(*this &lt; b);&#125; bool operator!=(const bign&amp; b) const&#123;return b &lt; *this || *this &lt; b;&#125; bool operator==(const bign&amp; b) const&#123;return !(b &lt; *this) &amp;&amp; !(b &gt; *this);&#125; string str() const&#123; char s[maxn]=&#123;&#125;; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+'0'; return s; &#125;&#125;;istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x)&#123; string s; in &gt;&gt; s; x = s.c_str(); return in;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x)&#123; out &lt;&lt; x.str(); return out;&#125;bign f[20] , g;int n , d;int main()&#123; scanf("%d%d",&amp;n,&amp;d); f[0] = 1; for(int i = 1 ; i &lt;= d ; ++i) &#123; bign g = 1; for(int j = 1 ; j &lt;= n ; ++j) g = g * f[i-1]; // std::cout &lt;&lt; g &lt;&lt; endl; f[i] = g + 1; &#125; std::cout&lt;&lt;f[d] - f[d-1];&#125;]]></content>
      <tags>
        <tag>WQS带权二分 递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NationalDay1]]></title>
    <url>%2F2018%2F10%2F05%2FBEF1%2F</url>
    <content type="text"><![CDATA[今天ATP学姐来讲课啦。 在记录讲课内容及题解前先看道以前做过的DP [HAOI2009]逆序对数列题目描述对于一个数列{ai}，如果有iaj，那么我们称ai与aj为一对逆序对数。若对于任意一个由1~n自然数组成的数列，可以很容易求出有多少个逆序对数。那么逆序对数为k的这样自然数数列到底有多少个？ 输入输出格式输入格式： 第一行为两个整数n，k。 输出格式： 写入一个整数，表示符合条件的数列个数，由于这个数可能很大，你只需输出该数对10000求余数后的结果。 输入输出样例输入样例#1： 14 1 输出样例#1： 13 说明样例说明： 下列3个数列逆序对数都为1；分别是1 2 4 3 ；1 3 2 4 ；2 1 3 4； 测试数据范围 30%的数据 n&lt;=12 100%的数据 n&lt;=1000，k&lt;=1000 题解现在已经不难想到状态 ， 设 f(i,j)表示前i个数产生j个逆序对数的方案数。 由于下一个数一定更大，所以转移就是： f(i+1,j) = \sum_{k=0}^{j}f(i-1,j-k)这个式子还是有点问题的，因为当前加的这个数最多产生i对逆序对数，因此加的时候要减掉(j-i)的逆序对数的方案。 也就是这样 f(i+1,j) = \sum_{k=0}^{min(j,i-1)}f(i-1,k)程序实现这个递推有点技巧，下面是Code 1234567891011121314151617181920212223242526// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#define maxn 3005#define mod 10000long long n , k , f[maxn][maxn*2];int main()&#123; scanf("%lld%lld",&amp;n,&amp;k); for(int i = 1 ;i &lt;= n ; i++) f[i][0] = 1; for(int i = 2 ; i &lt;= n ; i++) &#123; long long sum = 0; for(int j = 0 ; j &lt;= k ; j++) &#123; sum += f[i-1][j]%mod , sum %= mod; f[i][j] = sum%mod; if(j-i+1 &gt;= 0)((sum-=f[i-1][j-i+1])+=mod)%mod; &#125; &#125; printf("%lld\n", f[n][k]%mod);&#125; 接下来是几道矩阵快速幂的递推题 HDU 2604 •题目大意：给定一个数字L，求有多少个长度为L且仅有字母m和f的字符串满足串中不出现子串fmf和fff。答案对一个数字M取模 •多组数据，L不超过10^6 其实HDU原题是2^l…. 突然发现HDU TM说的就是L… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define ll long longint l , mod;struct Matrix&#123; int mat[10][10] , n , m; Matrix()&#123; n = 9 , m = 9; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) mat[i][j] = 0; &#125;&#125;F0 , F;Matrix operator*(const Matrix&amp; x , const Matrix&amp; y)&#123; Matrix ans; if(x.m != y.n) return ans; ans.n = x.n , ans.m = y.m; for(int i = 1 ; i &lt;= ans.n ; ++i) for(int j = 1 ; j &lt;= ans.m ; ++j) for(int k = 1 ; k &lt;= x.m ; ++k)&#123; ans.mat[i][j] += x.mat[i][k] * y.mat[k][j] , ans.mat[i][j] %= mod; ans.mat[i][j] %= mod; &#125; return ans;&#125;Matrix pow(const Matrix&amp; x , ll y)&#123; Matrix ans , base; ans.n = ans.m = base.n = base.m = x.n; for(int i = 1 ; i &lt;= x.n ; ++i) ans.mat[i][i] = 1; base = x; while(y) &#123; if(y&amp;1) ans = ans * base; base = base * base; y /= 2; &#125; return ans;&#125;int main()&#123; // freopen("data.in","r",stdin); // freopen("my.out","w",stdout); F0.n = 1 , F0.m = 4; F0.mat[1][1] = 9 , F0.mat[1][2] = 6 , F0.mat[1][3] = 4 , F0.mat[1][4] = 1; F.n = F.m = 4; F.mat[1][1] = F.mat[3][1] = F.mat[4][1] = F.mat[1][2] = F.mat[2][3] = F.mat[3][4] = 1; while(scanf("%d%d",&amp;l,&amp;mod) != EOF) &#123; if(l == 0) &#123;printf("0\n") ; continue;&#125; if(l &lt;= 4) &#123; printf("%d\n",F0.mat[1][4-l+1]%mod); continue; &#125; Matrix ans = F0 * pow(F,l-4); printf("%d\n",ans.mat[1][1]%mod); &#125;&#125;]]></content>
      <tags>
        <tag>dp 矩阵 递推</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F13%2FNO.-6%2F</url>
    <content type="text"><![CDATA[「一本通 5.5 例 4」旅行问题题目描述原题来自：POI 2004 John 打算驾驶一辆汽车周游一个环形公路。公路上总共有 nnn 车站，每站都有若干升汽油（有的站可能油量为零），每升油可以让汽车行驶一千米。John 必须从某个车站出发，一直按顺时针（或逆时针）方向走遍所有的车站，并回到起点。在一开始的时候，汽车内油量为零，John 每到一个车站就把该站所有的油都带上（起点站亦是如此），行驶过程中不能出现没有油的情况。 任务：判断以每个车站为起点能否按条件成功周游一周。 输入格式第一行是一个整数 nnn，表示环形公路上的车站数； 接下来 n 行，每行两个整数，分别表示表示第 iii 号车站的存油量和第 iii 号车站到下一站的距离。 输出格式输出共 nnn 行，如果从第 iii 号车站出发，一直按顺时针（或逆时针）方向行驶，能够成功周游一圈，则在第 iii 行输出 TAK，否则输出 NIE。 样例样例输入12345653 11 25 20 15 4 样例输出12345TAKNIETAKNIETAK 数据范围与提示 p_i,d_i对于全部数据， 1\le n\le 10^6,0\le p_i\le 2\times 10^9,0\lt d_i\le 2\times 10^9题解一道单调队列的思维题。 注意题目中说的，必须任意时刻有油，又考虑到从起点到当前点会有剩下的油（如果剩负的不合法），显然可以想到前缀和，对于每个点和路长之差的前缀和（即剩余油量）。 然后破环为链 这样我们只需要在倍长的链上做区间RMQ即可（即判断链上一个长度为n的区间是否某一时刻前缀值小于区间左端点减一的前缀值，那意味着中途没油了） 再反着跑，请注意细节，由此导致第一次提交因为下标问题而得了0分。 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 1000005long long s[maxn*2] , p[maxn] , d[maxn] , n;bool f[maxn] , g[maxn] , tmp[maxn];std::deque&lt;int&gt; q;int main()&#123; scanf("%lld",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld%lld",&amp;p[i],&amp;d[i]); for(int i = 1 ; i &lt;= n ; ++i) s[i] = p[i] - d[i] + s[i-1]; for(int i = n + 1 ; i &lt;= n * 2 ; ++i) s[i] = p[i-n] - d[i-n] + s[i-1]; for(int i = 1 ; i &lt;= n ; ++i) &#123; while(!q.empty() &amp;&amp; s[q.back()] &gt; s[i]) q.pop_back(); q.push_back(i); &#125; if(s[q.front()] &gt; 0) f[1] = true; for(int i = n + 1 ; i &lt;= 2 * n - 1 ; ++i)//for each i - n + 1 as a begin &#123; while(!q.empty() &amp;&amp; s[q.back()] &gt; s[i]) q.pop_back(); while(!q.empty() &amp;&amp; q.front() &lt;= i - n) q.pop_front(); q.push_back(i);//i-n+1 ~ i Min value if(s[q.front()] &gt;= s[i - n]) f[i-n+1] = true; &#125; int fn = d[n]; for(int i = n ; i &gt; 1 ; --i) d[i] = d[i-1]; d[1] = fn; std::memset(s,0,sizeof(s)); while(!q.empty()) q.pop_back(); for(int i = 1 ; i &lt;= n ; ++i) s[i] = s[i-1] + (p[n-i+1] - d[n-i+1]); for(int i = n + 1 ; i &lt;= 2 * n - 1; ++i) s[i] = s[i-1] + (p[n-i+1+n] - d[n-i+1+n]); for(int i = 1 ; i &lt;= n ; ++i) &#123; while(!q.empty() &amp;&amp; s[q.back()] &gt;= s[i]) q.pop_back(); q.push_back(i); &#125; if(s[q.front()] &gt; 0) g[n] = true; for(int i = n + 1 ; i &lt;= 2 * n - 1 ; ++i)//for each i - n + 1 as a begin &#123; while(!q.empty() &amp;&amp; s[q.back()] &gt; s[i]) q.pop_back(); while(!q.empty() &amp;&amp; q.front() &lt;= i - n) q.pop_front(); q.push_back(i);//i-n+1 ~ i Min value if(s[q.front()] &gt;= s[i - n]) tmp[i-n] = true; &#125; for(int i = 1 ; i &lt;= n-1 ; ++i) g[n-i] = tmp[i]; for(int i = 1 ; i &lt;= n ; ++i) if(f[i] || g[i]) printf("TAK\n"); else printf("NIE\n");&#125; 「一本通 5.5 例 5」Banknotes题目描述原题来自：POI 2005 Byteotian Bit Bank (BBB) 拥有一套先进的货币系统，这个系统一共有 nnn 种面值的硬币，面值分别为 b1,b2,⋯,bnb_1, b_2,\cdots , b_nb1,b2,⋯,bn。但是每种硬币有数量限制，现在我们想要凑出面值 kkk，求最少要用多少个硬币。 输入格式第一行一个数 nnn； 接下来一行 nnn 个整数 b1,b2,⋯,bnb_1, b_2,\cdots , b_nb1,b2,⋯,bn； 第三行 nnn 个整数 c1,c2,⋯,cnc_1,c_2,\cdots ,c_nc1,c2,⋯,cn，表示每种硬币的个数； 最后一行一个数 kkk，表示要凑的面值数。 输出格式第一行一个数表示最少需要付的硬币数。 样例样例输入123432 3 52 2 110 样例输出13 数据范围与提示对于全部数据， 1\le n\le 200,1\le b_1\lt b_2\lt \cdots \lt b_n\le 2\times 10^4,1\le c_i,k\le 2\times 10^4题解一开始想了个生成函数的做法。。 我们知道，幂形式相乘底数相同的指数相加。 因此我们可以构造一个生成函数让价值在指数幂上，底数是x。。 也即是： f(x) = \prod_{i=1}^{n}\sum_{j=1}^{c_i}x^{b_i*j}然后展开后对于第k项的系数即为组合的方案数 然后发现这是 O(n^3)然后发现读错了题，是求最少的硬币数。 然后就是一个二进制优化的多重背包。。当然也可以单调队列优化一下，不过没必要。 Code： 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define maxn 205#define maxk 20005#define maxlog 15int n , x[maxn] , y[maxn] , f[maxk] , w[maxn*maxlog] , c[maxn*maxlog] , tot , k;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;x[i]); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;y[i]); scanf("%d",&amp;k); std::memset(f,0x7f,sizeof(f)); f[0] = 0; for(int i = 1 ; i &lt;= n ; ++i) &#123; int k = 0; while((1&lt;&lt;k) &lt;= y[i])&#123; y[i] -= (1&lt;&lt;k); w[++tot] = x[i] * (1&lt;&lt;k); c[tot] = (1&lt;&lt;k); ++k; &#125; if(y[i]) w[++tot] = x[i] * y[i] , c[tot] = y[i]; &#125; for(int i = 1 ; i &lt;= tot ; ++i) for(int j = k ; j &gt;= w[i] ; --j) f[j] = std::min(f[j] , f[j-w[i]] + c[i]); printf("%d",f[k]);&#125;]]></content>
      <tags>
        <tag>dp 单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NO.-7]]></title>
    <url>%2F2018%2F09%2F03%2FNO.-7%2F</url>
    <content type="text"><![CDATA[[USACO17JAN]Balanced Photo平衡的照片题目描述Farmer John is arranging his NN cows in a line to take a photo (1 \leq N \leq 100,0001≤N≤100,000). The height of the iith cow in sequence is h_ihi, and the heights of all cows are distinct. As with all photographs of his cows, FJ wants this one to come out looking as nice as possible. He decides that cow ii looks “unbalanced” if L_iLi and R_iRi differ by more than factor of 2, where L_iLi and R_iRi are the number of cows taller than ii on her left and right, respectively. That is, ii is unbalanced if the larger of L_iLi and R_iRi is strictly more than twice the smaller of these two numbers. FJ is hoping that not too many of his cows are unbalanced. Please help FJ compute the total number of unbalanced cows. FJ正在安排他的N头奶牛站成一排来拍照。（1&lt;=N&lt;=100,000)序列中的第i头奶牛的高度是h[i]，且序列中所有的奶牛的身高都不同。 就像他的所有牛的照片一样，FJ希望这张照片看上去尽可能好。他认为，如果L[i]和R[i]的数目相差2倍以上的话，第i头奶牛就是不平衡的。（L[i]和R[i]分别代表第i头奶牛左右两边比她高的数量）。FJ不希望他有太多的奶牛不平衡。 请帮助FJ计算不平衡的奶牛数量。 输入输出格式输入格式： The first line of input contains NN. The next NN lines contain h_1 \ldots h_Nh1…hN, each a nonnegative integer at most 1,000,000,000. 第一行一个整数N。接下N行包括H[1]到H[n]，每行一个非负整数（不大于1,000，000，000)。 输出格式： Please output a count of the number of cows that are unbalanced. 请输出不平衡的奶牛数量。 输入输出样例输入样例#1： 1234567873462305992 输出样例#1： 13 题解统计左边高的和右边高的显然是离散化+树状数组。右边高的就倒着让每头奶牛右边的比它先插入就可以统计了。 Code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005#define lowbit(x) (x &amp; -x)int bit[maxn] , l[maxn] , r[maxn] , n , tot , rank[maxn] , ans;struct cow&#123; int h , k;&#125;c[maxn]; bool operator&lt;(cow x , cow y)&#123;return x.h &lt; y.h;&#125;inline int query(int x)&#123; int ans = 0; for(int i = x ; i ; i -= lowbit(i)) ans += bit[i]; return ans;&#125;inline void update(int x , int v)&#123; for(int i = x ; i &lt;= tot ; i += lowbit(i)) bit[i] += v;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;c[i].h) , c[i].k = i; std::sort(c+1,c+n+1); c[0].h = 19260817; for(int i = 1 ; i &lt;= n ; ++i) if(c[i].h == c[i-1].h) rank[c[i].k] = tot; else rank[c[i].k] = ++ tot; // for(int i = 1 ; i &lt;= tot ; ++i) // printf("%d",rank[i]); for(int i = 1 ; i &lt;= n ; ++i) l[i] = i - 1 - query(rank[i]) , update(rank[i],1); std::memset(bit,0,sizeof(bit)); for(int i = n ; i &gt;= 1 ; --i) r[i] = n - i - query(rank[i]) , update(rank[i],1); // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d %d\n",l[i],r[i]); for(int i = 1 ; i &lt;= n ; ++i) if(l[i] &gt; 2 * r[i] || r[i] &gt; 2 * l[i]) ++ans; printf("%d",ans);&#125; 接下来复习树上背包树形DP复习完毕。。。 P2014 选课题目描述在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 输入输出格式输入格式： 第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300) 接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。 输出格式： 只有一行，选M门课程的最大得分。 输入输出样例输入样例#1： 123456787 42 20 10 42 17 17 62 2 输出样例#1： 113 题解这应该是树上背包最简单的问题了，题意就是让你选k件物品，每种物品选的条件是他的父亲都选，问最大价值。 设$f(u,k)$表示u的子树内选k件物品的最大价值是多少。 转移只需要抓住 每种物品选的条件是他的父亲都选 这个条件$dp[v][k-1]=dp[u][k]+val$$dp[u][k]=max(dp[u][k],dp[v][k−1])$这个我想了想它比真正的树上背包是要少一个枚举第二维的，因为它用了贪心的思想，显然根节点选的情况下子树可以选k-1个。 一般来说是这样的$f(u,k) = max\{f(v,t) + f(u,k-t-1)\}$这个似乎更好理解一点，emmm。 总结一下：树上背包主要就是将每个子树（或者说叫儿子，因为每个儿子的状态更新完后才会更新父亲的状态）看做物品，然后做正常背包，最上面那个是针对权值都是非负的情况的一种优化。 1234567891011121314151617181920212223242526272829303132333435363738394041// luogu-judger-enable-o2// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 305#define maxm 305int f[maxn][maxm] , n , head[maxn] , m , val[maxn] , cnt;struct edge&#123; int next , to;&#125;e[maxn*2];void dfs(int x , int cnt , int fx)&#123; if(cnt == 0) return; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(v == fx) continue; for(int k = 0 ; k &lt; cnt ; ++k) f[v][k] = f[x][k] + val[v]; dfs(v , cnt - 1 , x); for(int k = 1 ; k &lt;= cnt ; ++k) f[x][k] = std::max(f[x][k] , f[v][k-1]); &#125;&#125;inline void add(int x , int y)&#123; e[++cnt].next = head[x]; e[cnt].to = y; head[x] = cnt;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y; for(int i = 1 ; i &lt;= n; ++i) scanf("%d%d",&amp;x,&amp;y) , add(i,x) , add(x,i) , val[i] = y;//the i dfs(0,m,0); printf("%d",f[0][m]);&#125; 复习基础dp了，希望联赛别挂基础题。 「一本通 5.1 例 1」石子合并题目描述将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。 请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算： 选择一种合并石子的方案，使得做 n−1 次合并得分总和最大。 选择一种合并石子的方案，使得做 n−1 次合并得分总和最小。 输入格式输入第一行一个整数 nnn，表示有 nnn 堆石子。 第二行 nnn 个整数，表示每堆石子的数量。 输出格式输出共两行： 第一行为合并得分总和最小值， 第二行为合并得分总和最大值。 样例样例输入1244 5 9 4 样例输出124354 数据范围与提示对于 100% 的数据，有$1≤n≤200。$ 题解经典区间dp 首先假如我们有一个区间合并的最优值，以后转移也只需要他，所以 设f(l,r)表示l~r合并的最大值 每次区间合并的代价是整个区间的石子数加上当前两堆分别独自合并的最优值 Code： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 205int f[maxn*2][maxn*2] , n , v[maxn*2] , g[maxn*2][maxn*2];int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]) , v[i+n] = v[i]; for(int i = 1 ; i &lt;= 2 * n ; ++i) v[i] += v[i-1]; // for(int i = n + 1 ; i &lt;= 2 * n ; ++i) // v[i] = v[i-n]; // std::memset(f,-30,sizeof(f)); // std::memset(g,30,sizeof(g)); // for(int i = 1 ; i &lt;= 2 * n ; ++i) // f[i][i] = g[i][i] = 0; for(int i = 2 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= 2 * n - i + 1 ; ++j) &#123; int to = i + j - 1; f[j][to] = 0; g[j][to] = 0x7ffffff/8; for(int k = j ; k &lt; to ; ++k) &#123; f[j][to] = std::max(f[j][to] , f[j][k] + f[k+1][to]); g[j][to] = std::min(g[j][to] , g[j][k] + g[k+1][to]); &#125; g[j][to] += v[to] - v[j-1]; f[j][to] += v[to] - v[j-1]; &#125; int ans1 = 0 , ans2 = 0x7fffffff; for(int i = 1 ; i &lt;= n ; ++i) ans1 = std::max(ans1 , f[i][i+n-1]) , ans2 = std::min(ans2 , g[i][i+n-1]); printf("%d%d",ans2 , ans1);&#125; [USACO06NOV]路障Roadblocks题目描述Bessie has moved to a small farm and sometimes enjoys returning to visit one of her best friends. She does not want to get to her old home too quickly, because she likes the scenery along the way. She has decided to take the second-shortest rather than the shortest path. She knows there must be some second-shortest path. The countryside consists of R (1 ≤ R ≤ 100,000) bidirectional roads, each linking two of the N (1 ≤ N ≤ 5000) intersections, conveniently numbered 1..N. Bessie starts at intersection 1, and her friend (the destination) is at intersection N. The second-shortest path may share roads with any of the shortest paths, and it may backtrack i.e., use the same road or intersection more than once. The second-shortest path is the shortest path whose length is longer than the shortest path(s) (i.e., if two or more shortest paths exist, the second-shortest path is the one whose length is longer than those but no longer than any other path). 贝茜把家搬到了一个小农场，但她常常回到FJ的农场去拜访她的朋友。贝茜很喜欢路边的风景，不想那么快地结束她的旅途，于是她每次回农场，都会选择第二短的路径，而不象我们所习惯的那样，选择最短路。 贝茜所在的乡村有R(1&lt;=R&lt;=100,000)条双向道路，每条路都联结了所有的N(1&lt;=N&lt;=5000)个农场中的某两个。贝茜居住在农场1，她的朋友们居住在农场N（即贝茜每次旅行的目的地）。 贝茜选择的第二短的路径中，可以包含任何一条在最短路中出现的道路，并且，一条路可以重复走多次。当然咯，第二短路的长度必须严格大于最短路（可能有多条）的长度，但它的长度必须不大于所有除最短路外的路径的长度。 输入输出格式输入格式： Line 1: Two space-separated integers: N and R Lines 2..R+1: Each line contains three space-separated integers: A, B, and D that describe a road that connects intersections A and B and has length D (1 ≤ D ≤ 5000) 输出格式： Line 1: The length of the second shortest path between node 1 and node N 输入输出样例输入样例#1： 123454 41 2 1002 4 2002 3 2503 4 100 输出样例#1： 1450 说明Two routes: 1 -&gt; 2 -&gt; 4 (length 100+200=300) and 1 -&gt; 2 -&gt; 3 -&gt; 4 (length 100+250+100=450) 题解虽然现在最短路我已经倾向于写Dijkstra，但是这种灵活的最短路变形问题还是SPFA好思考一点。 题目要求严格非简单次短路，SPFA的更新方法很好想。 假如当前点u的最短路可以更新v的最短路，更新并且v的次短路变为原来的最短路。 假如当前点u的最短路不能更新v的最短路，但是可以更新v的次短路也要更新。 u的次短路也可以试着更新v的次短路。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 5005#define maxm 100005int head[maxn] , cnt , n , m , d[maxn] , g[maxn];bool vis[maxn];struct edge&#123; int next , to , dis;&#125;e[maxm*2];inline void add(int x, int y , int dis)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;void SPFA(int s)&#123; std::queue&lt;int&gt; q; std::memset(d,0x7f,sizeof(d)); std::memset(g,0x7f , sizeof(g)); d[s] = 0; q.push(s) , vis[s] = true; while(!q.empty()) &#123; int k = q.front(); q.pop(); vis[k] = false; for(int i = head[k] ; i ; i = e[i].next) &#123; if(d[k] + e[i].dis &lt; d[e[i].to]) &#123; g[e[i].to] = d[e[i].to]; d[e[i].to] = d[k] + e[i].dis; if(!vis[e[i].to]) q.push(e[i].to) , vis[e[i].to] = true; &#125; if(d[k] + e[i].dis &gt; d[e[i].to] &amp;&amp; d[k] + e[i].dis &lt; g[e[i].to]) &#123; g[e[i].to] = d[k] + e[i].dis; if(!vis[e[i].to]) q.push(e[i].to) , vis[e[i].to] = true; &#125; if(g[k] + e[i].dis &lt; g[e[i].to]) &#123; g[e[i].to] = g[k] + e[i].dis; if(!vis[e[i].to]) q.push(e[i].to) , vis[e[i].to] = true; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y , dis; for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;dis) , add(x,y,dis) , add(y,x,dis); SPFA(1); printf("%d",g[n]);&#125; 第六讲 分组的背包问题问题有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 算法这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有： 12&gt; f[k][v]=max&#123;f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于组k&#125;&gt; 使用一维数组的伪代码如下： 1234for 所有的组k for v=V..0 for 所有的i属于组k f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; 注意这里的三层循环的顺序，甚至在本文的第一个beta版中我自己都写错了。“for v=V..0”这一层循环必须在“for 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。（同01背包与完全背包） 另外，显然可以对每组内的物品应用P02中“一个简单有效的优化”。 小结分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。 相信理解了这个之后，对于树上背包的解决思路有了更加深刻的认识。 来看一道树上背包的简单题 二叉苹果树题目描述有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点） 这棵树共有N个结点（叶子点或者树枝分叉点），编号为1-N,树根编号一定是1。 我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。下面是一颗有4个树枝的树 123452 5 \ / 3 4 \ / 1 现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。 给定需要保留的树枝数量，求出最多能留住多少苹果。 输入输出格式输入格式： 第1行2个数，N和Q(1&lt;=Q&lt;= N,1&lt;N&lt;=100)。 N表示树的结点数，Q表示要保留的树枝数量。接下来N-1行描述树枝的信息。 每行3个整数，前两个是它连接的结点的编号。第3个数是这根树枝上苹果的数量。 每根树枝上的苹果不超过30000个。 输出格式： 一个数，最多能留住的苹果的数量。 输入输出样例输入样例#1： 123455 21 3 11 4 102 3 203 5 20 输出样例#1： 121 题解显然每颗子树的每个状态是一件物品， 每颗子树的所有状态构成一组物品，每组物品只能选一件，使当前状态值最大 = 分组背包 注意边界问题，不合法的边界将会导致错误 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define maxn 105int f[maxn][maxn] , n , q , head[maxn] , cnt , v[maxn] , sz[maxn];struct edge&#123; int next , to , dis;&#125;e[maxn*2];inline void add(int x, int y , int dis)&#123; e[++cnt].next = head[x]; e[cnt].to = y; e[cnt].dis = dis; head[x] = cnt;&#125;void pre(int x , int fx , int d)&#123; v[x] = d; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) pre(e[i].to , x , e[i].dis);&#125;void dfs(int x , int fx)&#123; for(int i = head[x] ; i ; i = e[i].next) if(e[i].to != fx) &#123; dfs(e[i].to , x); sz[x] += sz[e[i].to] + 1; for(int j = std::min(q,sz[x]); j &gt;= 1 ; --j) for(int k = std::min(j-1,sz[e[i].to]) ; k &gt;= 0 ; --k) f[x][j] = std::max(f[e[i].to][k] + f[x][j-k-1] + e[i].dis , f[x][j]); &#125; // for(int i = q ; i &gt;= 1 ; --i) // f[x][i] = f[x][i-1] + v[x];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); int x , y , dis; for(int i = 1 ; i &lt;= n-1 ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;dis) , add(x,y,dis) , add(y,x,dis); pre(1,1,0); dfs(1,1); printf("%d",f[1][q]);&#125;]]></content>
      <tags>
        <tag>树上背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NO.-5]]></title>
    <url>%2F2018%2F08%2F13%2FNO.-5%2F</url>
    <content type="text"><![CDATA[P1921 赌博游戏题目背景赌场是暴利的。大赌场通过游戏规则控制游戏的公平来赚钱。虽然规则看似很公平，但实际上是稍微有点不公平的，而大赌场由于客流量大，资金流量大，这点稍微的不公平就被放大到能让赌场得到很可观的收入。同时，这些个不公平有时并不是规则的不公平，而是道具不公平。比如说灌铅的骰子，它和正常骰子不一样，它投出Q种点数的概率并不一样。有时，为了不让顾客察觉，他们每一次游戏结束后都有可能更换骰子。 题目描述作弊的赌场有N个骰子，在这个赌场可能发生了M次游戏，每次游戏包括一个骰子投出的点数，我们并不知道这个骰子的编号，但知道第i次游戏投出的点数O(i)。 第i个骰子投出点数j的概率是A(i,j)，用完第i个骰子，下一次用第j个骰子的概率为B(i,j)。特别地，对于第一次游戏，用第i个骰子的概率为π(i)。 好奇的小v来问你，在这个赌场发生这M次游戏的概率。 输入输出格式输入格式： 第一行两个正整数N，M，Q 第二行N个浮点数，表示π(i) 第三行至2+N行有N*Q个浮点数，第i+2行j列表示A(i,j) 第N+3至2N+2行有NN个浮点数，第N+2+i行j列表示B(i,j) 第2*N+3行有M个正整数，表示M次游戏的结果O[i]，也就是每次游戏投出的点数。 输出格式： 表示所求概率，保留四位位小数。 输入输出样例输入样例#1： 1234567893 10 31 0 00.03 0.03 0.940.02 0.02 0.960.99 0.005 0.0050.01 0.99 00.05 0.05 0.900.98 0.002 0.008 2 2 0 2 2 0 2 2 0 2 输出样例#1： 10.4483 说明数据范围: 对于30%的数据：M&lt;=100，1&lt;=N，Q&lt;=10 对于100%的数据：1&lt;=M&lt;=1000，1&lt;=N，Q&lt;=50 对于矩阵A，B，向量π都具备概率转移的特征条件 期望dp入门题,NOIp D1T2难度 首先我们能想到设计一个状态，使得可以转移到第m次游戏时完全匹配的概率，显然游戏的次数是一个状态维度。 而每次转移到下一次我们只需要知道上一次的骰子点数是多少，因此第二维我们就表示为结尾的骰子是什么。 转移就是 ​ f[i][j] =\sum_{i=1}^{n} f[i-1][k]*A[j][res[i]]*B[k][j]显然m次游戏后以任意骰子结尾都是合法的，因此 Ans = \sum_{i=1}^{n} f[m][i]Code: 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 55#define maxq 55#define maxm 1005double pi[maxn] , A[maxn][maxq] , B[maxn][maxn] , f[maxm][maxn] ;int res[maxm];int n , m , q;double eps = 1e-6;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lf",&amp;pi[i]); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 0 ; j &lt;= q-1 ; ++j) scanf("%lf",&amp;A[i][j]); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= n ; ++j) scanf("%lf",&amp;B[i][j]); for(int i = 1 ; i &lt;= m ; ++i) scanf("%d",&amp;res[i]); for(int i = 1 ; i &lt;= n ; ++i) f[1][i] = pi[i] * A[i][res[1]]; for(int i = 2 ; i &lt;= m ; ++i) for(int j = 1 ; j &lt;= n ; ++j) for(int k = 1 ; k &lt;= n ; ++k) f[i][j] += f[i-1][k] * A[j][res[i]] * B[k][j]; double ans = 0.00; for(int i = 1 ; i &lt;= n ; ++i) ans += f[m][i]; printf("%.4lf",ans);&#125; P1613 跑路题目描述小A的工作不仅繁琐，更有苛刻的规定，要求小A每天早上在6：00之前到达公司，否则这个月工资清零。可是小A偏偏又有赖床的坏毛病。于是为了保住自己的工资，小A买了一个十分牛B的空间跑路器，每秒钟可以跑2^k千米（k是任意自然数）。当然，这个机器是用longint存的，所以总跑路长度不能超过maxlongint千米。小A的家到公司的路可以看做一个有向图，小A家为点1，公司为点n，每条边长度均为一千米。小A想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证1到n至少有一条路径。 输入输出格式输入格式： 第一行两个整数n，m，表示点的个数和边的个数。 接下来m行每行两个数字u，v，表示一条u到v的边。 输出格式： 一行一个数字，表示到公司的最少秒数。 输入输出样例输入样例#1： 复制 123454 41 11 22 33 4 输出样例#1： 复制 11 说明【样例解释】 1-&gt;1-&gt;2-&gt;3-&gt;4，总路径长度为4千米，直接使用一次跑路器即可。 【数据范围】 50%的数据满足最优解路径长度&lt;=1000； 100%的数据满足n&lt;=50，m&lt;=10000，最优解路径长度&lt;=maxlongint。 一看是 2^k大致想到就是倍增了。 设 f(i,j,k)表示i,j之间的路径长度是否是 2^k显然1也是2的次幂，所以每条边初始的时候就是 f(u,v,0) = true然后这些是 2^k的都可以1s到达，所以再设dis跑最短路即可。 Code: 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 105#define maxlog 45bool f[maxn][maxn][maxlog];int dis[maxn][maxn];int n , m ,x , y;int main()&#123; scanf("%d%d",&amp;n,&amp;m); std::memset(dis,30,sizeof(dis));//below the adjancent matrix!!! for(int i = 1 ; i &lt;= m ; ++i) &#123; scanf("%d%d",&amp;x,&amp;y); f[x][y][0] = true;//direct Graph !!! read carefully! dis[x][y] = 1;//init , do not forget! &#125; for(int i = 1 ; i &lt;= maxlog ; ++i) for(int j = 1 ; j &lt;= n ; ++j) for(int u = 1 ; u &lt;= n ; ++u) for(int v = 1 ; v &lt;= n ; ++v) if(f[u][j][i-1] &amp;&amp; f[j][v][i-1]) f[u][v][i] = true , dis[u][v] = 1; for(int k = 1 ; k &lt;= n ; ++k) for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= n ; ++j) dis[i][j] = std::min(dis[i][j],dis[i][k] + dis[k][j]); printf("%d",dis[1][n]);&#125; P1608 路径统计题目描述走一条从小镇1到小镇N花费最少的一条路，这个最少花费的路径有多少条？ 输入输出格式输入格式： 输入文件第一行为两个空格隔开的数N，E，表示这张地图里有多少个小镇及有多少边的信息。 下面E行，每行三个数I、J、C，表示从I小镇到J小镇有道路相连且花费为C.（注意，数据提供的边信息可能会重复，不过保证I&lt;&gt;J,1&lt;=I,J&lt;=n）。 输出格式： 输出文件包含两个数，分别是最少花费和花费最少的路径的总数. 两个不同的最短路方案要求：路径长度相同（均为最短路长度）且至少有一条边不重合。 若城市N无法到达则只输出一个(‘No answer’); 输入输出样例输入样例#1： 123455 41 5 41 2 22 5 24 1 1 输出样例#1： 14 2 说明对于30%的数据 N&lt;=20; 对于100%的数据 1&lt;=N&lt;=2000,0&lt;=E&lt;=N*(N-1), 1&lt;=C&lt;=10. 讲道理，真是4000000条边什么都跑不进一秒时限 最短路计数，SPFA或者DIJ都能完成。 SPFA最短路计数思想是，每更新一次就重置被更新点为当前点的数量，假如一样由加法原理就加上更新点的计数。 【算法思路】我们直接对图跑一遍SPFA，只不过在修改每个点到起点的距离的同时，我们还需要使用一个cnt数组来记录到这个点的最短路径的路径数。并且当我们修改某个点到起点的最短距离时，需要进行一些额外的处理： 1.如果搜索到的点到起点的距离等于当前点到起点的距离加上这两点间的那条边的距离，那么我们就将搜索到的点的路径数加上当前点的路径数，即： 12if(dis[i]==dis[k]+e[k][i]) cnt[i]+=cnt[k]; 2.如果我们更新了搜索到的点到起点的最短距离，那么我们将到达改点的路径数改为当前点的路径数，即： 1234if(dis[i]&gt;dis[k]+e[k][i])&#123; dis[i]=dis[k]+e[k][i]; cnt[i]=cnt[k];&#125; 3.只有当一个点到起点的路径数不为0且未入队时，我们才将它放入队列。 【注意事项】1、由于试题中存在重边（更详细的说应该是完全一样的边），并结合节点数小于等于2000这个数据范围，所以我们优先考虑使用邻接矩阵来保存边以方便预处理判重。 2、如果用于存边的二维数组定义的为int型，则初始化时建议不要将值设为2^31-1，否则有可能在中途比较的时候，算出来一些奇奇怪怪的东西。 3、如果搜索到的一条边的终点为n，那么我们应该跳过这一条边的搜索，而不是直接结束程序。 4、每次对取出来的点进行完搜索后，一定要将它的路径数清0，不然会出现重复统计。 【代码】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int e[2010][2010],n,cnt[2010],dis[2010];bool book[2010];void spfa(int s,int t)&#123; queue &lt;int&gt; sta; sta.push(s); book[s]=1; cnt[s]=1; dis[s]=0; while(!sta.empty())&#123; int k=sta.front(); sta.pop(); book[k]=0; if(k==t) continue; for(register int i=1;i&lt;=n;i=-~i)&#123; if(dis[i]==dis[k]+e[k][i]) cnt[i]+=cnt[k]; if(dis[i]&gt;dis[k]+e[k][i])&#123; dis[i]=dis[k]+e[k][i]; cnt[i]=cnt[k]; &#125; if(cnt[i] &amp;&amp; !book[i])&#123; book[i]=1; sta.push(i); &#125; &#125; cnt[k]=0; &#125;&#125;int main()&#123; int x,y,z,i,j,k,m; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i=-~i) for(j=1;j&lt;=n;j=-~j) e[i][j]=1000000000; while(m--)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); e[x][y]=min(e[x][y],z); &#125; for(i=1;i&lt;=n;i=-~i) dis[i]=1000000000; spfa(1,n); if(dis[n]==1000000000) printf("No answer"); else printf("%d %d",dis[n],cnt[n]); return 0;&#125; 而我想的则是更加（稳定）好想的DIJ，由DIJ原理可知，当前出队的点一定是最短路了，这样更新其他点后也不用清空，而且一点也不玄学。 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define pii std::pair&lt;int,int&gt;#define mp(x,y) std::make_pair((x),(y))#define maxn 2005int g[maxn][maxn];int head[maxn] , tot , n , m , d[maxn];struct edge&#123; int next , to , dis;&#125;e[maxn*maxn];inline void add(int x , int y , int d)&#123; e[++tot].next = head[x]; e[tot].to = y; e[tot].dis = d; head[x] = tot;&#125;namespace CNT&#123; bool vis[maxn]; long long cnt[maxn]; inline void DIJCNT(int s) &#123; std::priority_queue&lt;pii,std::vector&lt;pii&gt; , std::greater&lt;pii&gt; &gt; q; std::memset(d,0x7f,sizeof(d)); d[s] = 0 , cnt[s] = 1; q.push(mp(d[s],s)); while(!q.empty()) &#123; int k = q.top().second; q.pop(); if(vis[k]) continue; vis[k] = true; for(int i = head[k] ; i ; i = e[i].next) &#123; if(d[k] + e[i].dis &lt; d[e[i].to]) &#123; d[e[i].to] = d[k] + e[i].dis; cnt[e[i].to] = cnt[k]; q.push(mp(d[e[i].to],e[i].to)); &#125; else if(d[k] + e[i].dis == d[e[i].to]) cnt[e[i].to] += cnt[k]; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); int x , y , dis; std::memset(g,0x7f,sizeof(g)); for(int i = 1 ; i &lt;= m ; ++i) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;dis); g[x][y] = std::min(g[x][y],dis) ; &#125; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= n ; ++j) if(i != j &amp;&amp; g[i][j]) add(i,j,g[i][j]); CNT::DIJCNT(1); if(d[n] &gt; 80000000) &#123; puts("No answer"); return 0; &#125; printf("%d %lld", d[n] , CNT::cnt[n]);&#125; 关于如何使用unordered_map 12#include &lt;tr1\unordered_map&gt;std::tr1::unordered_map&lt;int,int&gt; mapa; 有时间练练这个好东西qwq P1342 请柬题目描述给定一个有向图，求源点到所有点的最短路之和与所有点到源点的最短路之和。 输入输出格式输入格式： 第1行有两个整数n、m，n是点数，m是有向边数。 输出格式： 输出一行，表示所求答案。 数据范围 (1]]></content>
      <tags>
        <tag>期望dp 图论 生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组学习笔记]]></title>
    <url>%2F2018%2F07%2F14%2FEF2%2F</url>
    <content type="text"><![CDATA[\sum_{i=1}^{n}love_i准备加强一下树状数组的使用？ 首先来看一维区间修改+查询怎么做。 还是要应用差分。 思路还是很简单的。。 放代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define maxn 1000005#define lowbit(x) x &amp; (-x)long long BIT[3][maxn] , c[maxn] , n , t[maxn] , m , op , l , r , v;inline void update(int,int,int);inline long long query(int,int);//first is the query typeinline void init();int main()&#123; freopen("6.in","r",stdin); freopen("my.out","w",stdout); scanf("%lld%lld",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%lld",&amp;t[i]); for(int i = 1 ; i &lt;= n ; ++i) c[i] = t[i] - t[i-1]; // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d\n",c[i]); init(); for(int i = 1 ; i &lt;= m ; ++i) &#123; scanf("%lld",&amp;op); if(op == 1) &#123; scanf("%lld%lld%lld",&amp;l,&amp;r,&amp;v); update(1,l,v) , update(1,r+1,-v); update(2,l,v) , update(2,r+1,-v); &#125; if(op == 2) &#123; scanf("%lld%lld",&amp;l,&amp;r); // printf("%lld %lld %lld %lld\n",(r+1)*query(1,r),query(2,r),l*query(1,l-1),query(2,l-1)); printf("%lld\n",(r+1)*query(1,r) - query(2,r) - l*query(1,l-1) + query(2,l-1)); &#125; &#125;&#125;inline void init()&#123; for(int i = 1 ; i &lt;= n ; ++i) update(1,i,c[i]) , update(2,i,c[i]); // BIT[1][i] += c[i] , BIT[2][i] += c[i]*i;//why this WA?? // if(i + lowbit(i) &lt;= n) // BIT[1][i+lowbit(i)] += c[i] , BIT[2][i+lowbit(i)] += c[i]*i;&#125;inline long long query(int type , int k)&#123; long long ans = 0; if(type == 1) for(int i = k ; i ; i -= lowbit(i)) ans += BIT[1][i]; else for(int i = k ; i ; i -= lowbit(i)) ans += BIT[2][i]; return ans;&#125;inline void update(int type , int k , int v)&#123; if(type == 1) for(int i = k ; i &lt;= n ; i += lowbit(i)) BIT[1][i] += v; else for(int i = k ; i &lt;= n ; i += lowbit(i)) BIT[2][i] += 1ll*v*k;// love vk~&#125; 2–d树状数组支持维护区间修改区间查询。 显然二维线段树会被卡空间（事实是不会） ， 我们来看看如何用二维树状数组来维护。 AC代码（巨大无比的常数令我很无奈。。最后加了register和快读连同inline才一起过的。。）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define lowbit(x) (x) &amp; -(x)#define maxn 2050#define re registerint BIT[4][maxn][maxn] , n , m , x , y , a , b , v;char c;inline int read()&#123; int x = 0 , f = 1; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') &#123; if(ch == '-') f= -1; ch = getchar(); &#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x&lt;&lt;3) + (x&lt;&lt;1) + ch - 48 , ch = getchar(); return x*f;&#125;inline int query(int tr , int x , int y)&#123; int ans = 0; for(re int i = x ; i ; i -= lowbit(i)) for(re int j = y ; j ; j -= lowbit(j)) ans += BIT[tr][i][j]; return ans;&#125;inline int rangeSum(int x, int y)&#123; return query(0,x,y)*(x+1)*(y+1) - query(1,x,y)*(y+1) - query(2,x,y)*(x+1) + query(3,x,y);&#125;inline void update(int x , int y , int v)&#123; for(re int i = x ; i &lt;= n ; i += lowbit(i)) for(re int j = y ; j &lt;= m ; j += lowbit(j)) BIT[0][i][j] += v , BIT[1][i][j] += v*x , BIT[2][i][j] += v*y , BIT[3][i][j] += v*x*y;&#125;int main()&#123; std::cin&gt;&gt;c; scanf("%d%d",&amp;n,&amp;m); while(std::cin&gt;&gt;c) &#123; if(c == 'L')//update &#123; a = read() , b = read() , x = read() , y = read() , v = read(); update(a,b,v) , update(a,y+1,-v), update(x+1,b,-v) , update(x+1,y+1,v); &#125; else if(c == 'k') &#123; a = read() , b = read() , x = read() , y = read() ; printf("%d\n",rangeSum(x,y)-rangeSum(x,b-1)-rangeSum(a-1,y)+rangeSum(a-1,b-1)); &#125; &#125;&#125;/*X 4 4L 1 1 3 3 2L 2 2 4 4 1k 2 2 3 3*/ 友情提示：2-d BIT从上面会发现如果数据比较大是会很容易爆掉的，开long long都么有用，所以二维线段树在空间允许的情况下比较好用。]]></content>
      <tags>
        <tag>FenwickTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bef->NO.14]]></title>
    <url>%2F2018%2F06%2F06%2FNO.-14%2F</url>
    <content type="text"><![CDATA[[NOI2005]瑰丽华尔兹题目背景你跳过华尔兹吗？当音乐响起，当你随着旋律滑动舞步，是不是有一种漫步仙境的惬意？ 众所周知，跳华尔兹时，最重要的是有好的音乐。但是很少有几个人知道，世界上最伟大的钢琴家一生都漂泊在大海上，他的名字叫丹尼·布德曼·T.D.·柠檬·1900，朋友们都叫他1900。 1900 在20 世纪的第一年出生在往返于欧美的邮轮弗吉尼亚号上。很不幸，他刚出生就被抛弃，成了孤儿。1900 孤独的成长在弗吉尼亚号上，从未离开过这个摇晃的世界。也许是对他命运的补偿，上帝派可爱的小天使艾米丽照顾他。可能是天使的点化，1900拥有不可思议的钢琴天赋：从未有人教，从没看过乐谱，但他却能凭着自己的感觉弹出最沁人心脾的旋律。当1900 的音乐获得邮轮上所有人的欢迎时，他才8 岁，而此时，他已经乘着海轮往返欧美大陆50 余 次了。 虽说是钢琴奇才，但1900还是个孩子，他有着和一般男孩一样的好奇和调皮，只不过更多一层浪漫的色彩罢了：这是一个风雨交加的夜晚，海风卷起层层巨浪拍打着弗吉尼亚号，邮轮随着巨浪剧烈的摇摆。船上的新萨克斯手迈克斯·托尼晕船了，1900 招呼托尼和他 一起坐到舞厅里的钢琴上，然后松开了固定钢琴的闸，于是，钢琴随着海轮的倾斜滑动起来。准确的说，我们的主角1900、… 题目描述不妨认为舞厅是一个N行M列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。 艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。 输入输出格式输入格式： 输入文件的第一行包含5个数N, M, x, y和K。N和M描述舞厅的大小，x和y为钢琴的初始位置；我们对船体倾斜情况是按时间的区间来描述的，且从1开始计算时间，比如“在[1, 3]时间里向东倾斜，[4, 5]时间里向北倾斜”，因此这里的K表示区间的数目。 以下N行，每行M个字符，描述舞厅里的家具。第i 行第j 列的字符若为‘ . ’，则表示该位置是空地；若为‘ x ’，则表示有家具。 以下K行，顺序描述K个时间区间，格式为：si ti di(1 ≤ i ≤ K)。表示在时间区间[si, ti]内，船体都是向di方向倾斜的。di为1, 2, 3, 4中的一个，依次表示北、南、西、东（分别对应矩阵中的上、下、左、右）。输入保证区间是连续的，即 s1 = 1 ti = si-1 + 1 (1 &lt; i ≤ K) tK = T 输出格式： 输出文件仅有1行，包含一个整数，表示钢琴滑行的最长距离(即格子数)。 输入输出样例输入样例#1： 123456784 5 4 1 3..xx.........x......1 3 44 5 16 7 3 输出样例#1： 16 说明钢琴的滑行路线： 钢琴在“×”位置上时天使使用一次魔法，因此滑动总长度为6。 【数据范围】 50%的数据中，1≤N, M≤200，T≤200； 100%的数据中，1≤N, M≤200，K≤200，T≤40000。 题解这道题的dp实在是挺好想的，我一开始以为是道高思维难度DP。 最最基础也最最简单的dp状态就是 f(i,j,k)表示i时间后到达(j,k)的最长滑行路线，然后用 (i',j')表示 (i,j)的上一个合法位置 那么 f(i,j,k) = max\{f(i-1,j',k')\} + 1期望得分：40 然后我们很容易发现对于每一个时间区间方向是单调的，这样的话我们就可以用 f(i,j,k)表示i时间段后到达(j,k)的最长滑行路线，然后 f(i,j,k) = max\{f(i-1,j',k') + w_i\}w是个枚举量,(j’,k’)由 w_i确定 然后不合法的状态就不用转移。 Code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define max(a,b) (a) &gt; (b) ? (a) : (b)#define maxn 205char ch;int f[maxn][maxn][maxn] , n , m , k , l[maxn] , r[maxn] , g[maxn][maxn] , xx , yy , dr[maxn] , ans;int main()&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;xx,&amp;yy,&amp;k); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) std::cin&gt;&gt;ch , g[i][j] = (ch=='x'); // printf("%d\n",k); for(int i = 1 ; i &lt;= k ; ++i) scanf("%d%d%d",&amp;l[i],&amp;r[i],&amp;dr[i]); // puts("OK"); int dx , dy ; std::memset(f,-1,sizeof(f)); f[0][xx][yy] = 0; for(int i = 1 ; i &lt;= k ; ++i) &#123; if(dr[i] == 1) dx = -1 , dy = 0; if(dr[i] == 2) dx = 1 , dy = 0; if(dr[i] == 3) dx = 0 , dy = -1; if(dr[i] == 4) dx = 0 , dy = 1; for(int x = 1 ; x &lt;= n ; ++x) for(int y = 1 ; y &lt;= m ; ++y) &#123; if(f[i-1][x][y] == -1) continue; if(g[x][y]) continue; for(int w = 0 ; w &lt;= r[i] - l[i] + 1 ; ++w) &#123; int nx = x + w * dx , ny = y + w * dy ; if(nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; m || g[nx][ny]) break; f[i][nx][ny] = max(f[i][nx][ny] , f[i-1][x][y] + w); &#125; &#125; &#125; for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= m ; ++j) ans = max(ans , f[k][i][j]); printf("%d",ans);&#125; 序列合并题目描述有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到N^2N2个和，求这N^2N2个和中最小的N个。 输入输出格式输入格式： 第一行一个正整数N； 第二行N个整数A_iAi, 满足A_i\le A_{i+1}Ai≤Ai+1且A_i\le 10^9Ai≤109; 第三行N个整数B_iBi, 满足B_i\le B_{i+1}Bi≤Bi+1且B_i\le 10^9Bi≤109. 【数据规模】 对于50%的数据中，满足1&lt;=N&lt;=1000； 对于100%的数据中，满足1&lt;=N&lt;=100000。 输出格式： 输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。 输入输出样例输入样例#1： 12332 6 61 4 8 输出样例#1： 13 6 7 题解一道很不错的思路题。 经过我的冥思苦想，发现假如我们对每个数编号0,1，然后放进同一个数组排序，只需要看看前面有几个和他编号不同的，显然是错误的。 期望得分：0分 然后我们考虑暴力，堆模拟。 n^2logn期望得分：50 ， 真好 最后我们的暴力价格剪枝，对于 A_i*B_j : A_{i-1}*B_{j},A_{i}*{B_{j-1}} , A_{i-1}*B_{j-1}他们全都得在n个和以内，否则就不用加入优先队列 期望得分：100 ， 很玄学 Code： 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;queue&gt;std::priority_queue&lt;int , std::vector&lt;int&gt; , std::greater&lt;int&gt; &gt; q;#define maxn 100005int n , flag , A[maxn] , B[maxn];int main()&#123; scanf("%d",&amp;n); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;A[i]) ; for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;B[i]); for(int i = 1 ; i &lt;= n ; ++i) for(int j = 1 ; j &lt;= n ; ++j) &#123; if(i*j &gt; n) break; q.push(A[i]+B[j]); &#125; for(int i = 1 ; i &lt;= n ; ++i) printf("%d " , q.top()) , q.pop();&#125; 哈希冲突题目背景此题约为NOIP提高组Day2T2难度。 题目描述众所周知，模数的hash会产生冲突。例如，如果模的数p=7，那么4和11便冲突了。 B君对hash冲突很感兴趣。他会给出一个正整数序列value[]。 自然，B君会把这些数据存进hash池。第value[k]会被存进(k%p)这个池。这样就能造成很多冲突。 B君会给定许多个p和x，询问在模p时，x这个池内数的总和。 另外，B君会随时更改value[k]。每次更改立即生效。 保证1&lt;=p&lt;n1&lt;=p&lt;n. 输入输出格式输入格式： 第一行，两个正整数n,m，其中n代表序列长度，m代表B君的操作次数。 第一行，n个正整数，代表初始序列。 接下来m行，首先是一个字符cmd，然后是两个整数x,y。 若cmd=&#39;A&#39;，则询问在模x时，y池内数的总和。 若cmd=&#39;C&#39;，则将value[x]修改为y。 输出格式： 对于每个询问输出一个正整数，进行回答。 输入输出样例输入样例#1： 123456710 51 2 3 4 5 6 7 8 9 10A 2 1C 1 20A 3 1C 5 1A 5 0 输出样例#1： 123254111 说明样例解释 A 2 1的答案是1+3+5+7+9=25. A 3 1的答案是20+4+7+10=41. A 5 0的答案是1+10=11. 数据规模 对于10%的数据，有n&lt;=1000,m&lt;=1000. 对于60%的数据，有n&lt;=100000.m&lt;=100000. 对于100%的数据，有n&lt;=150000,m&lt;=150000. 保证所有数据合法，且1&lt;=value[i]&lt;=1000. 题解自己yy出了一个根号优化。。 我们把模数分成小于等于 \sqrt{n}和其他两部分。 然后对于小模数，我们 O(n\sqrt{n})预处理每个数在 \sqrt{n}以下的模数的余数的和（即hash池） 每次修改除了要改原数组，还要 \sqrt{n}地更新预处理的数组。 大模数直接暴力就好，最后时间复杂度 O((n+m)\sqrt{n})可以通过本题。 Code : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define maxn 150005#define maxsqrt 400int block[maxsqrt][maxsqrt] , n , p , m , x , y , v[maxn] , size;char ch;inline void update(int x , int y)&#123; int val = v[x]; v[x] = y; for(int i = 1 ; i &lt;= size ; ++i) block[i][x%i] -= val , block[i][x%i] += v[x];&#125;inline int query(int x , int y)&#123; return block[x][y];&#125;inline int brute(int x , int y)&#123; int ans = 0; for(int i = y ; i &lt;= n ; i += x) ans += v[i]; return ans;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;v[i]); size = std::sqrt(n); for(int i = 1 ; i &lt;= size ; ++i) for(int j = 1 ; j &lt;= n ; ++j) block[i][j%i] += v[j]; for(int i = 1 ; i &lt;= m ; ++i) &#123; std::cin&gt;&gt;ch; if(ch == 'A') &#123; scanf("%d%d",&amp;x,&amp;y); if(x &lt;= size) printf("%d\n",query(x,y)); else printf("%d\n",brute(x,y)); &#125; else if(ch == 'C') scanf("%d%d",&amp;x,&amp;y) , update(x,y); &#125;&#125; [USACO07NOV]电话线Telephone Wire题目描述Farmer John’s cows are getting restless about their poor telephone service; they want FJ to replace the old telephone wire with new, more efficient wire. The new wiring will utilize N (2 ≤ N ≤ 100,000) already-installed telephone poles, each with some heighti meters (1 ≤ heighti ≤ 100). The new wire will connect the tops of each pair of adjacent poles and will incur a penalty cost C × the two poles’ height difference for each section of wire where the poles are of different heights (1 ≤ C ≤ 100). The poles, of course, are in a certain sequence and can not be moved. Farmer John figures that if he makes some poles taller he can reduce his penalties, though with some other additional cost. He can add an integer X number of meters to a pole at a cost of X2. Help Farmer John determine the cheapest combination of growing pole heights and connecting wire so that the cows can get their new and improved service. 给出若干棵树的高度，你可以进行一种操作：把某棵树增高h，花费为h*h。 操作完成后连线，两棵树间花费为高度差*定值c。 求两种花费加和最小值。 输入输出格式输入格式： * Line 1: Two space-separated integers: N and C * Lines 2..N+1: Line i+1 contains a single integer: heighti 输出格式： * Line 1: The minimum total amount of money that it will cost Farmer John to attach the new telephone wire. 输入输出样例输入样例#1： 1234565 223514 输出样例#1： 115 题解一个很简单的dp 分析如何设计状态，显然从前往后dp每个数只和它前面的一个数在计算的时候有关系 因此设 f(i,j)表示前i个最后一个高为j的费用。 然后转移很显然 f(i,j) = (h[i]-j)^2 + max\{abs(j-k) * c+f(i-1,k)\}Code: 123456789101112131415161718192021222324252627// luogu-judger-enable-o2#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define maxn 100005#define maxh 105int f[maxn][maxh] , n , h[maxn] , c , hmax , ans = 0x7fffffff;inline int abs(int x)&#123;return x &gt;= 0 ? x : (-x) ;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;c); for(int i = 1 ; i &lt;= n ; ++i) scanf("%d",&amp;h[i]) , hmax = std::max(hmax , h[i]); // hmax = 99; std::memset(f,30,sizeof(f)); for(int i = 1 ; i &lt;= hmax ; ++i) f[1][i] = (h[1] - i) * (h[1] - i); for(int i = 2 ; i &lt;= n ; ++i) for(int j = h[i] ; j &lt;= hmax ; ++j)//f[i][j] = std::min(f[i][j] , f[i-1][k] + (h[i] - j) * (h[i] - j) + c * abs(k - j)); for(int k = h[i-1] ; k &lt;= hmax ; ++k) f[i][j] = std::min(f[i][j] , f[i-1][k] + (h[i] - j) * (h[i] - j) + c * abs(k - j)); for(int i = 1 ; i &lt;= hmax ; ++i) ans = std::min(ans , f[n][i]); printf("%d",ans);&#125; [APIO2008]免费道路题目描述新亚（New Asia）王国有 N 个村庄，由 M 条道路连接。其中一些道路是鹅卵石路，而其它道路是水泥路。保持道路免费运行需要一大笔费用，并且看上去 王国不可能保持所有道路免费。为此亟待制定一个新的道路维护计划。 国王已决定保持尽可能少的道路免费，但是两个不同的村庄之间都应该一条且仅由一条 且仅由一条免费道路的路径连接。同时，虽然水泥路更适合现代交通的需 要，但国王也认为走在鹅卵石路上是一件有趣的事情。所以，国王决定保持刚好 K 条鹅卵石路免费。 举例来说，假定新亚王国的村庄和道路如图 3(a)所示。如果国王希望保持两 条鹅卵石路免费，那么可以如图 3(b)中那样保持道路(1, 2)、(2, 3)、(3, 4)和(3, 5) 免费。该方案满足了国王的要求，因为：(1)两个村庄之间都有一条由免费道 路组成的路径；(2)免费的道路已尽可能少；(3)方案中刚好有两条鹅卵石道路 (2, 3)和(3, 4) 图 3: (a)新亚王国中村庄和道路的一个示例。实线标注的是水泥路，虚线标注 的是鹅卵石路。(b)一个保持两条鹅卵石路免费的维护方案。图中仅标出了免 费道路。 给定一个关于新亚王国村庄和道路的述以及国王决定保持免费的鹅卵石 道路数目，写一个程序确定是否存在一个道路维护计划以满足国王的要求，如果 存在则任意输出一个方案。 输入输出格式输入格式： 输入第一行包含三个由空格隔开的整数： N，村庄的数目(1≤N≤20,000)； M，道路的数目(1≤M≤100,000)； K，国王希望保持免费的鹅卵石道路数目(0≤K≤N - 1)。 此后 M 行述了新亚王国的道路，编号分别为 1 到 M。第(i+1)行述了第 i 条 道路的情况。用 3 个由空格隔开的整数述： ui 和 vi，为第 i 条道路连接的两个村庄的编号，村庄编号为 1 到 N； ci，表示第 i 条道路的类型。ci = 0 表示第 i 条道路是鹅卵石路，ci = 1 表 示第 i 条道路是水泥路。 输入数据保证一对村庄之间至多有一条道路连接 输出格式： 如果满足国王要求的道路维护方案不存在，你的程序应该在输出第一行打印 no solution。 否则，你的程序应该输出一个符合要求的道路维护方案，也就是保持免费的 道路列表。按照输入中给定的那样输出免费的道路。如果有多种合法方案，你可 以任意输出一种。 输入输出样例输入样例#1： 123456785 7 2 1 3 0 4 5 1 3 2 0 5 3 1 4 3 0 1 2 1 4 2 1 输出样例#1： 12343 2 0 4 3 0 5 3 1 1 2 1 题解我一眼就想到了边权随机化的带权二分，啊哈哈哈独立切了APIO的题。 WQS二分前面已经说过了。 然后就没什么了，挺简单一道题。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#define maxn 20005#define maxm 100005#define ll long longll cnt , tot , n , m , mst , ans , f[maxn] , k , flag;bool get[maxm] , vis[maxm];struct edge&#123; ll from , to , dis , col;&#125;e[maxm] , g[maxm];inline bool operator &lt; (edge x , edge y)&#123; if(x.dis == y.dis) return x.col &lt; y.col ; return x.dis &lt; y.dis;&#125;int find(int x)&#123; if(f[x] != x) return f[x] = find(f[x]); return f[x];&#125;inline void add(ll x , ll y, ll dis , ll col )&#123; e[++cnt].from = x ; e[cnt].to = y; e[cnt].col = col; e[cnt].dis = dis;&#125;inline ll solve(ll ad)&#123; std::memset(get,false,sizeof(get)); ll count = 0 ; for(int i = 1 ; i &lt;= m ; ++i) g[i] = e[i]; for(int i = 1 ; i &lt;= m ; ++i) if(!g[i].col) g[i].dis += ad; for(int i = 1 ; i &lt;= n ; ++i) f[i] = i; tot = 0; std::sort(g+1,g+m+1); for(int i = 1 ; i &lt;= m &amp;&amp; tot &lt; n ; ++i) &#123; int fx = find(g[i].from) , fy = find(g[i].to); if(fx != fy) &#123; f[fx] = fy; if(!g[i].col) ++count; ++tot; get[i] = true; if(tot == n-1) break; &#125; &#125; return count ;&#125;inline void print()&#123; for(int i = 1 ; i &lt;= m ; ++i) if(get[i]) printf("%lld %lld %lld\n",g[i].from , g[i].to , g[i].col);&#125;int main()&#123; srand(time(NULL)); scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); ll x , y , d , col; for(int i = 1 ; i &lt;= m ; ++i) scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;col) , d = rand() % 2122473297 + 1 , add(x , y , d , col); ll l = -100000000009 , r = 100000000009 ; while(l &lt;= r) &#123; ll mid = l + r &gt;&gt; 1; ll now = solve(mid); if(now == k) &#123;print() ;flag = 1; break;&#125; if(now &gt; k) l = mid + 1; else r = mid - 1; &#125; if(!flag) printf("no solution");&#125; 正则表达式题目背景小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。 题目描述在Internet网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在A到B的连接不一定存在B到A的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在A到B的连接的同时也存在B到A的连接的话，那么A和B实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为0。 现在小Z告诉你整个网络的构成情况，他希望知道从他的电脑（编号为1），到小X的电脑（编号为n）所需要的最短传输时间。 输入输出格式输入格式： 第一行两个整数n, m， 表示有n台电脑，m个连接关系。 接下来m行，每行三个整数u,v,w；表示从电脑u到电脑v传输信息的时间为w。 输出格式： 输出文件仅一行为最短传输时间。 输入输出样例输入样例#1： 1233 21 2 12 3 1 输出样例#1： 12 输入样例#2： 1234565 51 2 12 3 63 4 14 2 13 5 2 输出样例#2： 13 说明对于40%的数据，1&lt;=n&lt;=1000, 1&lt;=m&lt;=10000 对于70%的数据，1&lt;=n&lt;=5000, 1&lt;=m&lt;=100000 对于100%的数据，1&lt;=n&lt;=200000, 1&lt;=m&lt;=1000000 题解Tarjan缩点+DAGdp 似乎现在Tarjan缩点还是可以的，虽然Tarjan是一个我只会感性理解不会证明的算法。 Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define maxn 200005#define maxm 1000005inline int read()&#123; int x = 0 , f = 1; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') if(ch == '-') f = -1 , ch = getchar() ; else ch = getchar(); while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = x * 10 + ch - 48; return x * f;&#125;int head[maxn] , n , m , id[maxn] , tot , x , y , dis , cnt , h[maxn] , cntr , dfn[maxn] , low[maxn] , idx , d[maxn] , f[maxn] , s , t;bool get[maxn] , ins[maxn] , vis[maxn];std::stack&lt;int&gt; st;struct edge&#123; int next , to , dis;&#125;e[maxm*2] , r[maxm*2];inline void add(int x , int y , int d)&#123; e[++cnt].next = head[x] ; e[cnt].to = y; e[cnt].dis = d; head[x] = cnt;&#125;inline void addr(int x , int y , int dis)&#123; r[++cntr].next = h[x] ; r[cntr].to = y; r[cntr].dis = dis; h[x] = cntr; ++d[y];&#125;void Tarjan(int x)&#123; dfn[x] = low[x] = ++idx; st.push(x); ins[x] = true; for(int i = head[x] ; i ; i = e[i].next) &#123; int v = e[i].to; if(!dfn[v]) &#123; Tarjan(v); low[x] = std::min(low[x] , low[v]); &#125; else if(dfn[v] &amp;&amp; ins[v]) low[x] = std::min(low[x] , dfn[v]); &#125; if(dfn[x] == low[x]) &#123; ++tot; while(st.top() != x) &#123; id[st.top()] = tot; ins[st.top()] = false; if(st.top() == 1) s = tot; if(st.top() == n) t = tot; st.pop(); &#125; id[st.top()] = tot; if(st.top() == 1) s = tot; if(st.top() == n) t = tot; ins[st.top()] = false ; st.pop(); &#125;&#125;void Print(int x)&#123; // putchar(10); putchar(10); for(int i = h[x] ; i ; i = r[i].next) if(!vis[i]) printf("%d -&gt; %d\n",x,r[i].to) , vis[x] = true , Print(r[i].to);&#125;inline int dp()&#123; std::queue&lt;int&gt; q; std::memset(f,0x7f,sizeof(f)); f[s] = 0; q.push(s); while(!q.empty()) &#123; int k = q.front(); q.pop(); for(int i = h[k] ; i ; i = r[i].next) &#123; f[r[i].to] = std::min(f[r[i].to] , f[k] + r[i].dis) , --d[r[i].to]; if(!d[r[i].to]) q.push(r[i].to); &#125; &#125; return f[t];&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1 ; i &lt;= m ; ++i) scanf("%d%d%d",&amp;x,&amp;y,&amp;dis), add(x,y,dis); for(int i = 1 ; i &lt;= n ; ++i) if(!dfn[i]) Tarjan(i); // for(int i = 1 ; i &lt;= n ; ++i) // printf("%d ",id[i]); for(int i = 1 ; i &lt;= n ; ++i) for(int j = head[i] ; j ; j = e[j].next) if(id[i] != id[e[j].to]) addr(id[i] , id[e[j].to] , e[j].dis); dp(); printf("%d",f[t]);&#125; 构造完全图题目描述对于完全图 G，若有且仅有一棵最小生成树为 T，则称完全图 G 是树 T 扩展出的。 给你一棵树 T，找出 T 能扩展出的边权和最小的完全图 G。 输入格式第一行 N 表示树 T 的点数； 接下来 N−1行三个整数 Si,Ti,Di；描述一条边 保证输入数据构成一棵树。 输出格式输出仅一个数，表示最小的完全图 G 的边权和。 样例样例输入12344 1 2 1 1 3 1 1 4 2 样例输出112 样例说明添加 D(2,3)=2,D(3,4)=3,D(2,4)=3D(2, 3)=2, D(3, 4)=3, D(2, 4)=3D(2,3)=2,D(3,4)=3,D(2,4)=3 即可。 数据范围与提示对于 20% 的数据， N≤10对于 50% 的数据， N≤1000对于 100%的数据， N\le 10^5, 1\le D_i\le 10^5题解一道根据Kruskal贪心的好题。 我们想象一下原来的完全做最小生成树的过程。 当合并两个联通块的时候，设这两个联通块的大小分别为x,y 它们之间有x*y条边，其中一条是最小生成树的边，由题目给定，另外的只需要是这条边边长+1就可以了，为什么呢? 为什么呢？因为Kruskal在之前合并两个联通块的时候用的是不大于当前的边，这意味着只要我们当前连的边不会替代当前这条边（也就是大于等于，即+1），就不会和两个联通块内部的边造成冲突。 因此将MST的边从小到大排序，合并的同时统计答案即可。 [HAOI2012]容易题题目描述为了使得大家高兴，小Q特意出个自认为的简单题（easy）来满足大家，这道简单题是描述如下： 有一个数列A已知对于所有的A[i]都是1~n的自然数，并且知道对于一些A[i]不能取哪些值，我们定义一个数列的积为该数列所有元素的乘积，要求你求出所有可能的数列的积的和 mod 1000000007的值，是不是很简单呢？呵呵！ 输入输出格式输入格式： 第一行三个整数n,m,k分别表示数列元素的取值范围，数列元素个数，以及已知的限制条数。 接下来k行，每行两个正整数x,y表示A[x]的值不能是y。 输出格式： 一行一个整数表示所有可能的数列的积的和对1000000007取模后的结果。如果一个合法的数列都没有，答案输出0。 输入输出样例输入样例#1： 1234563 4 51 11 12 22 34 3 输出样例#1： 190 说明样例解释 A[1]不能取1 A[2]不能去2、3 A[4]不能取3 所以可能的数列有以下12种 数列 积 2 1 1 1 2 2 1 1 2 4 2 1 2 1 4 2 1 2 2 8 2 1 3 1 6 2 1 3 2 12 3 1 1 1 3 3 1 1 2 6 3 1 2 1 6 3 1 2 2 12 3 1 3 1 9 3 1 3 2 18 30%的数据 n]]></content>
      <tags>
        <tag>DAGdp 贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The function test for the blog]]></title>
    <url>%2F2017%2F01%2F02%2FAll%20Tests%20for%20function%2F</url>
    <content type="text"><![CDATA[lim_{1\to+\infty}P(|\frac{1}{n}\sum_i^nX_i-\mu|]]></content>
  </entry>
</search>
